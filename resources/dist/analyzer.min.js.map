{"version":3,"sources":["analyzer-objects/Analyzer.js","analyzer-objects/Bloc.js","analyzer-objects/Report.js","analyzer-objects/Section.js","analyzer-objects/Report/Report_Aggregate.js","analyzer-objects/Report/Report_Controls.js","analyzer-objects/Report/Report_Grouped.js"],"names":["Analyzer","[object Object]","this","I","Report","new","init","n","d","Options","Decimals","Selected","undefined","toFixed","v","log","Math","log10","Value","Shift","getValue","Unit","shiftForUnit","Name","isNaN","maxL","width","max","o","html","LogScale","headerConcLog","name","shift","rootForUnit","Type","logValue","out","roundNb","c","inner","value","title","noData","Class","Border","Index","Title","ReturnLength","HTML","Length","length","toString","array","maxLength","forEach","e","i","Types","Titles","cellForValue","rowWidth","columnIndex","options","style","Collapse","row","Rows","divHeight","l","Sync","stats","Total","Avg","SD","CV","N","numericOnly","val","type","isNumeric","push","avg","sumVariance","map","pow","reduce","a","b","sqrt","Stats","column","Visible","Label","output","arrayToColumn","Values","StatsOnly","display","t","event","target","tr","parentElement","me","cellIndex","scrollActive","Scroll","scrollTop","htmlCollection","getElementsByClassName","j","rows","cols","values","aggregation","headTop","headBottom","col","header","valueHeader","r","groupedDataRow","rowV","rowTag","Tags","data","includes","Number","S","arrayToRow","Array","fill","table","txt","start","TableType","rowToString","innerRowToString","UI","DataView","groupedTableToString","cells","format","ExportFormat","valueFromCell","cell","innerText","hasAttribute","getAttribute","Start","index","dataFound","temp","children","content","AfterLine","aggreg","AllCols","groupedColCount","eltMax","groupedEltMaxPerCol","groupedHeader","groupedHeaderRow","rowTableToString","h","Top","Bottom","headerTop","headerBottom","topOffset","bottomOffset","pad","padEnd","first","second","nextSibling","nodeName","Bloc","ID","File","Sections","SectionsTab","TabControl","Multiple","Layout","Tabs","found","sections","newSection","prop","Object","assign","section","Section","addTab","SetActive","Content","activateControls","Anchors","Output","Menu","Export","Results","PlateSelect","ResultPlate","PlateDoAll","PairingTarget","GetId","innerHTML","RespTable","window","opener","LoggedPlate","Fields","Headers","onSelect","s","os","oi","saveState","setPlates","do","restoreState","bind","FullWidth","RowNumbers","NoControls","Blocs","Active","LinkCtrl","Default","Chain","Change","enable","disable","refresh","Min","Step","Last","List","NewLine","Show","Plate","Result","pairStatus","append","buttonBar","Click","exportAll","Method","Report_Controls","Report_Aggregate","Report_Grouped","Report_Hits","report","blocs","set","OpenedTab","newBloc","source","plates","Form","open","Buttons","cancel","onCancel","close","p","lastIndexOf","cleanFileName","substring","trim","replace","resultIndex","active","jumpTo","param","ResultIndex","setValue","FirstBlocIndex","SelectedIndices","startsWith","Params","Parameters","ui","PlatesID","NavBar","Lookup","Pairing","Pair","unpaired","Html","pair","Pairs","Ranges","getDefPlate","RangeIndex","Check","DefPlateIndex","Table","Broken","change","O","state","id","bloc","Cancel","what","refreshRows","refreshDecimals","refreshCV","refreshLog","height","HTMLcollection","elt","items","maxHeight","overflowY","LogOnly","Log","setAttribute","tables","m","minWidth","bool","show","querySelectorAll","Z","JSZip","dir","folder","blob","export","BlobOnly","file","generateAsync","then","url","URL","createObjectURL","replaceButtons","revokeObjectURL","Summary","Tables","Columns","wrapper","lastChild","names","previousSibling","FileName","fullName","printable","tableIndex","ColumnName","entry","newRow","indexOf","console","warn","updatedTable","objectToTable","getTables","save","fileHeader","tableToString","Blob","fileName","download","Reporter","super","Aggregate","Combinations","A","ResolvedNames","addTabs","computeStats","button","statsAllPlates","bar","selectAll","insertAdjacentHTML","prepend","Definition","sel","Area","resolveNames","updateNames","Preserve","NameResolved","resolveAllNames","promises","Promise","resolve","all","defIndex","factor","MaxRange","args","Factor","AreaName","Column","Mapping","Mapper","definition","RangeIndexBase0","FindAll","find","modeWellPlate","range","collection","getElementsByTagName","th","string","pos","end","selectedPlate","Items","Areas","waitMessage","custom","well","plate","parser","wellIndex","scan","Custom","params","getBloc","blocName","replaceContent","getValues","processValues","plateSummary","getSection","valueTable","valueIndex","plateSummaryTables","updateTable","hideAllTables","lock","plateCounter","plateIterator","current","next","running","done","currentPlate","hasData","plateCount","unlock","zFactor","Controls","P","control","controlHTML","computeZFactor","zScoreAllPlates","b_pos","b_neg","Neg","Pos","Numeric","neg","getControlValues","scores","processZscore","controls","zScoreTable","Score","todo","zScoreFromStats","Scores","windowFromStats","enough","score","z","abs","classForZ","w","min","classForW","Zscores","Wscores","combinationName","Grouped","Available","Concentrations","Conc","onDelete","onUpdate","Action","compute","Cols","buttons","addData","Ready","remove","available","selected","availableMenu","Size","updateSelectedData","onInit","addEventListener","moveRow","category","sourceID","targetID","toDisplay","div","cat","obj","insertBefore","childs","inserted","update","paramIndex","groupedTable"],"mappings":"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","file":"analyzer.min.js","sourcesContent":["//**************************************************************************************************************\r\n// ANALYZER object - Allow presentation of result and data analysis in a window separated from the Layout Editor\r\n//**************************************************************************************************************\r\nclass Analyzer {\r\n\tconstructor() {return this}\r\n\t//Static Methods\r\n\tstatic init(I) { //Read the method and prepare the report accordingly\r\n\t\tthis.Report = Report.new(I).init();\r\n\t\treturn this;\r\n\t}\r\n\tstatic roundNb(n) { //Round the number using decimal value recovered from the report control\r\n\t\tlet d = this.Report.Options.Decimals.Selected;\r\n\t\tif(n.toFixed === undefined || d == \"All\") {return n} //Not a number or all decimals required\r\n\t\treturn n.toFixed(d);\r\n\t}\r\n\tstatic logValue(v) { //Compute the log10 of the value v for the report passed\r\n\t\tlet log = Math.log10(v.Value);\r\n\t\tif(this.Report.Options.Shift.getValue()) { //Shift to the higher unit\r\n\t\t\treturn log + Unit.shiftForUnit(v.Name);\r\n\t\t}\r\n\t\treturn log;\r\n\t}\r\n\tstatic isNumeric(v) { //Returns a boolean to indicate if the value is text or number\r\n\t\treturn (v !== undefined && v.toFixed !== undefined && isNaN(v) == false);\r\n\t}\r\n\tstatic divHeight(n) { //Compute the height of the div required to display n rows\r\n\t\treturn (1.65 * (n + 0.5)) + \"em\"; //Row height is ~1.65em (1.25em + 0.4 padding) per default, add half a row to let the user know something is below\r\n\t}\r\n\tstatic rowWidth(n, maxL) { //Compute the width of a row to accomodate n elements with their max length given\r\n\t\tlet width = maxL * n * 0.9 * (1 - (0.2 * maxL/20)); //font-size is 0.9em; the last factor is to shorten longest numbers (up to 20%), because 1 digit is less than 0.9em in width\r\n\t\twidth = Math.max(width, 2);\r\n\t\treturn width + \"em\";\r\n\t}\r\n\tstatic noData() { //The string used to indicate this cell has no data\r\n\t\treturn \"<span class=\\\"warning\\\">&Oslash;</span>\";\r\n\t}\r\n\tstatic header(o) { //Return the html header for the row/col object provided\r\n\t\tif(o.Unit) {\r\n\t\t\tlet html = \"<span class=\\\"Header_Conc\\\" name=\\\"\" + o.Name + \"\\\">\";\r\n\t\t\tif(this.Report.Options.LogScale.getValue()) {html += this.headerConcLog(o.Name)}\r\n\t\t\telse {html += o.Name}\r\n\t\t\treturn html + \"</span>\";\r\n\t\t}\r\n\t\treturn o.Name;\r\n\t}\r\n\tstatic headerConcLog(name, shift) { //Wrap the name into a log10(...) text\r\n\t\tif(shift) {name = Unit.rootForUnit(name)}\r\n\t\treturn \"Log<sub>10</sub>(\" + name + \")\";\r\n\t}\r\n\tstatic valueHeader(v) { //Return the html header for the value object v\r\n\t\tif(v.Type == \"Conc\") {\r\n\t\t\tlet log = this.logValue(v);\r\n\t\t\tlet out = \"\";\r\n\t\t\tif(this.Report.Options.LogScale.getValue()) {out = this.roundNb(log)}\r\n\t\t\telse {out = this.roundNb(v.Value)}\r\n\t\t\treturn \"<th class=\\\"Value_PlaceHolder Header_Conc\\\" value=\\\"\" + v.Value + \"\\\" logvalue=\\\"\" + log + \"\\\" shift=\\\"\" + Unit.shiftForUnit(v.Name) + \"\\\">\" + out + \"</th>\";\r\n\t\t}\r\n\t\treturn \"<th>\" + v.Name + \"</th>\";\r\n\t}\r\n\tstatic cellForValue(v, I) { //prepare a cell to hold a numeric or textual value\r\n\t\tlet c = \" class=\\\"\";\r\n\t\tlet inner = v;\r\n\t\tlet value = \"\";\r\n\t\tlet title = \"\";\r\n\t\tif(v === \"\") {inner = this.noData()} //Mind the type equality, because 0 == \"\" evaluates to true\r\n\t\tif(I) { //Look the options\r\n\t\t\tif(I.Class) {c += I.Class + \" \"}\r\n\t\t\tif(I.Border && I.Index > 0) {c += \"BorderLeft \"}\r\n\t\t\tif(I.Type == \"#\" && v !== \"\") { //Number should use the value placeHolder\r\n\t\t\t\tinner = this.roundNb(v);\r\n\t\t\t\tc += \"Value_PlaceHolder\";\r\n\t\t\t\tvalue = \" value=\\\"\" + v + \"\\\"\";\r\n\t\t\t}\r\n\t\t\tif(I.Title) {title = \" title=\\\"\" + I.Title + \"\\\"\"}\r\n\t\t\tif(I.ReturnLength) {\r\n\t\t\t\tlet html = \"<td\" + c + \"\\\"\" + value + title + \">\" + inner + \"</td>\";\r\n\t\t\t\tif(v === \"\") {return {HTML: html, Length: 2}}\r\n\t\t\t\telse {\r\n\t\t\t\t\tif(inner.length === undefined) { //In case the value is a number that we want to treat as text\r\n\t\t\t\t\t\treturn {HTML: html, Length: inner.toString().length}\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn {HTML: html, Length: inner.length}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn \"<td\" + c + \"\\\"\" + value + title + \">\" + inner + \"</td>\";\r\n\t}\r\n\tstatic arrayToRow(array, I) { //Convert the array of values into an innerTable with a single row\r\n\t\tlet html = \"\";\r\n\t\tlet maxLength = 0;\r\n\t\tif(array.length == 0) {html += \"<td>\" + this.noData() + \"</td>\"}\r\n\t\telse {\r\n\t\t\tarray.forEach(function(e, i) {\r\n\t\t\t\tlet o = {Border: true, Index: i, ReturnLength: true}\r\n\t\t\t\tif(I) {\r\n\t\t\t\t\tif(I.Types) {o.Type = I.Types[i]}\r\n\t\t\t\t\tif(I.Titles) {o.Title = I.Titles[i]}\r\n\t\t\t\t}\r\n\t\t\t\tlet out = this.cellForValue(e, o);\r\n\t\t\t\thtml += out.HTML;\r\n\t\t\t\tmaxLength = Math.max(maxLength, out.Length); //Log the max length of the string to display\r\n\t\t\t}, this);\r\n\t\t}\r\n\t\treturn \"<div class=\\\"InnerTable_Wrapper\\\"><table class=\\\"InnerTableRow\\\" style=\\\"min-width: \" + this.rowWidth(array.length, maxLength) + \"\\\"><tr>\" + html + \"</tr></table></div>\";\r\n\t}\r\n\tstatic arrayToColumn(array, columnIndex, I) { //Convert the array provided into a single column table and compute the stats for it\r\n\t\tlet options = this.Report.Options;\r\n\t\tlet style = \"\";\r\n\t\tif(options.Collapse.getValue()) {\r\n\t\t\tlet row = options.Rows.getValue();\r\n\t\t\tstyle =  \" style=\\\"max-height: \" + this.divHeight(row);\r\n\t\t\tif(array.length <= row) {style += \"; overflow-y: unset\\\"\"}\r\n\t\t\telse {style += \"; overflow-y: scroll\\\"\"}\r\n\t\t}\r\n\t\tlet html = \"<td class=\\\"Border\\\"\";\r\n\t\tlet l = array.length;\r\n\t\tif(l > 1) {html += \" style=\\\"vertical-align: top\\\"\"}\r\n\t\thtml += \"><div class=\\\"InnerTable_Wrapper\\\"\" + style;\r\n\t\tif(I && I.Sync) {html += \" onmouseenter=\\\"Analyzer.scrollActive = \" + columnIndex + \"\\\" onscroll=\\\"Analyzer.syncScrolling()\\\"\"}\r\n\t\thtml += \"><table class=\\\"InnerTable\\\">\";\r\n\t\tlet stats = {Total: 0, Avg: \"\", SD: \"\", CV: \"\", N: 0} //Keep defaults as text so that nothing is displayed if no or not enough elements to calculate it\r\n\t\tlet numericOnly = []; //An array to store only numeric values, in case some text is also present\r\n\t\tarray.forEach(function(val, i) {\r\n\t\t\tlet v = val;\r\n\t\t\tif(val.Value !== undefined) {v = val.Value}\r\n\t\t\tlet isNumeric = this.isNumeric(v);\r\n\t\t\tlet type = \"#\";\r\n\t\t\tif(isNumeric == false) {type = \"Text\"}\r\n\t\t\telse { //Push the numeric values only and exclude the text\r\n\t\t\t\tnumericOnly.push(v);\r\n\t\t\t\tstats.Total += v;\r\n\t\t\t} \r\n\t\t\thtml += \"<tr>\" + this.cellForValue(v, {Type: type, Class: val.Class}) + \"</tr>\"; \r\n\t\t}, this);\r\n\t\tif(l == 0) {html += \"<tr><td>\" + this.noData() + \"</td></tr>\"} //The array was empty\r\n\t\thtml += \"</table></div></td>\";\r\n\t\tlet n = numericOnly.length;\r\n\t\tif(n > 0) { //At least one numeric value was found\r\n\t\t\tlet avg = stats.Total / n;\r\n\t\t\tstats.Avg = avg;\r\n\t\t\tif(n > 1) {\r\n\t\t\t\tlet variance = numericOnly.map(function(v) {//return an array for which each element x is now (x-avg)^2\r\n\t\t\t\t\treturn(Math.pow(v - avg, 2));\r\n\t\t\t\t}); \r\n\t\t\t\tlet sumVariance = variance.reduce(function(a, b) {return(a + b)});\r\n\t\t\t\tlet SD = Math.sqrt(sumVariance / n); //Population SD, computed with 1/N (For Sample SD, we should use 1/N-1, but population SD is more natural: [8, 12] => pSD = 2; sSD = 2.82)\r\n\t\t\t\tstats.SD = SD;\r\n\t\t\t\tstats.CV = 100 * SD / avg;\r\n\t\t\t}\r\n\t\t}\r\n\t\tstats.N = l;\r\n\t\tif(n != l) {stats.N = n + \" (\" + l + \")\"} //Inform that not all values were used\r\n\t\treturn {HTML: html, Stats: stats}\r\n\t}\r\n\tstatic objectToTable(o, I) { //Return an html table representing the array of object passed. Each object should have a \"Values\" property, containing the array of values\r\n\t\tlet html = \"\";\r\n\t\thtml += \"<table class=\\\"OuterTable\\\">\";\r\n\t\thtml += \"<tr><td></td>\"; //Table headers, leave an empty columns for the legend; use <td> so that it has no borders\r\n\t\to.forEach(function(column) { //Append the headers\r\n\t\t\tif(column.Visible) {html += \"<th>\" + column.Label + \"</th>\"}\r\n\t\t}); \r\n\t\thtml += \"</tr><tr><td></td>\";\r\n\t\tlet stats = [];\r\n\t\to.forEach(function(column, c) { //Compute stats for all columns. Only visible columns will be displayed\r\n\t\t\tlet output = this.arrayToColumn(column.Values, c, I);\r\n\t\t\tstats.push(output.Stats);\r\n\t\t\tif(column.Visible) {html += output.HTML}\r\n\t\t}, this);\r\n\t\tif(I && I.StatsOnly) {return {Stats: stats}} //The rest of the html is not processed if only the stats are needed\r\n\t\thtml += \"</tr><tfoot>\";\r\n\t\thtml += \"<tr title=\\\"Mean of the numerical values for this column. Not available for text\\\"><td>Average</td>\";\r\n\t\to.forEach(function(column, c) {\r\n\t\t\tif(column.Visible) {html += Analyzer.cellForValue(stats[c].Avg, {Type: \"#\"})}\r\n\t\t});\r\n\t\thtml += \"</tr>\";\r\n\t\thtml += \"<tr title=\\\"Standard deviation of the numerical values for this column. Available with 2 or more values\\\"><td>SD</td>\";\r\n\t\to.forEach(function(column, c) {\r\n\t\t\tif(column.Visible) {html += Analyzer.cellForValue(stats[c].SD, {Type: \"#\"})}\r\n\t\t});\r\n\t\thtml += \"</tr>\";\r\n\t\tlet display = \"none\";\r\n\t\tif(this.Report.Options.CV.getValue()) {display = \"table-row\"} //Show CV only if desired\r\n\t\thtml += \"<tr class=\\\"CV_Row\\\" style=\\\"display: \" + display + \"\\\" title=\\\"Coefficient of variation for the numerical values in this column. Available with 2 or more values\\\"><td>CV (%)</td>\";\r\n\t\to.forEach(function(column, c) {\r\n\t\t\tif(column.Visible) {html += Analyzer.cellForValue(stats[c].CV, {Type: \"#\"})}\r\n\t\t});\r\n\t\thtml += \"</tr>\";\r\n\t\thtml += \"<tr title=\\\"Count of valid numerical values for this column. If textual, invalid or empty values are present, the total count of values is indicated in parenthesis\\\"><td>N</td>\";\r\n\t\to.forEach(function(column, c) {\r\n\t\t\tif(column.Visible) {html += \"<td>\" + stats[c].N + \"</td>\"} //There is no need to adjust decimals here as N is an integer\r\n\t\t});\r\n\t\thtml += \"</tr></tfoot>\";\r\n\t\thtml += \"</table>\";\r\n\t\treturn {HTML: html, Stats: stats}\r\n\t}\r\n\tstatic syncScrolling() { //Sync column scrolling within a table\r\n\t\tlet t = event.target;\r\n\t\tlet tr = t.parentElement;\r\n\t\tlet me = tr.cellIndex - 1;\r\n\t\tlet i = this.scrollActive;\r\n\t\tif(i == me) { //This is the element triggering the scroll on the other divs\r\n\t\t\tthis.Scroll = t.scrollTop; //Log its scroll value\r\n\t\t\tlet htmlCollection = tr.parentElement.getElementsByClassName(\"InnerTable_Wrapper\"); //This is NOT an array, so we have to use a for loop to traverse it\r\n\t\t\tlet l = htmlCollection.length;\r\n\t\t\tfor(let j=0; j<l; j++) { //For each synchronized div\r\n\t\t\t\tif(j != i) { //If you are not the one that triggered the scroll\r\n\t\t\t\t\tlet div = htmlCollection[j];\r\n\t\t\t\t\tdiv.scrollTop = this.Scroll; //Update the scroll position. This will trigger the scroll event for this element, which will do nothing\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tstatic groupedTable(rows, cols, values, aggregation) { //Build a 2d/grouped table using the rows/cols data and values provided. Rows/Cols are arrays of objects that include a Values property, in which the tags array hold the index where to find the values in the values array provided\r\n\t\tlet html = \"\";\r\n\t\thtml += \"<table class=\\\"OuterTable\\\">\";\r\n\t\tlet headTop = \"<tr><td rowspan=\\\"2\\\"></td><td rowspan=\\\"2\\\"></td>\"; //Table headers, leave two empty columns for the legend; use <td> so that it has no borders\r\n\t\tlet headBottom = \"<tr>\";\r\n\t\tcols.forEach(function(col) { //Travel the cols to prepare the headers\r\n\t\t\tlet l = col.Values.length;\r\n\t\t\tif(l == 1) {headTop += \"<th rowspan = \\\"2\\\">\" + this.header(col) + \"</th>\"} //Only one value for this group\r\n\t\t\telse { //A group with more than one values\r\n\t\t\t\theadTop += \"<th colspan=\\\"\" + col.Values.length + \"\\\">\" + this.header(col) + \"</th>\"; //The header for the group\r\n\t\t\t\tcol.Values.forEach(function(v) { //Append all the values \r\n\t\t\t\t\theadBottom += this.valueHeader(v);\r\n\t\t\t\t}, this);\r\n\t\t\t}\r\n\t\t}, this);\r\n\t\thtml += headTop + \"</tr>\" + headBottom + \"</tr>\";\r\n\t\trows.forEach(function(row, i) { //Travel the rows\r\n\t\t\tlet r = row.Values.length;\r\n\t\t\tif(r == 1) { //This group has only one value, it needs only one row\r\n\t\t\t\thtml += \"<tr><th>\" + this.header(row) + \"</th>\" + this.valueHeader(row.Values[0]); //There is only one value\r\n\t\t\t\thtml += this.groupedDataRow(row.Values[0], cols, values, aggregation);\r\n\t\t\t\thtml += \"</tr>\";\r\n\t\t\t}\r\n\t\t\telse { //Several rows are needed\r\n\t\t\t\thtml += \"<tr><th rowspan=\\\"\" + r + \"\\\">\" + this.header(row) + \"</th>\";\r\n\t\t\t\trow.Values.forEach(function(rowV, j) {\r\n\t\t\t\t\tif(j > 0) {html += \"<tr>\"}\r\n\t\t\t\t\thtml += this.valueHeader(rowV);\r\n\t\t\t\t\thtml += this.groupedDataRow(rowV, cols, values, aggregation);\r\n\t\t\t\t\thtml += \"</tr>\";\r\n\t\t\t\t}, this);\r\n\t\t\t}\r\n\t\t\thtml += \"</tr>\";\r\n\t\t}, this);\r\n\t\thtml += \"</table>\";\r\n\t\treturn {HTML: html}\r\n\t}\r\n\tstatic groupedDataRow(row, cols, values, aggregation) { //Prepare a row of data for the row object passed, by collecting and appending the values for all cols\r\n\t\tlet html = \"\";\r\n\t\tlet rowTag = row.Tags;\r\n\t\tcols.forEach(function(col) { //Travel the groups\r\n\t\t\tcol.Values.forEach(function(v) { //Travel all the items\r\n\t\t\t\tlet data = []; //The data to recover for this row/col coordinate\r\n\t\t\t\tv.Tags.forEach(function(t) {\r\n\t\t\t\t\tif(rowTag.includes(t)) {data.push(Number(values[t]))} //Insert data at indices of well shared by the row and the col\r\n\t\t\t\t});\r\n\t\t\t\tlet out = this.arrayToColumn(data); //Compute the stats for the values and prepare the html for a vertical table\r\n\t\t\t\tlet S = out.Stats;\r\n\t\t\t\tswitch(aggregation) { //How to display multiple data will be different depending on aggregation\r\n\t\t\t\t\tcase \"Row\": html += \"<td class=\\\"Border\\\">\" + this.arrayToRow(data, {Types: Array(data.length).fill(\"#\")}) + \"</td>\"; break; //Display values as a horizontal table\r\n\t\t\t\t\tcase \"Average\": html += this.cellForValue(S.Avg, {Class: \"BorderSpaced\", Type: \"#\"}); break;\r\n\t\t\t\t\tcase \"Avg, SD, N\": html += \"<td class=\\\"Border\\\">\" + this.arrayToRow([S.Avg, S.SD, S.N], {Types: [\"#\", \"#\", \"Text\"], Titles: [\"Average\", \"SD\", \"N\"]}) + \"</td>\"; break;\r\n\t\t\t\t\tdefault: html += out.HTML; break;\r\n\t\t\t\t}\r\n\t\t\t}, this);\r\n\t\t}, this);\r\n\t\treturn html;\r\n\t}\r\n//*************************************************\r\n//Methods for the export of data tables to txt file\r\n//*************************************************\r\n\tstatic tableToString(table, I) { //Convert the DOM element table into a text string suitable for export as a tab-delimited file\r\n\t\tlet txt = \"\";\r\n\t\tif(I && I.Title) {txt = I.Title + \"\\n\"} //Add a title if needed\r\n\t\tlet rows = table.rows;\r\n\t\tlet r = rows.length;\r\n\t\tlet start = 0; //Index of the row where to start the for loop\r\n\t\tif(I && I.TableType) {\r\n\t\t\tswitch(I.TableType) {\r\n\t\t\t\tcase \"Inner\": //In this case, the table has inner tables within its columns\r\n\t\t\t\t\ttxt += this.rowToString(rows[0]) + \"\\n\"; //Prepare the headers\r\n\t\t\t\t\ttxt += this.innerRowToString(rows[1]) + \"\\n\"; //The tricky part is to export correctly the inner tables\r\n\t\t\t\t\tstart = 2; //The footer part is straightforward\r\n\t\t\t\t//FALL-THROUGH\r\n\t\t\t\tcase \"Simple\": \r\n\t\t\t\t\tfor(let i=start; i<r; i++) { //Prepare the output\r\n\t\t\t\t\t\tif(rows[i].style.display != \"none\") { //Ignore hidden rows\r\n\t\t\t\t\t\t\tif(i > start) {txt += \"\\n\"}\r\n\t\t\t\t\t\t\ttxt += this.rowToString(rows[i]);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\t\tcase \"Grouped\":\r\n\t\t\t\t\ttxt = \"Aggregation method: \" + this.Report.UI.DataView.Selected + \"\\n\";\r\n\t\t\t\t\ttxt += this.groupedTableToString(table);\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn txt;\r\n\t}\r\n\tstatic rowToString(row) { //Convert a DOM row element into a string. The row contains only text/numbers as inner content\r\n\t\tlet out = \"\";\r\n\t\tlet cells = row.cells;\r\n\t\tlet c = cells.length;\r\n\t\tlet format = (this.Report.Options.ExportFormat.getValue() == 1); //true means use the formatted data\r\n\t\tlet log = this.Report.Options.LogScale.getValue();\r\n\t\tfor(let j=0; j<c; j++) {\r\n\t\t\tif(j > 0) {out += \"\\t\"}\r\n\t\t\tout += this.valueFromCell(cells[j], format, log);\r\n\t\t}\r\n\t\treturn out;\r\n\t}\r\n\tstatic valueFromCell(cell, format, log) { //Extract the value for the DOM cell object provided, formatted as in the cell or the real file value based on the format boolean\r\n\t\tif(format) {return cell.innerText} //Easy\r\n\t\tif(cell.hasAttribute(\"logvalue\") && log) {return cell.getAttribute(\"logvalue\")}\r\n\t\tif(cell.hasAttribute(\"value\")) {return cell.getAttribute(\"value\")}\r\n\t\treturn cell.innerText;\r\n\t}\r\n\tstatic innerRowToString(row, I) { //Convert a DOM row table containing an innerTable with values into a string\r\n\t\tlet format = (this.Report.Options.ExportFormat.getValue() == 1); //true means use the formatted data\r\n\t\tlet log = this.Report.Options.LogScale.getValue();\r\n\t\tlet start = 1;\r\n\t\tif(I && I.Start) {start = I.Start}\r\n\t\tlet inner = \"\";\r\n\t\tlet index = 0;\r\n\t\tlet dataFound = true;\r\n\t\tlet l = row.cells.length;\r\n\t\twhile(dataFound) { //As long as we can find data within the innerTables, create a new line with the data\r\n\t\t\tlet temp = \"\\t\";\r\n\t\t\tdataFound = false; //The loop should stop when no more data are found\r\n\t\t\tfor(let n=start; n<l; n++) { //Travel all the columns to collect the data. Start at the specified column index\r\n\t\t\t\tlet cell = row.cells[n].children[0].children[0].rows[index]; //The cell is wrapped in a table, within a div\r\n\t\t\t\tlet content = \"\";\r\n\t\t\t\tif(cell) { //If this cell exist, get its content\r\n\t\t\t\t\tdataFound = true; \r\n\t\t\t\t\tcontent = this.valueFromCell(cell.children[0], format, log);\r\n\t\t\t\t}\r\n\t\t\t\tif(n > start) {temp += \"\\t\"} //In any case, add a tab to respect column ordering\r\n\t\t\t\ttemp += content;\r\n\t\t\t}\r\n\t\t\tif(dataFound) { //We found something, collate it to the string to output\r\n\t\t\t\tif(index > 0) {\r\n\t\t\t\t\tinner += \"\\n\";\r\n\t\t\t\t\tif(I && I.AfterLine !== undefined) {inner += I.AfterLine}\r\n\t\t\t\t}\r\n\t\t\t\tinner += temp;\r\n\t\t\t}\r\n\t\t\tindex++; //Increment the index and continue until the data are exhausted\r\n\t\t}\r\n\t\treturn inner;\r\n\t}\r\n\tstatic groupedTableToString(table) { //Convert a DOM grouped table into a string\r\n\t\tlet format = (this.Report.Options.ExportFormat.getValue() == 1); //true means use the formatted data\r\n\t\tlet log = this.Report.Options.LogScale.getValue();\r\n\t\tlet txt = \"\";\r\n\t\tlet rows = table.rows;\r\n\t\tlet aggreg = this.Report.UI.DataView.Selected; //Data representation will depend on this factor\r\n\t\tlet AllCols = this.groupedColCount(rows[0].cells); //The number of data columns to output\r\n\t\tlet eltMax = this.groupedEltMaxPerCol(rows, AllCols);\r\n\t\ttxt += this.groupedHeader(rows[0], rows[1], AllCols, eltMax, format, log); //Headers for the table\r\n\t\tlet r = rows.length;\r\n\t\tfor(let i=2; i<r; i++) { //Travel the rows, ignoring the headers, to build the output\r\n\t\t\ttxt += \"\\n\" + this.groupedHeaderRow(rows[i].cells[0], rows[i].cells[1], format, log);\r\n\t\t\tlet n = rows[i].cells.length;\r\n\t\t\tlet start = n - AllCols; //Rows for elements within a group have one column header only and should start with a different offset\r\n\t\t\tswitch(aggreg) { //The aggregation method indicates what to expect for the inner Tables\r\n\t\t\t\tcase \"Column\": txt += this.innerRowToString(rows[i], {Start: start, AfterLine: \"\\t\"}); break; //The entire row is processed by this method. Important to add a tab after each line to keep correct column ordering\r\n\t\t\t\tcase \"Average\": //In this mode, a simple cell hold the value\r\n\t\t\t\t\tfor(let j=0; j<AllCols; j++) { //Travel the cols to build the output\r\n\t\t\t\t\t\ttxt += \"\\t\" + this.valueFromCell(rows[i].cells[start + j], format, log);\r\n\t\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\t\tdefault: //Remaining cases, data are in line and a InnerTableRow hold the data\r\n\t\t\t\t\tfor(let j=0; j<AllCols; j++) { //Travel the cols to build the output\r\n\t\t\t\t\t\ttxt += this.rowTableToString(rows[i].cells[start + j].children[0].children[0], eltMax[j], format, log); //The child table is within a div\r\n\t\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn txt;\r\n\t}\r\n\tstatic groupedColCount(cells) { //For a grouped table, calulate the number of columns by flattening the sub-groups\r\n\t\tlet cols = 0; //The number of data columns to output\r\n\t\tlet h = cells.length;\r\n\t\tfor(let i=2; i<h; i++) { //Navigate the headers to define the number of cols\r\n\t\t\tlet cell = cells[i];\r\n\t\t\tif(cell.hasAttribute(\"rowspan\")) {cols++} //Individual cell that \"count\" only for 1\r\n\t\t\telse {cols += Number(cell.getAttribute(\"colspan\"))} //Group: add the number of sub-groups\r\n\t\t}\r\n\t\treturn cols;\r\n\t}\r\n\tstatic groupedEltMaxPerCol(rows, c) { //For a grouped table of c data column, capture the max number of elements per column, for each column\r\n\t\tlet r = rows.length;\r\n\t\tlet eltMax = []; //Results are stored in an array the size of the number of column\r\n\t\tlet aggreg = this.Report.UI.DataView.Selected;\r\n\t\tswitch(aggreg) { //The aggregation method indicates what to expect for the inner Tables\r\n\t\t\tcase \"Row\": //Rows of n values. In this case, need to count the max number of values per row, for each column\r\n\t\t\t\teltMax = Array(c).fill(0);\r\n\t\t\t\tfor(let i=2; i<r; i++) { //Look all rows, ignoring the headers\r\n\t\t\t\t\tlet inner = rows[i].getElementsByClassName(\"InnerTableRow\");\r\n\t\t\t\t\tfor(let j=0; j<c; j++) { //Go through the inner tables; there must be exactly one per column to output\r\n\t\t\t\t\t\teltMax[j] = Math.max(eltMax[j], inner[j].rows[0].cells.length); //Log the max value\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\tbreak;\r\n\t\t\tcase \"Avg, SD, N\": eltMax = Array(c).fill(3); break; //Rows of 3 values\r\n\t\t\tdefault: eltMax = Array(c).fill(1); break; //Rows have only one value\r\n\t\t}\r\n\t\treturn eltMax;\r\n\t}\r\n\tstatic groupedHeader(Top, Bottom, c, eltMax, format, log) { //For a grouped table, build the output for the headers using eltMax array to pad with tabs and respect column indentation\r\n\t\tlet headerTop = \"\";\r\n\t\tlet headerBottom = \"\";\r\n\t\tlet topOffset = 2; //Tracker to follow the cells traversed in the top row. This row starts with two empty cells that span the bottom row\r\n\t\tlet bottomOffset = 0; //Tracker to follow the cells traversed in the bottom row\r\n\t\tfor(let i=0; i<c; i++) { //Navigate the data columns\r\n\t\t\tlet cell = Top.cells[topOffset];\r\n\t\t\tif(cell.hasAttribute(\"rowspan\")) { //Individual cell that \"count\" only for 1\r\n\t\t\t\tlet pad = \"\".padEnd(eltMax[i] - 1, \"\\t\");\r\n\t\t\t\theaderTop += \"\\t\" + pad;\r\n\t\t\t\theaderBottom += this.valueFromCell(cell, format, log) + \"\\t\" + pad;\r\n\t\t\t}\r\n\t\t\telse { //A group with multiple columns\r\n\t\t\t\tlet l = Number(cell.getAttribute(\"colspan\")); //The number of elements in this group\r\n\t\t\t\theaderTop += this.valueFromCell(cell, format, log); //Name of the group\r\n\t\t\t\tfor(let j=0; j<l; j++) { //Prepare the headers\r\n\t\t\t\t\tlet pad = \"\".padEnd(eltMax[i] - 1, \"\\t\");\r\n\t\t\t\t\theaderTop += \"\\t\" + pad; //Pad with enough tab to respect column indentation\r\n\t\t\t\t\theaderBottom += this.valueFromCell(Bottom.cells[bottomOffset], format, log) + \"\\t\" + pad;\r\n\t\t\t\t\tbottomOffset++;\r\n\t\t\t\t}\r\n\t\t\t\ti += (l - 1); //Also need to increment the column count\r\n\t\t\t}\r\n\t\t\ttopOffset++;\r\n\t\t}\r\n\t\treturn \"\\t\\t\" + headerTop + \"\\n\" + \"\\t\\t\" + headerBottom;\r\n\t}\r\n\tstatic groupedHeaderRow(first, second, format, log) { //For a grouped table, prepare the header for a row given its two first cells\r\n\t\tif(first.hasAttribute(\"rowspan\")) { //This marks the beginning of a group\r\n\t\t\treturn this.valueFromCell(first, format, log) + \"\\t\" + this.valueFromCell(second, format, log);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tif(first.nextSibling.nodeName == \"TD\") { //Member of a group\r\n\t\t\t\treturn \"\\t\" + this.valueFromCell(first, format, log);\r\n\t\t\t}\r\n\t\t\telse { //Group with only one element\r\n\t\t\t\treturn this.valueFromCell(first, format, log) + \"\\t\" + this.valueFromCell(second, format, log);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tstatic rowTableToString(table, pad, format, log) { //Convert the rowTable given into a string. Pad with the number of tab given if necessary to respect column order\r\n\t\tlet txt = \"\";\r\n\t\tlet cells = table.rows[0].cells;\r\n\t\tlet n = cells.length;\r\n\t\tfor(let i=0; i<pad; i++) {\r\n\t\t\tif(i<n) {txt += \"\\t\" + this.valueFromCell(cells[i], format, log)}\r\n\t\t\telse {txt += \"\\t\"}\r\n\t\t}\r\n\t\treturn txt;\r\n\t}\r\n}","//*****************************************************************************\r\n// BLOC object - First layer used to organize reporting of data in the analyzer\r\n//*****************************************************************************\r\nclass Bloc {\r\n\tconstructor(I) {\r\n\t\tthis.ID = I.ID;\r\n\t\tthis.Name = I.Name; //Internal name\r\n\t\tthis.File = I.File; //Name of the file associated to this bloc\r\n\t\tthis.Sections = [];\r\n\t\tthis.SectionsTab = new TabControl({ //Tab to manipulate the Section objects\r\n\t\t\tID: I.ID,\r\n\t\t\tMultiple: true,\r\n\t\t\tLayout: \"Horizontal\",\r\n\t\t\tTabs: [],\r\n\t\t});\r\n\t\treturn this;\r\n\t}\r\n\t//Static methods\r\n\r\n\t//Methods\r\n\tinit() { //Initialize the bloc on the page\r\n\t\tthis.SectionsTab.init();\r\n\t\treturn this;\r\n\t}\r\n\tgetSection(name, I) { //Return the section object with the given name, for the bloc provided\r\n\t\tlet found = false;\r\n\t\tlet i = 0;\r\n\t\tlet sections = this.Sections;\r\n\t\tlet l = sections.length;\r\n\t\twhile(!found && i<l) {\r\n\t\t\tif(sections[i].Name == name) {found = true}\r\n\t\t\telse {i++}\r\n\t\t}\r\n\t\tif(found) {return this.Sections[i]} //Section already exists, call it back\r\n\t\telse {return this.newSection(name, i, I)} //Create the section\r\n\t}\r\n\tnewSection(name, index, I) { //Create a new section for this bloc\r\n\t\tlet id = this.ID + \"_\" + index;\r\n\t\tlet prop = {Name: name, Bloc: this, ID: id};\r\n\t\tif(I) {Object.assign(prop, I)} //\"Concat\" properties of I and param\r\n\t\tlet section = new Section(prop);\r\n\t\tthis.Sections.push(section);\r\n\t\tthis.SectionsTab.addTab({Label: name, SetActive: true, Content: {Type: \"HTML\", Value: section.HTML(name)} });\r\n\t\tsection.activateControls(); //Activate the controls\r\n\t\treturn section;\r\n\t}\r\n}","//****************************************************************************\r\n// REPORT object - Holds the values and controls available to analyze the data\r\n//****************************************************************************\r\nclass Report {\r\n\tconstructor(o) {\r\n\t\tthis.Title = o.Title;\r\n\t\tthis.Anchors = {\r\n\t\t\tOutput: \"Output\",\r\n\t\t\tMenu: \"Menu\",\r\n\t\t\tOptions: \"Options\",\r\n\t\t\tExport: \"Export\",\r\n\t\t\tResults: \"Results\",\r\n\t\t\tPlateSelect: \"PlateSelect\",\r\n\t\t\tResultPlate: \"ResultPlate\",\r\n\t\t\tPlateDoAll: \"PlateDoAll\",\r\n\t\t\tPairingTarget: \"PairingTarget\",\r\n\t\t}\r\n\t\tlet html = \"\";\r\n\t\thtml += \"<div id=\\\"\" + this.Anchors.Menu + \"\\\"></div>\";\r\n\t\thtml += \"<div id=\\\"\" + this.Anchors.Output + \"\\\"></div>\"\r\n\t\tGetId(\"Main\").innerHTML = html;\r\n\t\tthis.Results = new RespTable({ //RespTable object controling the available result files\r\n\t\t\tID: this.Anchors.Results,\r\n\t\t\tArray: window.opener.Results.map(function(r) {r.LoggedPlate = 0; return r}), //On init, set the logged plate property to 0 for each result\r\n\t\t\tFields: [\"Name\", \"Size\", \"Info\"], Headers: [\"Name\", \"Size\", \"Parameters\"],\r\n\t\t\tonSelect: function(s, os, i, oi) { //What to do on result selection\r\n\t\t\t\tif(i[0] == oi[0]) {return} //Same result is selected, do nothing\r\n\t\t\t\tReport.saveState(this, oi[0]); //Save the current tab opened for the old selection (selected result)\r\n\t\t\t\tthis.setPlates().do();\r\n\t\t\t\tReport.restoreState(this, i[0]); //Restore the opened tab for the newly opened result\r\n\t\t\t}.bind(this), FullWidth: true, RowNumbers: true, NoControls: true,\r\n\t\t});\r\n\t\tthis.Blocs = []; //Array of bloc objects\r\n\t\tthis.Output = new TabControl({ //Tab to manipulate the Bloc objects\r\n\t\t\tID: this.Anchors.Output,\r\n\t\t\tLayout: \"Horizontal\",\r\n\t\t\tTabs: [],\r\n\t\t});\r\n\t\tthis.Menu = new TabControl({ //Menu for the report page\r\n\t\t\tID: this.Anchors.Menu,\r\n\t\t\tMultiple: true,\r\n\t\t\tLayout: \"Menu\",\r\n\t\t\tTabs: [\r\n\t\t\t\t{Label: \"Options\", Active: true, Content: {Type: \"HTML\", Value: \"<div id=\\\"\" + this.Anchors.Options + \"\\\"></div>\"} },\r\n\t\t\t\t{Label: \"Export\", Active: true, Content: {Type: \"HTML\", Value: \"<div id=\\\"\" + this.Anchors.Export + \"\\\"></div>\"} },\r\n\t\t\t\t{Label: \"Results\", Active: true, Content: {Type: \"HTML\", Value: \"<div id=\\\"\" + this.Anchors.Results + \"\\\"></div>\"} },\r\n\t\t\t\t{Label: \"Plates\", Active: true, Content: {Type: \"HTML\", Value:\r\n\t\t\t\t\t\"<fieldset id=\\\"\" + this.Anchors.PlateSelect + \"\\\">\" +\r\n\t\t\t\t\t\t\"<legend>Result</legend>\" +\r\n\t\t\t\t\t\t\"<div id=\\\"\" + this.Anchors.ResultPlate + \"\\\"></div>\" +\r\n\t\t\t\t\t\t\"<div style=\\\"text-align: center; margin-bottom: 10px\\\" id=\\\"\" + this.Anchors.PairingTarget + \"\\\"></div>\" +\r\n\t\t\t\t\t\t\"<div id=\\\"\" + this.Anchors.PlateDoAll + \"\\\"></div>\" +\r\n\t\t\t\t\t\"</fieldset>\"}\r\n\t\t\t\t},\r\n\t\t\t],\r\n\t\t});\r\n\t\tthis.Options = {\r\n\t\t\tCollapse: LinkCtrl.new(\"Checkbox\", {ID: this.Anchors.Options, Label: \"Collapse tables\", Default: true, Chain: {Index: 0}, Change: function(v) {\r\n\t\t\t\tlet r = this.Options.Rows;\r\n\t\t\t\tif(v) {r.enable()}\r\n\t\t\t\telse {r.disable()}\r\n\t\t\t\tthis.refresh(\"Rows\", {Collapse: v, Rows: r.getValue()});\r\n\t\t\t}.bind(this), Title: \"Tick to limit the number of rows displayed in tables\"}),\r\n\t\t\tRows: LinkCtrl.new(\"Number\", {ID: this.Anchors.Options, Label: \"Rows\", Default: 10, Min: 2, Step: 1, Chain: {Index: 1, Last: true}, Change: function(v) {\r\n\t\t\t\tthis.refresh(\"Rows\", {Collapse: true, Rows: v});\r\n\t\t\t}.bind(this), Title: \"Maximum number of rows to show for each table\"}),\r\n\t\t\tDecimals: LinkCtrl.new(\"Select\", {ID: this.Anchors.Options, Label: \"Decimals\", Default: 3, List: [0, 1, 2, 3, 4, 5, 6, \"All\"], Chain: {Index: 2, NewLine: true}, Change: function(v) {\r\n\t\t\t\tthis.refresh(\"Decimals\");\r\n\t\t\t}.bind(this), Title: \"Number of decimals to show for the computed values. Parsed values from the file are not affected\"}),\r\n\t\t\tCV: LinkCtrl.new(\"Checkbox\", {ID: this.Anchors.Options, Label: \"Show CV\", Default: false, Chain: {Index: 3, Last: true}, Change: function(v) {\r\n\t\t\t\tthis.refresh(\"CV\", {Show: v});\r\n\t\t\t}.bind(this), Title: \"Tick to show the coefficient of varation (CV, %) for the data\"}),\r\n\t\t\tLogScale: LinkCtrl.new(\"Checkbox\", {ID: this.Anchors.Options, Label: \"Log Scale\", Default: false, Chain: {Index: 4, NewLine: true}, Change: function(v) {\r\n\t\t\t\tthis.refresh(\"Log\");\r\n\t\t\t}.bind(this), Title: \"Tick to show the concentration data in log scale\"}),\r\n\t\t\tShift: LinkCtrl.new(\"Checkbox\", {ID: this.Anchors.Options, Label: \"Shift unit\", Default: false, Chain: {Index: 5, Last: true}, Change: function(v) {\r\n\t\t\t\tthis.refresh(\"Log\");\r\n\t\t\t}.bind(this), Title: \"Tick to shift the concentration data to their closest parent value (i.e. M or g/mL) when using the log scale\"}),\r\n\t\t\tExportFormat: LinkCtrl.new(\"Radio\", {ID: this.Anchors.Export, Default: 0, Label: \"Export values\", List: [\"From file\", \"Displayed\"], Title: \"Controls wheter the exported data should be as they appear in the file (From file), or as they appear in the table (Displayed)\"}),\r\n\t\t}\r\n\t\tthis.UI = { //Container for specific LinkCtrl elements\r\n\t\t\tPlate: LinkCtrl.new(\"Select\", {ID: this.Anchors.ResultPlate, Default: 0, List: [], Label: \"Plate\", Change: function(index) {\r\n\t\t\t\tthis.Result.LoggedPlate = index; //Log the selected plate for this result file\r\n\t\t\t\tthis.pairStatus(index);\r\n\t\t\t\tthis.do();\r\n\t\t\t}.bind(this), Title: \"The result plate for which values will be displayed\"}),\r\n\t\t}\r\n\t\tthis.Menu.init();\r\n\t\tthis.Output.init();\r\n\t\tthis.Results.init();\r\n\t\tObject.values(this.Options).forEach(function(o) {o.init()});\r\n\t\tGetId(this.Anchors.Export).append(LinkCtrl.buttonBar([ //Export functionalities\r\n\t\t\t{Label: \"Export All\", Title: \"Export all the data generated by the report, as a zip file containing tab-delimited text files\", Click: this.exportAll.bind(this)},\r\n\t\t]));\r\n\t\treturn this;\r\n\t}\r\n\t//Static methods\r\n\tstatic new(o) {\r\n\t\tswitch(o.Method) {\r\n\t\t\tcase \"zFactor\": return new Report_Controls(o);\r\n\t\t\tcase \"Aggregate\": return new Report_Aggregate(o);\r\n\t\t\tcase \"Grouped\": return new Report_Grouped(o);\r\n\t\t\tcase \"Hits\": return new Report_Hits(o);\r\n\t\t\tdefault: return new Report(o);\r\n\t\t}\r\n\t}\r\n\tstatic getBloc(report, name) { //Return the desired bloc object (identified by its name) for the report passed\r\n\t\tlet found = false;\r\n\t\tlet i = 0;\r\n\t\tlet blocs = report.Blocs;\r\n\t\tlet l = blocs.length;\r\n\t\twhile(!found && i<l) {\r\n\t\t\tif(blocs[i].Name == name) {found = true}\r\n\t\t\telse {i++}\r\n\t\t}\r\n\t\tif(found) { //Bloc already exists, call it back\r\n\t\t\treport.Output.Tabs[i].set(\"Enabled\"); //Blocs that are called can be set back as enabled\r\n\t\t\treturn report.Blocs[i];\r\n\t\t}\r\n\t\telse { //Create the bloc\r\n\t\t\treport.Result.OpenedTab = i; //Set the default state on bloc opening\r\n\t\t\treturn report.newBloc(name, i);\r\n\t\t} \r\n\t}\r\n\tstatic *plateIterator(source) { //A generator function that create a generator object for counting plates\r\n\t\tlet l = source.length;\r\n\t\tfor(let i=0; i<l; i++) {\r\n\t\t\tyield source[i];\r\n\t\t}\r\n\t}\r\n\tstatic lock(report, plates) { //Lock the report while parsing data\r\n\t\tlet id = \"Report_Mask\";\r\n\t\tForm.open({\r\n\t\t\tID: id,\r\n\t\t\tHTML: \"<p><span class=\\\"warning\\\">Parsing in progress, please wait...<span></p><p>Processing plate <span id=\\\"Mask_PlateNumber\\\">1</span> / \" + plates + \"</p>\",\r\n\t\t\tTitle: \"Analysis in progress...\",\r\n\t\t\tButtons: [\r\n\t\t\t\t{Label: \"Abort\", Click: function() {report.cancel()}}\r\n\t\t\t],\r\n\t\t\tonCancel: function() {report.cancel()},\r\n\t\t});\r\n\t}\r\n\tstatic unlock() { //Release the report after parsing\r\n\t\tForm.close(\"Report_Mask\");\r\n\t}\r\n\tstatic plateCount(p) { //Update the count of completed plates while analyzing all of them\r\n\t\tlet target = GetId(\"Mask_PlateNumber\");\r\n\t\tif(target) {target.innerHTML = p}\r\n\t}\r\n\tstatic cleanName(report) { //Return the cleaned name of the selected result for the report object passed, as a safe(r) string to be used for a file name\r\n\t\tlet n = report.Result.Name;\r\n\t\tlet l = n.lastIndexOf(\".\");\r\n\t\tif(l > -1) {return this.cleanFileName(n.substring(0, l))} //The fileName without the extension and cleaned\r\n\t\telse {return this.cleanFileName(n)} //In case the file name is already without extension\r\n\t}\r\n\tstatic cleanFileName(n) { //Clean the provided name to make it a safe(r) string to be used for a file name\r\n\t\tif(n == \"\" || n === undefined) {return \"unknown\"} //Let's have a fallback for weird cases\r\n\t\treturn n.trim() //Starts by removing space characters at both ends\r\n\t\t\t.replace(/[^a-z0-9_\\-\\[\\]\\(\\)\\.]/gi, \"_\") //Replace all undesirable characters with \"_\"\r\n\t\t\t.replace(/_{2,}/g, \"_\"); //Collapse consecutive \"_\" into one\r\n\t}\r\n\tstatic saveState(r, resultIndex) { //Save the state of the panels opened for the result of index passed, for the report provided\r\n\t\tr.Results.Array[resultIndex].OpenedTab = r.Output.active(); //Save the active bloc\r\n\t\tr.Output.disable(); //Disable all the tabs. Tabs that are called by getBloc() later during the do() will be set as active\r\n\t}\r\n\tstatic restoreState(r, resultIndex) {\r\n\t\tlet n = r.Results.Array[resultIndex].OpenedTab;\r\n\t\tif(n !== undefined) {r.Output.jumpTo(n)} //Need a control for the first opening case\r\n\t}\r\n\tstatic blocName(param) { //Build a unique bloc name using the properties of the parameter object provided\r\n\t\treturn param.ResultIndex + \". \" + param.Name;\r\n\t}\r\n\t//Getter and setter\r\n\tget Result() { //Get the result file currently selected\r\n\t\tlet r = this.Results.Selected[0];\r\n\t\tif(r === undefined) {this.Results.setValue([0])}\r\n\t\treturn this.Results.Selected[0];\r\n\t}\r\n\tget FirstBlocIndex() { //For the result file selected, get the index of the first bloc containing its data\r\n\t\tlet start = (this.Results.SelectedIndices[0] + 1) + \". \"; //The start of the name for all the parameters of the selected result file\r\n\t\tlet found = false;\r\n\t\tlet i = 0;\r\n\t\tlet blocs = this.Blocs;\r\n\t\tlet l = blocs.length;\r\n\t\twhile(!found && i<l) {\r\n\t\t\tif(blocs[i].Name.startsWith(start)) {found = true}\r\n\t\t\telse {i++}\r\n\t\t}\r\n\t\tif(found) {return i}\r\n\t\telse {return undefined}\r\n\t}\r\n\tget Params() {\r\n\t\treturn this.Result.Parameters;\r\n\t}\r\n\t//Methods\r\n\tinit() { //Init the controls on the page\r\n\t\tObject.values(this.UI).forEach(function(v) {v.init()});\r\n\t\tthis.setPlates(); //Update plate list and pairing data\r\n\t\tthis.do(); //Do the job\r\n\t\treturn this;\r\n\t}\r\n\tdo() {} //Do the job. Each child report has its own implementation of what to do\r\n\tsetPlates() { //Update the plate list to match that of the selected result; this will also trigger a pairStatus to update the pairing info\r\n\t\tlet ui = this.UI.Plate;\r\n\t\tlet plates = this.Result.PlatesID;\r\n\t\tui.List = plates;\r\n\t\tif(plates.length > 1) { //Update the navigation tools\r\n\t\t\tui.NavBar = true;\r\n\t\t\tui.Lookup = {Active: false}\r\n\t\t}\r\n\t\telse {\r\n\t\t\tui.NavBar = false;\r\n\t\t\tui.Lookup = undefined;\r\n\t\t}\r\n\t\tlet v = this.Result.LoggedPlate; //Logged plate for this result file\r\n\t\tui.setValue(v) //Set the selection to the right plate\r\n\t\tui.init(); //Initialize to re-build the display\r\n\t\tthis.pairStatus(v); //Update pairing data for the selected plate\r\n\t\treturn this;\r\n\t}\r\n\tpairStatus(index, I) { //Update the pairing information for the result plate selected\r\n\t\tlet target = GetId(this.Anchors.PairingTarget);\r\n\t\tlet P = this.Result.Pairing;\r\n\t\tif(P === undefined) {target.innerHTML = Pair.unpaired().Html; return} //This plate has no pairing information, escape here\r\n\t\tlet pair = this.Result.Pairing.Pairs[index];\r\n\t\tif(pair === undefined) {target.innerHTML = Pair.unpaired().Html; return} //This plate has no pairing information, escape here\r\n\t\tif(this.Ranges) {\r\n\t\t\tlet pairInfo = pair.getDefPlate(this.Ranges);\r\n\t\t\tpairInfo.forEach(function(p, i) { //Loop the pairInfo\r\n\t\t\t\tlet ui = this.UI[\"Definition_\" + p.RangeIndex];\r\n\t\t\t\tif(I && I.Check) { //Comparison only\r\n\t\t\t\t\tif(p.DefPlateIndex == ui.getValue()) { //OK\r\n\t\t\t\t\t\tpair.Table[i].Broken = false;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse { //Set as broken\r\n\t\t\t\t\t\tpair.Table[i].Broken = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse { //Setter for the definition\r\n\t\t\t\t\tui.setValue(p.DefPlateIndex).change(); //Trigger a change to update the displayed names\r\n\t\t\t\t\tpair.Table[i].Broken = false;\r\n\t\t\t\t}\t\r\n\t\t\t}, this);\r\n\t\t}\r\n\t\tlet O = pair.state();\r\n\t\ttarget.innerHTML = O.Html; //Output\r\n\t\treturn this;\r\n\t}\r\n\tnewBloc(name, index) {\r\n\t\tlet id = \"Bloc_\" + index;\r\n\t\tlet bloc = new Bloc({Name: name, ID: id, File: this.Result.Name});\r\n\t\tthis.Blocs.push(bloc);\r\n\t\tthis.Output.addTab({Label: name, SetActive: true, Content: {Type: \"HTML\", Value: \"<p>Data for Result file: \" + this.Result.Name + \"</p><div id=\\\"\" + id + \"\\\"><span class=\\\"warning\\\">Initializing the report, please wait...</span></div>\"} });\r\n\t\treturn bloc.init();\r\n\t}\r\n\tcancel() {\r\n\t\tthis.Cancel = true;\r\n\t\treturn this;\r\n\t}\r\n\trefresh(what, I) { //Refresh the report\r\n\t\tswitch(what) {\r\n\t\t\tcase \"Rows\": this.refreshRows(I); break;\r\n\t\t\tcase \"Decimals\": this.refreshDecimals(I); break;\r\n\t\t\tcase \"CV\": this.refreshCV(I.Show); break;\r\n\t\t\tcase \"Log\": this.refreshLog(I); break;\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\treturn this;\r\n\t}\r\n\trefreshRows(I) { //Update the number of rows displayed per table\r\n\t\tlet height = \"unset\";\r\n\t\tif(I.Collapse) {height = Analyzer.divHeight(I.Rows)}\r\n\t\tlet HTMLcollection = GetId(\"Output\").getElementsByClassName(\"InnerTable_Wrapper\");\r\n\t\tlet l = HTMLcollection.length;\r\n\t\tfor(let i=0; i<l; i++) {\r\n\t\t\tlet elt = HTMLcollection[i];\r\n\t\t\tlet items = elt.children[0].rows.length;\r\n\t\t\telt.style.maxHeight = height;\r\n\t\t\tif(items <= I.Rows) {elt.style.overflowY = \"unset\"}\r\n\t\t\telse {elt.style.overflowY = \"scroll\"}\r\n\t\t}\r\n\t\treturn this;\r\n\t}\r\n\trefreshDecimals(I) { //Update the number of decimals displayed\r\n\t\tlet HTMLcollection = [];\r\n\t\tif(I && I.LogOnly) {HTMLcollection = GetId(\"Output\").getElementsByClassName(\"Value_PlaceHolder Header_Conc\")} //Limit to the relevant items for log scale\r\n\t\telse {HTMLcollection = GetId(\"Output\").getElementsByClassName(\"Value_PlaceHolder\")}\r\n\t\tlet l = HTMLcollection.length;\r\n\t\tfor(let i=0; i<l; i++) { //Update all the value placeholders\r\n\t\t\tlet elt = HTMLcollection[i];\r\n\t\t\tif(elt.hasAttribute(\"value\")) { //Locate elements with a value attribute\r\n\t\t\t\tlet val = Number(elt.getAttribute(\"value\"));\r\n\t\t\t\tif(I && I.Log) {\r\n\t\t\t\t\tval = Math.log10(val);\r\n\t\t\t\t\tif(I.Shift) {val += Number(elt.getAttribute(\"shift\"))} //Shift to the higher unit\r\n\t\t\t\t\telt.setAttribute(\"logvalue\", val);\r\n\t\t\t\t}\r\n\t\t\t\tif(val != \"\" && (isNaN(val) == false)) { //If convertion to a number falls into NaN, it means the value is a text, so leave it as it is\r\n\t\t\t\t\telt.innerHTML = Analyzer.roundNb(val);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tif(I && I.LogOnly) {return} //No need to adjust this for log scale\r\n\t\tlet tables = GetId(\"Output\").getElementsByClassName(\"InnerTableRow\");\r\n\t\tlet m = tables.length;\r\n\t\tfor(let i=0; i<m; i++) { //For each table\r\n\t\t\tlet t = tables[i];\r\n\t\t\tlet n = t.rows[0].cells.length; //Get the number of cells (these tables have only one row)\r\n\t\t\tlet maxLength = 2; //Minimum length\r\n\t\t\tfor(let j=0; j<n; j++) { //Travel each cell for this row\r\n\t\t\t\tmaxLength = Math.max(maxLength, t.rows[0].cells[j].innerText.length); //Using innerText solve the issue of the <span> for empty cells\r\n\t\t\t}\r\n\t\t\tt.style.minWidth = Analyzer.rowWidth(n, maxLength); //Update tables min-width\r\n\t\t}\r\n\t\treturn this;\r\n\t}\r\n\trefreshCV(bool) { //Show or hide the computed CV values\r\n\t\tlet HTMLcollection = GetId(\"Output\").getElementsByClassName(\"CV_Row\");\r\n\t\tlet l = HTMLcollection.length;\r\n\t\tlet display = \"none\";\r\n\t\tif(bool) {display = \"table-row\"}\r\n\t\tfor(let i=0; i<l; i++) {\r\n\t\t\tHTMLcollection[i].style.display = display;\r\n\t\t}\r\n\t\treturn this;\r\n\t}\r\n\trefreshLog(I) { //Refresh log scale options\r\n\t\tlet show = this.Options.LogScale.getValue();\r\n\t\tlet shift = this.Options.Shift.getValue();\r\n\t\tlet HTMLcollection = GetId(\"Output\").querySelectorAll(\"span.Header_Conc\"); //update the text for the headers\r\n\t\tlet l = HTMLcollection.length;\r\n\t\tfor(let i=0; i<l; i++) { //Loop the headers\r\n\t\t\tlet elt = HTMLcollection[i];\r\n\t\t\tif(show) {elt.innerHTML = Analyzer.headerConcLog(elt.getAttribute(\"name\"), shift)} //LogScale on\r\n\t\t\telse {elt.innerHTML = elt.getAttribute(\"name\")} //Off\r\n\t\t}\r\n\t\tthis.refreshDecimals({LogOnly: true, Log: show, Shift: shift}); //Refresh the value display\r\n\t\t/*let HTMLcollection = GetId(\"Output\").getElementsByClassName(\"Value_PlaceHolder Header_Conc\");\r\n\t\tlet l = HTMLcollection.length;\r\n\t\tfor(let i=0; i<l; i++) {\r\n\t\t\tlet elt = HTMLcollection[i];\r\n\t\t\tlet val = Math.log10(Number(elt.getAttribute(\"value\")));\r\n\t\t\tif(shift) { //Shift on\r\n\t\t\t\tval += Unit.shiftForUnit()\r\n\t\t\t}\r\n\t\t\telt.setAttribute(\"logvalue\", val);\r\n\t\t\tif(show) {elt.innerHTML = Analyzer.roundNb(val)} //This option only affects display when log scale is turned on\r\n\t\t}*/\r\n\t}\r\n\texportAll() { //Export all data for available blocs and sections\r\n\t\tlet Z = new JSZip();\r\n\t\tlet id = \"Form_Save\";\r\n\t\tlet outputID = id + \"_Output\";\r\n\t\tlet fileName = \"ExportAll.zip\";\r\n\t\tForm.open({ //Open a form for feedback to the user\r\n\t\t\tID: id,\r\n\t\t\tHTML: \"<p id=\\\"\" + outputID + \"\\\"><span class=\\\"warning\\\">Preparing zip archive, please wait...</span></p>\",\r\n\t\t\tTitle: \"Export data\",\r\n\t\t\tButtons: [{Label: \"Close\", Click: function() {Form.close(id)}}],\r\n\t\t});\r\n\t\tthis.Blocs.forEach(function(bloc) {\r\n\t\t\tlet mainDir = Z.folder(bloc.File);\r\n\t\t\t//let dir = Z.folder(Report.cleanFileName(bloc.Name));\r\n\t\t\tlet dir = mainDir.folder(Report.cleanFileName(bloc.Name));\r\n\t\t\tbloc.Sections.forEach(function(section) {\r\n\t\t\t\tlet blob = section.export({BlobOnly: true});\r\n\t\t\t\tdir.file(Report.cleanFileName(section.Name + \".txt\"), blob);\r\n\t\t\t});\r\n\t\t});\r\n\t\tZ.generateAsync({type: \"blob\"}).then(function (b) {\r\n\t\t\tlet target = GetId(outputID); //Access the element only at the end\r\n\t\t\tif(target) {\r\n\t\t\t\tlet url = URL.createObjectURL(b);\r\n\t\t\t\t//target.innerHTML = \"<p>Click <a href=\\\"\" + url + \"\\\" download=\\\"\" + fileName + \"\\\">here</a> to download the generated zip file</p>\";\r\n\t\t\t\ttarget.innerHTML = \"<p>Click on the link below to download and save your file:</p><p style=\\\"text-align: center;\\\"><a href=\\\"\" + url + \"\\\" download=\\\"\" + fileName + \"\\\">\" + fileName + \"</a></p>\"\r\n\t\t\t\tForm.replaceButtons(id, [{Label: \"Close\", Click: function() {URL.revokeObjectURL(url); Form.close(id)}}]); //Revoke the URL has it is no longer useful\r\n\t\t\t}\r\n\t\t});\r\n\t\treturn this;\r\n\t}\r\n}","//*********************************************************************************\r\n// SECTION object - Second layer used to organize reporting of data in the analyzer\r\n//*********************************************************************************\r\nclass Section {\r\n\tconstructor(I) {\r\n\t\tthis.ID = I.ID;\r\n\t\tthis.Bloc = I.Bloc; //Parent bloc object\r\n\t\tthis.Name = I.Name; //Internal name\r\n\t\tthis.TableType = (I.TableType || \"Simple\"); //Defines the table type to let the analyzer know how to export it. Values can be [Simple, Inner]\r\n\t\tthis.Summary = I.Summary; //Whether this section contains a summary table\r\n\t\tif(this.Summary) { //In this case, keeping the values computed facilitates the creation and maintenance of the summary table\r\n\t\t\tthis.Tables = [];\r\n\t\t\tthis.Headers = I.Headers;\r\n\t\t\tI.Tables.forEach(function(t, i) { //Array of object with Label property\r\n\t\t\t\tlet table = {ID: this.ID + \"_Table_\" + i, Columns: []}\r\n\t\t\t\tif(t.Visible !== undefined) {table.Visible = t.Visible}\r\n\t\t\t\telse {table.Visible = true}\r\n\t\t\t\tif(t.Title !== undefined) {table.Title = t.Title}\r\n\t\t\t\telse {table.Title = \"Table \" + i}\r\n\t\t\t\tthis.Headers.forEach(function(h) { //For each header, there will be a storage using an object keyed with the header name\r\n\t\t\t\t\ttable.Columns.push({Label: h, Visible: true, Values: []}); //Initialize empty arrays to receive the values\r\n\t\t\t\t});\r\n\t\t\t\tthis.Tables.push(table);\r\n\t\t\t},this);\r\n\t\t}\r\n\t\treturn this;\r\n\t}\r\n\t//Static methods\r\n\tstatic getTables(s) { //For the section object passed, return the tables to be exported as an HTML collection of DOM elements\r\n\t\tif(s.Summary) { //For summary, do not include the hidden tables\r\n\t\t\tlet array = [];\r\n\t\t\ts.Tables.forEach(function(t) {\r\n\t\t\t\tlet wrapper = GetId(t.ID);\r\n\t\t\t\tif(wrapper.style.display != \"none\") { //Export the table if visible\r\n\t\t\t\t\tarray.push(wrapper.lastChild);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t\treturn array;\r\n\t\t}\r\n\t\tswitch(s.TableType) {\r\n\t\t\tcase \"Simple\": return GetId(s.ID).getElementsByClassName(\"Table\");\r\n\t\t\tdefault: return GetId(s.ID).getElementsByClassName(\"OuterTable\");\r\n\t\t}\r\n\t}\r\n\tstatic fullName(s) { //Provide a name representing the full data embedded in the section\r\n\t\tlet names = [s.Bloc.File, s.Bloc.Name, s.Name].map(function(n) {return Report.cleanFileName(n)}); //Clean each name individually\r\n\t\tlet name = \"(\" + names[0] + \")_\" + names[1] + \"_[\" + names[2] + \"]\"; //Merge the names together into a single string: (fileName)_BlocName_[SectionName]\r\n\t\treturn name.replace(/_{2,}/g, '_'); //Eliminate consecutive _\r\n\t}\r\n\tstatic fileHeader(s) { //Prepare a header for the file to be exported, that summarizes exactly where these data belongs to\r\n\t\tlet names = [s.Bloc.Name, s.Name].map(function(n) {return Report.cleanFileName(n)}); //Clean each name individually\r\n\t\treturn \"Data for Result file: [\" + s.Bloc.File + \"]; Parameter:  [\" + names[0] + \"]; Table: [\" + names[1] + \"]\\n\"; //Merge the names together into a single string\r\n\t}\r\n\t//Methods\r\n\tHTML(title) { //Prepare the inner html for a section\r\n\t\tlet html = \"\";\r\n\t\thtml += \"<fieldset><legend>\" + title + \"</legend><div class=\\\"Section_Controls\\\"></div><div id=\\\"\" + this.ID + \"\\\" class=\\\"Section\\\">\";\r\n\t\tif(this.Summary) {\r\n\t\t\thtml += \"<div>\"; //Wrapping div\r\n\t\t\tthis.Tables.forEach(function(t) {\r\n\t\t\t\thtml += \"<div id=\\\"\" + t.ID + \"\\\" style=\\\"float: left;border: 1px solid darkred;border-radius: 5px;padding: 5px; margin: 5px\\\"></div>\";\r\n\t\t\t});\r\n\t\t\thtml += \"</div>\";\r\n\t\t}\r\n\t\thtml += \"</div></fieldset>\";\r\n\t\treturn html\r\n\t}\r\n\treplaceContent(content) {\r\n\t\tlet me = GetId(this.ID);\r\n\t\tme.innerHTML = content;\r\n\t\treturn this;\r\n\t}\r\n\tactivateControls() { //Activate control elements within this section\r\n\t\tlet me = GetId(this.ID);\r\n\t\tme.previousSibling.append(LinkCtrl.buttonBar([\r\n\t\t\t{Label: \"Export\", Title: \"Click to export the data for this section\", Click: function() {this.export({FileName: Section.fullName(this)})}.bind(this)},\r\n\t\t\t{Label: \"Printable version\", Title: \"Click to view the data in a new window, allowing for printing or easy copy-pasting in other applications\", Click: function() {this.printable()}.bind(this)},\r\n\t\t]));\r\n\t}\r\n\tupdateTable(tableIndex, ColumnName, entry, newRow, I) { //Update the table of index given, updating the row containing entry in ColumnName with newRow\r\n\t\tlet t = this.Tables[tableIndex];\r\n\t\tlet c = this.Headers.indexOf(ColumnName); //Find the column index where to search the entry\r\n\t\tif(c == -1) {console.warn(\"Could not find '\" + ColumnName + \"' column in table headers\", this); return this}\r\n\t\tlet n = t.Columns[c].Values.indexOf(entry); //Search the entry\r\n\t\tif(n > -1) { //The value exist, update it\r\n\t\t\tt.Columns.forEach(function(col, i) {\r\n\t\t\t\tcol.Values[n] = newRow[i];\r\n\t\t\t});\r\n\t\t}\r\n\t\telse { //First time the value is seen, create a new element\r\n\t\t\tt.Columns.forEach(function(col, i) {\r\n\t\t\t\tcol.Values.push(newRow[i]);\r\n\t\t\t});\r\n\t\t}\r\n\t\tlet updatedTable = Analyzer.objectToTable(t.Columns, {Sync: true});\r\n\t\tlet target = GetId(t.ID);\r\n\t\ttarget.innerHTML = \"<p class=\\\"Title\\\">\" + t.Title + \"</p>\" + updatedTable.HTML;\r\n\t\tif(I && I.Visible !== undefined) {\r\n\t\t\tif(I.Visible) {target.style.display = \"block\"}\r\n\t\t\telse {target.style.display = \"none\"}\r\n\t\t}\r\n\t\treturn this;\r\n\t}\r\n\thideAllTables() { //Hide all tables for this summary section\r\n\t\tif(this.Summary) {\r\n\t\t\tthis.Tables.forEach(function(t) {\r\n\t\t\t\tGetId(t.ID).style.display = \"none\";\r\n\t\t\t});\r\n\t\t}\r\n\t\treturn this;\r\n\t}\r\n\thasData(tableIndex, ColumnName, entry) { //For the summary section, check if the entry exists in the specified table\r\n\t\tlet found = false;\r\n\t\tlet t = this.Tables[tableIndex];\r\n\t\tif(t === undefined) {return false} //Table does not exist, so the entry is sure not to exist too\r\n\t\tlet c = this.Headers.indexOf(ColumnName);\r\n\t\tif(c == -1) {return false} //Header with this name not found\r\n\t\tlet val = t.Columns[c].Values;\r\n\t\tlet l = val.length;\r\n\t\tlet i = 0;\r\n\t\twhile(!found && i < l) {\r\n\t\t\tif(val[i] == entry) {found = true}\r\n\t\t\ti++;\r\n\t\t}\r\n\t\treturn found;\r\n\t}\r\n\texport(I) { //Export the table data of this section\r\n\t\tlet tables = Section.getTables(this);\r\n\t\tlet l = tables.length;\r\n\t\tlet save = Section.fileHeader(this);\r\n\t\tlet title = \"\";\r\n\t\tfor(let i=0; i<l; i++) {\r\n\t\t\tlet t = tables[i];\r\n\t\t\tif(i == 0) {title = t.previousSibling.innerText} //The first table always has a title\r\n\t\t\telse { //For the following tables, it depends\r\n\t\t\t\tsave += \"\\n\\n\"; //Separator between tables\r\n\t\t\t\tif(this.TableType == \"Inner\") {title = t.previousSibling.innerText} //In this case, each table has a header\r\n\t\t\t\telse {title = undefined} //No need of title otherwise\r\n\t\t\t}\r\n\t\t\tsave += Analyzer.tableToString(t, {Title: title, TableType: this.TableType});\r\n\t\t}\r\n\t\tlet blob = new Blob([save], {type : \"text/plain;charset=utf-8\"});\r\n\t\tif(I && I.BlobOnly) {return blob} //If only the blob is required (chaining with other files), exit here by returning the blob\r\n\t\tlet fileName = \"Results.txt\";\r\n\t\tif(I && I.FileName) {fileName = I.FileName + \".txt\"}\r\n\t\tForm.download(save, {FileName: fileName});\r\n\t\treturn this;\r\n\t}\r\n\tprintable() { //Open a new window containing only the table and allowing easy copy-pasting / printing\r\n\t\tReporter.printable(GetId(this.ID).innerHTML);\r\n\t\treturn this;\r\n\t}\r\n}","//************************************************************************************************\r\n// REPORT_AGGREGATE object - A report object to display and navigate results from aggregated areas\r\n//************************************************************************************************\r\nclass Report_Aggregate extends Report {\r\n\tconstructor(o) {\r\n\t\tsuper(o);\r\n\t\tlet source = window.opener.Aggregate;\r\n\t\tsource.Combinations.A.forEach(function(c) {c.Selected = true}); //Mark all areas as selected\r\n\t\tthis.Ranges = source.Ranges;\r\n\t\tthis.ResolvedNames = []; //Array to collect the names for the definition plates currently selected \r\n\t\tthis.Menu.addTabs([ //Prepare the menu\r\n\t\t\t{Label: \"Areas\", SetActive: true, Content: {Type: \"HTML\", Value: \"<div style=\\\"max-height: 500px; overflow: auto\\\" id=\\\"Areas\\\"></div>\"} },\r\n\t\t]);\r\n\t\tthis.UI.A = new RespTable({ID: \"Areas\", Fields: [\"Name\"], RowNumbers: true, NoControls: true, Multiple: true, Array: source.Combinations.A, onSelect: this.computeStats.bind(this)});\r\n\t\tlet b = LinkCtrl.button({Label: \"Compute all\", Title: \"Click here to compute the stat summaries for all plates\", Click: function() {this.statsAllPlates()}.bind(this)});\r\n\t\tGetId(this.Anchors.PlateDoAll).append(b);\r\n\t\tlet bar = LinkCtrl.buttonBar([\r\n\t\t\t{Label: \"Unselect all\", Title: \"Click here to unselect all areas\", Click: function() {this.UI.A.setValue([]); this.computeStats()}.bind(this)},\r\n\t\t\t{Label: \"Select all\", Title: \"Click here to select all areas\", Click: function() {this.UI.A.selectAll(); this.computeStats()}.bind(this)},\r\n\t\t]);\r\n\t\tGetId(this.Anchors.PlateSelect).insertAdjacentHTML(\"afterend\", \"<fieldset><legend>Definitions</legend><div id=\\\"Definitions_Select\\\"><i>None available</i></div></fieldset>\");\r\n\t\tGetId(\"Areas\").parentElement.prepend(bar);\r\n\t\tthis.Ranges.forEach(function(r, i) { //For each definition input, prepare a select to change the plate used for resolution of the range item\r\n\t\t\tlet d = r.Definition;\r\n\t\t\tif(d !== undefined) {\r\n\t\t\t\tlet sel = LinkCtrl.new(\"Select\", {ID: \"Definitions_Select\", NewLine: true, Index: i, Default: 0, List: d.PlatesID, Label: d.Area.Name, Title: \"The plate to use for the resolution of the names for this range\", Change: function(v) {\r\n\t\t\t\t\tthis.resolveNames(d, i).then(function(names) { //Fetch the names for the plate selected for this range\r\n\t\t\t\t\t\tthis.ResolvedNames[i] = names; //Update the name property for this definition\r\n\t\t\t\t\t\tthis.updateNames(d.Area, i); //Update the displayed names\r\n\t\t\t\t\t}.bind(this));\r\n\t\t\t\t\tif(v !== undefined) { //If the change is triggered by a pair setter, v will be undefined and there is no need to check the status. But if the select is changed manually by the user, need to check\r\n\t\t\t\t\t\tthis.pairStatus(this.UI.Plate.getValue(), {Check: true}); //Update the pair status\r\n\t\t\t\t\t}\r\n\t\t\t\t}.bind(this)});\r\n\t\t\t\tif(sel.List.length > 1) {sel.NavBar = true; sel.Lookup = {Active: false} }\r\n\t\t\t\tif(i > 0) {sel.Preserve = true}\r\n\t\t\t\tthis.UI[\"Definition_\" + i] = sel;\r\n\t\t\t}\r\n\t\t}, this);\r\n\t\treturn this;\r\n\t}\r\n\t//Methods\r\n\tdo() {\r\n\t\tif(this.NameResolved) { //Names were already resolved, proceed\r\n\t\t\tthis.computeStats();\r\n\t\t}\r\n\t\telse { //First resolve the names\r\n\t\t\tthis.resolveAllNames().then(function() { //Start by recovering all definitions names\r\n\t\t\t\tthis.NameResolved = true;\r\n\t\t\t\tthis.computeStats(); //Compute the stats\r\n\t\t\t}.bind(this));\r\n\t\t}\r\n\t\treturn this;\r\n\t}\r\n\tresolveAllNames() { //Resolve the names for all the definitions available\r\n\t\tlet promises = [];\r\n\t\treturn new Promise(function(resolve) { //Return a promise that will resolve when the parsing is completed\r\n\t\t\tthis.Ranges.forEach(function(r, i) { //For each definition, start the fetching process\r\n\t\t\t\tlet d = r.Definition;\r\n\t\t\t\tif(d !== undefined) {\r\n\t\t\t\t\tpromises.push(this.resolveNames(d, i));\r\n\t\t\t\t}\r\n\t\t\t\telse {promises.push(undefined)} //Push something to maintain index synchronization with Ranges and Definitions arrays\r\n\t\t\t}, this);\r\n\t\t\tPromise.all(promises).then(function(names) { //When all the fetching is done, update the object property with the resolved names\r\n\t\t\t\tthis.ResolvedNames = names;\r\n\t\t\t\tresolve();\r\n\t\t\t}.bind(this));\r\n\t\t}.bind(this));\r\n\t}\r\n\tresolveNames(d, defIndex) { //Resolve the names for the definition passed\r\n\t\tlet a = d.Area;\r\n\t\t//\r\n\t\t//\r\n\t\t//\r\n\t\t//let factor = Math.ceil(a.Tagged / a.Replicates);\r\n\t\tlet factor = a.MaxRange;\r\n\t\t//\r\n\t\t//\r\n\t\t//\r\n\t\tlet args = {\r\n\t\t\tPlate: this.UI[\"Definition_\" + defIndex].Selected, //Name of the plate where to look the data\r\n\t\t\tFactor: factor, //This factor is necessary to find the data in case no well/plate mapping are available\r\n\t\t\tDefault: \"\", //Default fallback if the element needed is outside the list\r\n\t\t\tAreaName: a.Name, //To complete generic items\r\n\t\t\tColumn: d.Mapping[Mapper.definition().Name], //Index of the column containing the data to extract\r\n\t\t\tRangeIndexBase0: a.MaxRange, //Providing the maxRange ensures that the array is filled with generic items if there is not enough definitions available in the file\r\n\t\t\tFindAll: true,\r\n\t\t}\r\n\t\treturn new Promise(function(resolve) {\r\n\t\t\td.Mapper.find(d, args).then(function(array) {\r\n\t\t\t\tlet mode = Mapper.modeWellPlate(d.Mapping);\r\n\t\t\t\tswitch(mode) { //For mapping without well location, the array returned is the list of object available, can be returned as is. Otherwise, should convert the plate array to a flat array of item\r\n\t\t\t\t\tcase \"Plate\": //FALL-THROUGH\r\n\t\t\t\t\tcase \"Direct\": resolve(array); break;\r\n\t\t\t\t\tcase \"Well\": //FALL-THROUGH\r\n\t\t\t\t\tcase \"PlateWell\": \r\n\t\t\t\t\t\tlet items = [];\r\n\t\t\t\t\t\tthis.Ranges[defIndex].Values.forEach(function(v) { //Look at the individual items for this range\r\n\t\t\t\t\t\t\titems.push(array[v.Tags[0]]); //Get the index of the first well tagged for this rangeItem, and log its definition. We enforce here that other wells for this RangeItem share the same definition, even if this is wrong\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t\tresolve(items);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}.bind(this));\r\n\t\t}.bind(this));\r\n\t}\r\n\tupdateNames(range, index) { //Update the names for the rangeIndex provided, or all the ranges if nothing is passed\r\n\t\tlet source = this.Ranges;\r\n\t\tif(range !== undefined) { //A specific range is provided\r\n\t\t\tsource = Array(this.Ranges.length);\r\n\t\t\tsource[index] = range; //Create an empty array except for this index. This is to ensure we can use this index to find the matching definitions\r\n\t\t}\r\n\t\tlet collection = GetId(\"Output\").getElementsByTagName(\"TH\");\r\n\t\tlet l = collection.length;\r\n\t\tfor(let i=0; i<l; i++) { //Travel the collection and search for matching names\r\n\t\t\tlet th = collection[i];\r\n\t\t\tlet string = th.innerHTML;\r\n\t\t\tif(th.hasAttribute(\"RootName\")) {string = th.getAttribute(\"RootName\")} //In this case, recover the saved generic name\r\n\t\t\telse {th.setAttribute(\"RootName\", string)} //Save the generic name before making modifications\r\n\t\t\tsource.forEach(function(r, j) { //For each range\r\n\t\t\t\tif(r !== undefined && this.ResolvedNames[j] !== undefined) { //When a single range is provided, only one element of the array is defined. And when the range has no definitions, the resolved names are absent\r\n\t\t\t\t\tlet name = r.Name + \" #\";\r\n\t\t\t\t\tlet n = name.length;\r\n\t\t\t\t\tlet pos = string.indexOf(name);\r\n\t\t\t\t\tif(pos > -1) { //The title includes this name\r\n\t\t\t\t\t\tpos += n; //Update position to start at the #\r\n\t\t\t\t\t\tlet end = string.indexOf(\" \", pos); //Find the position of the next space\r\n\t\t\t\t\t\tlet RangeIndex = Number(string.substring(pos, end)); //Extract the range index value\r\n\t\t\t\t\t\tif(end == -1) {RangeIndex = Number(string.substring(pos))} //In cases where the name is not succeded by a unit or another area, the rangeIndex is up to the end of the string\r\n\t\t\t\t\t\tth.innerHTML = string.replace(name + RangeIndex, this.ResolvedNames[j][RangeIndex - 1]); //Replace the generic name with the definition\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}, this);\r\n\t\t}\r\n\t}\r\n\tgetValues(selectedPlate) { //Retrieve the values for all areas and parameters, for the selected plate\r\n\t\tthis.UI.A.Array.forEach(function(a) { //For each area\r\n\t\t\ta.Values = []; //Reset value arrays to accept new values\r\n\t\t});\r\n\t\tlet resultIndex = this.Results.SelectedIndices[0] + 1; //The index of the result file selected (1-based), unique\r\n\t\tlet o = {Items: 0, Areas: this.UI.A.Array, Params: []} //Output object containing the data for one plate\r\n\t\tthis.Params.forEach(function(p, i) { //Initialize empty array to receive the values for each selected parameters that is set as numeric\r\n\t\t\t//if(p.Selected && p.Numeric) { //This parameter is selected and numeric type, continue\r\n\t\t\tif(p.Selected) { //This parameter is selected and numeric type, continue\r\n\t\t\t\to.Params.push({Index: i, Name: p.Name, ResultIndex: resultIndex});\r\n\t\t\t\to.Areas.forEach(function(a) { //For each area\r\n\t\t\t\t\ta.Values.push([]); //Create empty arrays to receive the values\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t}, this);\r\n\t\tthis.waitMessage(o.Params); //This displays waiting message\r\n\t\tlet custom = function(well, plate, row, output, parser) { //The function to run on each line\r\n\t\t\tif(plate == selectedPlate) { //We are on the right plate\r\n\t\t\t\tlet wellIndex = well.Index;\r\n\t\t\t\toutput.Areas.forEach(function(a) { //For each area\r\n\t\t\t\t\tif(a.Tags.includes(wellIndex)) { //This area is tagged on this well\r\n\t\t\t\t\t\toutput.Params.forEach(function(param, i) { //Log the values for all parameters\r\n\t\t\t\t\t\t\ta.Values[i].push(Number(row[param.Index]));\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn new Promise(function(resolve) {\r\n\t\t\tthis.Result.Mapper.scan(this.Result, {Custom: custom}, o).then(function(data) {\r\n\t\t\t\tresolve(data);\r\n\t\t\t});\r\n\t\t}.bind(this));\r\n\t}\r\n\twaitMessage(params) { //Display a waiting message\r\n\t\tlet msg = \"<span class=\\\"warning\\\">Parsing values, please wait...</span>\";\r\n\t\tparams.forEach(function(param, i) { //Process all parameters\r\n\t\t\tlet bloc = Report.getBloc(this, Report.blocName(param));\r\n\t\t\tbloc.Sections.forEach(function(s) {\r\n\t\t\t\tif(s.Summary === undefined) {s.replaceContent(msg)}\r\n\t\t\t});\r\n\t\t}, this);\r\n\t}\r\n\tcomputeStats() {\r\n\t\tlet plate = this.UI.Plate.Selected;\r\n\t\tthis.getValues(plate).then(function(data) { //Collect values for this plate\r\n\t\t\tlet stats = this.processValues(data, plate); //Display the individual values and compute the stats\r\n\t\t\tif(this.Result.PlatesID.length > 1) { //If there are more than one plate attached to this result, then also create/update the Plate summary table\r\n\t\t\t\tthis.plateSummary(data, plate, stats);\r\n\t\t\t}\r\n\t\t\tthis.updateNames();\r\n\t\t}.bind(this));\r\n\t\treturn this;\r\n\t}\r\n\tprocessValues(data, plate) { //Process incoming data, as an array of object containing the values for each parameter and areas\r\n\t\tlet stats = [];\r\n\t\tdata.Params.forEach(function(param, i) { //Process all parameters\r\n\t\t\tlet section = Report.getBloc(this, Report.blocName(param)).getSection(\"Values\", {TableType: \"Inner\"});\r\n\t\t\tlet table = this.valueTable(data, i);\r\n\t\t\tsection.replaceContent(\"<p class=\\\"Title\\\">Data for plate: \" + plate + \"</p>\" + table.HTML);\r\n\t\t\tstats.push(table.Stats);\r\n\t\t}, this);\r\n\t\treturn stats;\r\n\t}\r\n\tvalueTable(data, valueIndex) { //Create the table holding values for all area, using values for the parameter at the index given\r\n\t\tlet o = []; //The array that will be used by the analyzer to create the table\r\n\t\tdata.Areas.forEach(function(a) { //Process all the areas\r\n\t\t\to.push({Label: a.Name, Values: a.Values[valueIndex], Visible: a.Selected});\r\n\t\t});\r\n\t\treturn Analyzer.objectToTable(o);\r\n\t}\r\n\tplateSummary(data, plate, stats) { //Update the plate summary by adding a row for the plate in each relevant table\r\n\t\tlet tables = this.plateSummaryTables(data);\r\n\t\tdata.Params.forEach(function(param, i) { //Process all parameters\r\n\t\t\tlet section = Report.getBloc(this, Report.blocName(param)).getSection(\"Plate Summary\", {Summary: true, Tables: tables, Headers: [\"Plate\", \"Average\", \"SD\", \"CV (%)\", \"N\"], TableType: \"Inner\"});\r\n\t\t\tif(stats[i]) {\r\n\t\t\t\ttables.forEach(function(t, j) { //Loop through the areas\r\n\t\t\t\t\tlet s = stats[i][j];\r\n\t\t\t\t\tsection.updateTable(j, \"Plate\", plate, [plate, s.Avg, s.SD, s.CV, s.N], {Visible: t.Visible});\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t\telse {section.hideAllTables()}\r\n\t\t}, this);\r\n\t}\r\n\tplateSummaryTables(data) {\r\n\t\tlet tables = [];\r\n\t\tdata.Areas.forEach(function(a) {\r\n\t\t\ttables.push({Title: a.Name, Visible: a.Selected});\r\n\t\t});\r\n\t\treturn tables;\r\n\t}\r\n\tasync statsAllPlates() { //Compute data for all plates, one after the other\r\n\t\tthis.Cancel = false;\r\n\t\tlet plates = this.Result.PlatesID;\r\n\t\tlet tables = this.plateSummaryTables({Areas: this.UI.A.Array});\r\n\t\tReport.lock(this, plates.length); //Lock the report and start\r\n\t\tlet plateCounter = Report.plateIterator(plates); //A generator to loop over the plates\r\n\t\tlet current = plateCounter.next();\r\n\t\tlet running = 0;\r\n\t\twhile(current.done == false && this.Cancel == false) { //Do this until the plate counter is exhausted or the user cancel the action\r\n\t\t\tlet currentPlate = current.value; //Current plate to analyze\r\n\t\t\tlet section = Report.getBloc(this, this.Blocs[this.FirstBlocIndex].Name).getSection(\"Plate Summary\", {Summary: true, Tables: tables, Headers: [\"Plate\", \"Average\", \"SD\", \"CV (%)\", \"N\"], TableType: \"Inner\"}); //Get the first section available. All sections share the data so we don't have to test for each of them\r\n\t\t\tif(section.hasData(0, \"Plate\", currentPlate) == false) { //If the values for this plate are not already logged, process it\r\n\t\t\t\tlet data = await this.getValues(currentPlate)\r\n\t\t\t\tlet stats = this.processValues(data, currentPlate); //Display the individual values and compute the stats\r\n\t\t\t\tthis.plateSummary(data, currentPlate, stats);\r\n\t\t\t\tthis.UI.Plate.setValue(running); //Ensures that the control is set at the same value as the last computed plate\r\n\t\t\t}\r\n\t\t\tcurrent = plateCounter.next();\r\n\t\t\trunning++;\r\n\t\t\tReport.plateCount(running + 1);\r\n\t\t}\r\n\t\tReport.unlock();\r\n\t}\r\n}","//*******************************************************************************\r\n// REPORT_CONTROLS object - A report object to display and navigate controls data\r\n//*******************************************************************************\r\nclass Report_Controls extends Report {\r\n\tconstructor(o) {\r\n\t\tsuper(o);\r\n\t\tlet source = window.opener.zFactor;\r\n\t\t[source.Controls.N, source.Controls.P].forEach(function(control) { //Mark all controls as selected\r\n\t\t\tcontrol.forEach(function(c) {c.Selected = true});\r\n\t\t});\r\n\t\tlet controlHTML = \"\";\r\n\t\tcontrolHTML += \"<fieldset style=\\\"margin-bottom: 10px\\\"><legend>Positive</legend><div id=\\\"Ctrl_Pos\\\"></div></fieldset>\";\r\n\t\tcontrolHTML += \"<fieldset style=\\\"margin-bottom: 10px\\\"><legend>Negative</legend><div id=\\\"Ctrl_Neg\\\"></div></fieldset>\";\r\n\t\tthis.Menu.addTabs([\r\n\t\t\t{Label: \"Controls\", SetActive: true, Content: {Type: \"HTML\", Value: controlHTML} },\r\n\t\t]);\r\n\t\tthis.UI.P = new RespTable({ID: \"Ctrl_Pos\", Fields: [\"Name\"], RowNumbers: true, Multiple: true, NoControls: true, Array: source.Controls.P, onSelect: this.computeZFactor.bind(this)});\r\n\t\tthis.UI.N = new RespTable({ID: \"Ctrl_Neg\", Fields: [\"Name\"], RowNumbers: true, Multiple: true, NoControls: true, Array: source.Controls.N, onSelect: this.computeZFactor.bind(this)})\r\n\t\tlet b = LinkCtrl.button({Label: \"Compute all\", Title: \"Click here to compute the Z-factor/Window summaries for all plates\", Click: function() {this.zScoreAllPlates()}.bind(this)});\r\n\t\tGetId(this.Anchors.PlateDoAll).append(b);\r\n\t\tlet b_pos = LinkCtrl.buttonBar([\r\n\t\t\t{Label: \"Unselect all\", Title: \"Click here to unselect all positive controls\", Click: function() {this.UI.P.setValue([]); this.computeZFactor()}.bind(this)},\r\n\t\t\t{Label: \"Select all\", Title: \"Click here to select all positive controls\", Click: function() {this.UI.P.selectAll(); this.computeZFactor()}.bind(this)},\r\n\t\t]);\r\n\t\tGetId(\"Ctrl_Pos\").parentElement.prepend(b_pos);\r\n\t\tlet b_neg = LinkCtrl.buttonBar([\r\n\t\t\t{Label: \"Unselect all\", Title: \"Click here to unselect all negative controls\", Click: function() {this.UI.N.setValue([]); this.computeZFactor()}.bind(this)},\r\n\t\t\t{Label: \"Select all\", Title: \"Click here to select all negative controls\", Click: function() {this.UI.N.selectAll(); this.computeZFactor()}.bind(this)},\r\n\t\t]);\r\n\t\tGetId(\"Ctrl_Neg\").parentElement.prepend(b_neg);\r\n\t\treturn this;\r\n\t}\r\n\t//Static Methods\r\n\tstatic combinationName(n, p) { //For the combination of negative and positive control object given, return the combination name as a string\r\n\t\treturn \"[\" + p.Name + \"] vs [\" + n.Name + \"]\";\r\n\t}\r\n\t//Methods\r\n\tdo() {\r\n\t\tthis.computeZFactor();\r\n\t\treturn this;\r\n\t}\r\n\tgetControlValues(selectedPlate) { //Retrieve the values for all controls and parameters, for the selected plate\r\n\t\t[this.UI.N.Array, this.UI.P.Array].forEach(function(control) { //For each of the negative and positive control arrays\r\n\t\t\tcontrol.forEach(function(c) { //For each control\r\n\t\t\t\tc.Values = []; //Reset value arrays to accept new values\r\n\t\t\t});\r\n\t\t});\r\n\t\tlet resultIndex = this.Results.SelectedIndices[0] + 1; //The index of the result file selected (1-based), unique\r\n\t\tlet o = {Items: 0, Neg: this.UI.N.Array, Pos: this.UI.P.Array, Params: []} //Output object containing the data for one plate\r\n\t\tthis.Params.forEach(function(p, i) { //Initialize empty array to receive the values for each selected parameters that is set as numeric\r\n\t\t\tif(p.Selected && p.Numeric) { //This parameter is selected and numeric type, continue\r\n\t\t\t\t//o.Params.push({Index: i, Name: resultIndex + \". \" + p.Name}); //Ensure unicity of parameter names, even accross multiple results\r\n\t\t\t\to.Params.push({Index: i, Name: p.Name, ResultIndex: resultIndex}); //Ensure unicity of parameter names, even accross multiple results\r\n\t\t\t\t[o.Neg, o.Pos].forEach(function(control) { //For each of the negative and positive control arrays\r\n\t\t\t\t\tcontrol.forEach(function(c) { //For each control\r\n\t\t\t\t\t\tc.Values.push([]); //Create empty arrays to receive the values\r\n\t\t\t\t\t});\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t}, this);\r\n\t\tthis.waitMessage(o.Params); //This displays waiting message\r\n\t\tlet custom = function(well, plate, row, output, parser) { //The function to run on each line\r\n\t\t\tif(plate == selectedPlate) { //We are on the right plate\r\n\t\t\t\tlet wellIndex = well.Index;\r\n\t\t\t\t[output.Neg, output.Pos].forEach(function(control) { //For each of the negative and positive controls\r\n\t\t\t\t\tcontrol.forEach(function(c) { //Check for each control\r\n\t\t\t\t\t\tif(c.Tags.includes(wellIndex)) { //This control is tagged on this well\r\n\t\t\t\t\t\t\toutput.Params.forEach(function(param, i) { //Log the values for all parameters\r\n\t\t\t\t\t\t\t\tlet v = row[param.Index];\r\n\t\t\t\t\t\t\t\tif(v == \"\") {c.Values[i].push(\"\")} //Number(\"\") returns 0\r\n\t\t\t\t\t\t\t\telse {c.Values[i].push(Number(v))}\r\n\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn new Promise(function(resolve) {\r\n\t\t\tthis.Result.Mapper.scan(this.Result, {Custom: custom}, o).then(function(data) {\r\n\t\t\t\tresolve(data);\r\n\t\t\t});\r\n\t\t}.bind(this));\r\n\t}\r\n\twaitMessage(params) { //Display a waiting message\r\n\t\tlet msg = \"<span class=\\\"warning\\\">Parsing values, please wait...</span>\";\r\n\t\tparams.forEach(function(param, i) { //Process all parameters\r\n\t\t\tlet bloc = Report.getBloc(this, Report.blocName(param));\r\n\t\t\tbloc.Sections.forEach(function(s) {\r\n\t\t\t\tif(s.Summary === undefined) {s.replaceContent(msg)}\r\n\t\t\t});\r\n\t\t}, this);\r\n\t}\r\n\tcomputeZFactor() { //Compute the z-factor for selected items\r\n\t\tlet neg = this.UI.N.Selected[0];\r\n\t\tlet pos = this.UI.P.Selected[0];\r\n\t\tif(neg === undefined && pos === undefined) {return} //Need at least one control to do something\r\n\t\tlet plate = this.UI.Plate.Selected;\r\n\t\tthis.getControlValues(plate).then(function(data) { //Collect values for this plate\r\n\t\t\tlet stats = this.processValues(data, plate); //Display the individual values and compute the stats\r\n\t\t\tlet scores = this.processZscore(stats, data, plate); //Compute and display the z-factor\r\n\t\t\tif(this.Result.PlatesID.length > 1) { //If there are more than one plate attached to this result, then also create/update the Plate summary table\r\n\t\t\t\tthis.plateSummary(data, plate, scores);\r\n\t\t\t}\r\n\t\t}.bind(this));\r\n\t}\r\n\tprocessValues(data, plate) { //Process incoming data, as an array of object containing the values for each parameter and controls\r\n\t\tlet stats = [];\r\n\t\tdata.Params.forEach(function(param, i) { //Process all parameters\r\n\t\t\tlet section = Report.getBloc(this, Report.blocName(param)).getSection(\"Values\", {TableType: \"Inner\"});\r\n\t\t\tlet table = this.valueTable(data, i);\r\n\t\t\tsection.replaceContent(\"<p class=\\\"Title\\\">Data for plate: \" + plate + \"</p>\" + table.HTML);\r\n\t\t\tstats.push(table.Stats);\r\n\t\t}, this);\r\n\t\treturn stats;\r\n\t}\r\n\tvalueTable(data, valueIndex) { //Create the table holding values for all controls, using values for the parameter at the index given\r\n\t\tlet html = \"\";\r\n\t\tlet o = []; //The array that will be used by the analyzer to create the table\r\n\t\t[data.Neg, data.Pos].forEach(function(controls) { //Process all the controls\r\n\t\t\tcontrols.forEach(function(c) {\r\n\t\t\t\to.push({Label: c.Name, Values: c.Values[valueIndex], Visible: c.Selected});\r\n\t\t\t});\r\n\t\t});\r\n\t\treturn Analyzer.objectToTable(o);\r\n\t}\r\n\tprocessZscore(stats, data, plate) { //Process the stats for each controls in order to compute the z-factors\r\n\t\tlet scores = [];\r\n\t\tdata.Params.forEach(function(param, i) { //Process all parameters\r\n\t\t\tlet section = Report.getBloc(this, Report.blocName(param)).getSection(\"Z-factors\");\r\n\t\t\tlet table = this.zScoreTable(stats[i], data);\r\n\t\t\tsection.replaceContent(\"<p class=\\\"Title\\\">Data for plate: \" + plate + \"</p>\" + table.HTML);\r\n\t\t\tscores.push(table.Score);\r\n\t\t}, this);\r\n\t\treturn scores;\r\n\t}\r\n\tzScoreTable(stats, data) { //Compute the z-scores and report the results as an HTML table\r\n\t\tlet l = data.Neg.length;\r\n\t\tlet html = \"\";\r\n\t\tlet scores = []; //To log the z/w values calculated for this plate\r\n\t\tlet todo = [ //There are 2 tables to output\r\n\t\t\t{Name: \"Z'\", Method: this.zScoreFromStats.bind(this), Scores: []},\r\n\t\t\t{Name: \"Window\", Method: this.windowFromStats.bind(this), Scores: []},\r\n\t\t];\r\n\t\tlet enough = false;\r\n\t\ttodo.forEach(function(t, n) { //Prepare a table for both the z and window scoring\r\n\t\t\thtml += \"<table class=\\\"Table\\\"\";\r\n\t\t\tif(n > 0) {html += \"style=\\\"margin-top: 20px\\\"\"} //Spacing between tables\r\n\t\t\thtml += \"><tr><th>\" + t.Name + \"</th>\";\r\n\t\t\tdata.Pos.forEach(function(p) { //Start with the positive controls as horizontal headers\r\n\t\t\t\tif(p.Selected) {html += \"<th>\" + p.Name + \"</th>\"}\r\n\t\t\t});\r\n\t\t\thtml += \"</tr>\";\r\n\t\t\tdata.Neg.forEach(function(n, i) { //Add one row for each negative control\r\n\t\t\t\tif(n.Selected) {html += \"<tr><th>\" + n.Name + \"</th>\"}\r\n\t\t\t\tdata.Pos.forEach(function(p, j) { //Each row has as many columns as positive controls\r\n\t\t\t\t\tlet score = t.Method(stats[i], stats[l + j]);\r\n\t\t\t\t\tt.Scores.push(score);\r\n\t\t\t\t\tif(p.Selected && n.Selected) {\r\n\t\t\t\t\t\thtml += Analyzer.cellForValue(score.Value, {Class: score.Class, Type: \"#\"});\r\n\t\t\t\t\t\tenough = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t}, this);\r\n\t\t\t\tif(n.Selected) {html += \"</tr>\"}\r\n\t\t\t}, this);\r\n\t\t\thtml += \"</table>\";\r\n\t\t}, this);\r\n\t\tif(enough == false) {return {HTML: \"<span class=\\\"warning\\\">Select at least one negative and one positive control to calculate a Z-factor!</span>\"}}\r\n\t\treturn {HTML: html, Score: todo}\r\n\t}\r\n\tzScoreFromStats(neg, pos) { //Compute the z score from the stats calculated from the +/- controls\r\n\t\tlet z = 1 - 3 * ((pos.SD + neg.SD) / Math.abs(pos.Avg - neg.Avg));\r\n\t\treturn {Class: this.classForZ(z), Value: z};\r\n\t}\r\n\twindowFromStats(neg, pos) { //Compute the window from the stats calculated from the +/- controls\r\n\t\tlet n = neg.Avg;\r\n\t\tlet p = pos.Avg;\r\n\t\tlet w = Math.max(n, p) / Math.min(n, p); //Window\r\n\t\treturn {Class: this.classForW(w), Value: w}\r\n\t}\r\n\tclassForW(w) { //Return the appropriate class for the window value\r\n\t\tif(w > 2) {return \"good\"}\r\n\t\tif(w > 1) {return \"neutral\"}\r\n\t\treturn \"bad\";\r\n\t}\r\n\tclassForZ(z) { //Return the appropriate class for the z value\r\n\t\tif(z > 0.4) {return \"good\"}\r\n\t\tif(z > 0.2) {return \"neutral\"}\r\n\t\treturn \"bad\";\r\n\t}\r\n\tplateSummary(data, plate, scores) { //Update the plate summary by adding a row for the plate in each relevant table\r\n\t\tlet tables = this.plateSummaryTables(data);\r\n\t\tdata.Params.forEach(function(param, i) { //Process all parameters\r\n\t\t\tlet section = Report.getBloc(this, Report.blocName(param)).getSection(\"Plate Summary\", {Summary: true, Tables: tables, Headers: [\"Plate\", \"Z'\", \"Window\"], TableType: \"Inner\"});\r\n\t\t\tif(scores[i]) {\r\n\t\t\t\tlet Zscores = scores[i][0].Scores;\r\n\t\t\t\tlet Wscores = scores[i][1].Scores;\r\n\t\t\t\ttables.forEach(function(t, j) { //Loop through the control combinations\r\n\t\t\t\t\tsection.updateTable(j, \"Plate\", plate, [plate, Zscores[j], Wscores[j]], {Visible: t.Visible});\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t\telse {section.hideAllTables()}\r\n\t\t}, this);\r\n\t}\r\n\tplateSummaryTables(data) { //Retrieve the tables that should be updated by the set of data received\r\n\t\tlet tables = [];\r\n\t\tdata.Neg.forEach(function(p) {\r\n\t\t\tdata.Pos.forEach(function(n) {\r\n\t\t\t\ttables.push({Title: Report_Controls.combinationName(n, p), Visible: (n.Selected && p.Selected)});\r\n\t\t\t});\r\n\t\t});\r\n\t\treturn tables;\r\n\t}\r\n\tasync zScoreAllPlates() { //Compute zScore for all available plates. Use a counter and a yielding loop to process the plates sequentially and prevent memory overflow\r\n\t\tthis.Cancel = false;\r\n\t\tlet plates = this.Result.PlatesID;\r\n\t\tlet tables = this.plateSummaryTables({Neg: this.UI.N.Array, Pos: this.UI.P.Array});\r\n\t\tReport.lock(this, plates.length); //Lock the report and start\r\n\t\tlet plateCounter = Report.plateIterator(plates); //A generator to loop over the plates\r\n\t\tlet current = plateCounter.next();\r\n\t\tlet running = 0;\r\n\t\twhile(current.done == false && this.Cancel == false) { //Do this until the plate counter is exhausted or the user cancel the action\r\n\t\t\tlet currentPlate = current.value.toString(); //Current plate to analyze. Should always be used as a text, force it here for generic index\r\n\t\t\tlet section = Report.getBloc(this, this.Blocs[this.FirstBlocIndex].Name).getSection(\"Plate Summary\", {Summary: true, Tables: tables, Headers: [\"Plate\", \"Z'\", \"Window\"]}); //Get the first section available. All sections share the data so we don't have to test for each of them\r\n\t\t\tif(section.hasData(0, \"Plate\", currentPlate) == false) { //If the values for this plate are not already logged, process it\r\n\t\t\t\tlet data = await this.getControlValues(currentPlate); //Collect values for this plate\r\n\t\t\t\tlet stats = this.processValues(data, currentPlate); //Display the individual values and compute the stats\r\n\t\t\t\tlet scores = this.processZscore(stats, data, currentPlate); //Compute and display the z-score\r\n\t\t\t\tthis.plateSummary(data, currentPlate, scores);\r\n\t\t\t\tthis.UI.Plate.setValue(running); //Ensures that the control is set at the same value as the last computed plate\r\n\t\t\t\tthis.pairStatus(running); //Also adjust the pairing info\r\n\t\t\t}\r\n\t\t\tcurrent = plateCounter.next();\r\n\t\t\trunning++;\r\n\t\t\tReport.plateCount(running + 1);\r\n\t\t}\r\n\t\tReport.unlock();\r\n\t}\r\n}","//************************************************************************************************************************************\r\n// REPORT_GROUPED object - A report object to display and navigate results from aggregated areas and concentrations, as 2-entry tables\r\n//************************************************************************************************************************************\r\nclass Report_Grouped extends Report {\r\n\tconstructor(o) {\r\n\t\tsuper(o);\r\n\t\tlet source = window.opener.Grouped;\r\n\t\tthis.Areas = source.Areas.map(function(a) {a.Available = true; a.Values = [{Name: a.Name, Value: a.Name, Tags: a.Tags}]; return a}); //Mark all items as available\r\n\t\tthis.Ranges = source.Ranges.map(function(r) {r.Available = true; return r});\r\n\t\tthis.Concentrations = source.Conc.map(function(c) {c.Available = true; return c});\r\n\t\tthis.ResolvedNames = []; //Array to collect the names for the definition plates currently selected \r\n\t\tthis.Menu.addTabs([ //Prepare the menu\r\n\t\t\t{Label: \"Data selected\", SetActive: true,\r\n\t\t\t\tContent: {\r\n\t\t\t\t\tType: \"HTML\",\r\n\t\t\t\t\tValue: \"<div id=\\\"Report_Ready\\\"><span class=\\\"warning\\\">Resolving definitions, please wait...</span></div>\" +\r\n\t\t\t\t\t\"<fieldset id=\\\"AddRowCol\\\"><div id=\\\"Data_Options\\\"></div></fieldset>\" +\r\n\t\t\t\t\t\"<fieldset><legend>Rows</legend><div style=\\\"max-height: 500px; overflow: auto\\\" id=\\\"SelectedRows\\\"></div></fieldset>\" +\r\n\t\t\t\t\t\"<fieldset><legend>Columns</legend><div style=\\\"max-height: 500px; overflow: auto\\\" id=\\\"SelectedCols\\\"></div></fieldset>\",\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t]);\r\n\t\tGetId(this.Anchors.PlateSelect).insertAdjacentHTML(\"afterend\", \"<fieldset><legend>Definitions</legend><div id=\\\"Definitions_Select\\\"><i>None available</i></div></fieldset>\");\r\n\t\tthis.UI.Rows = new RespTable({ID: \"SelectedRows\", Fields: [\"Name\"], RowNumbers: true, Array: [], onDelete: function(e) {e.Available = true}, onUpdate: function(I) {\r\n\t\t\tif(I === undefined || I.Action != \"Select\") {this.compute()}\r\n\t\t}.bind(this)});\r\n\t\tthis.UI.Cols = new RespTable({ID: \"SelectedCols\", Fields: [\"Name\"], RowNumbers: true, Array: [], onDelete: function(e) {e.Available = true}, onUpdate: function(I) {\r\n\t\t\tif(I === undefined || I.Action != \"Select\") {this.compute()}\r\n\t\t}.bind(this)});\r\n\t\tthis.UI.DataView = LinkCtrl.new(\"Select\", {ID: \"Data_Options\", Default: 0, Label: \"Aggregation\", List: [\"Avg, SD, N\", \"Average\", \"Column\", \"Row\"], Preserve: true, Change: this.compute.bind(this),\r\n\t\t\tTitle: \"Indicates how multiple values are displayed in the grouped table: arrayed in a single column or in consecutive rows; show only the average; show the average, standard deviation and number of samples\"\r\n\t\t});\r\n\t\tlet buttons = LinkCtrl.buttonBar([\r\n\t\t\t{Label: \"Add Rows\", Title: \"Click here to add rows of data to the summary table\", Click: function() {this.addData(\"Rows\")}.bind(this)},\r\n\t\t\t{Label: \"Add Columns\", Title: \"Click here to add columns of data to the summary table\", Click: function() {this.addData(\"Cols\")}.bind(this)},\r\n\t\t]);\r\n\t\tGetId(\"AddRowCol\").prepend(buttons);\r\n\t\tthis.Ranges.forEach(function(r, i) { //For each definition input, prepare a select to change the plate used for resolution of the range item\r\n\t\t\tlet d = r.Definition;\r\n\t\t\tif(d !== undefined) {\r\n\t\t\t\tlet sel = LinkCtrl.new(\"Select\", {ID: \"Definitions_Select\", NewLine: true, Index: i, Default: 0, List: d.PlatesID, Label: d.Area.Name, Title: \"The plate to use for the resolution of the names for this range\", Change: function(v) {\r\n\t\t\t\t\tthis.resolveNames(d, i).then(function(names) { //Fetch the names for the plate selected for this range\r\n\t\t\t\t\t\tthis.ResolvedNames[i] = names; //Update the name property for this definition\r\n\t\t\t\t\t\tthis.updateNames(d.Area, i); //Update the diplayed names\r\n\t\t\t\t\t}.bind(this));\r\n\t\t\t\t\tif(v !== undefined) { //If the change is triggered by a pair setter, v will be undefined and there is no need to check the status. But if the select is changed manually by the user, need to check\r\n\t\t\t\t\t\tthis.pairStatus(this.UI.Plate.getValue(), {Check: true}); //Update the pair status\r\n\t\t\t\t\t}\r\n\t\t\t\t}.bind(this)});\r\n\t\t\t\tif(sel.List.length > 1) {sel.NavBar = true; sel.Lookup = {Active: false} }\r\n\t\t\t\tif(i > 0) {sel.Preserve = true}\r\n\t\t\t\tthis.UI[\"Definition_\" + i] = sel;\r\n\t\t\t}\r\n\t\t}, this);\r\n\t\tGetId(\"Output\").innerHTML = \"<p class=\\\"Note\\\">Add Rows and Columns of data to start</p>\"; //Welcome message\r\n\t\treturn this;\r\n\t}\r\n\t//Methods\r\n\tdo() {\r\n\t\tif(this.Ready) { //Names were already resolved, proceed\r\n\t\t\tthis.compute();\r\n\t\t}\r\n\t\telse { //First resolve the names\r\n\t\t\tthis.resolveAllNames().then(function() { //Start by recovering all definitions names\r\n\t\t\t\tthis.Ready = true;\r\n\t\t\t\tGetId(\"Report_Ready\").remove();\r\n\t\t\t\tthis.compute(); //Compute\r\n\t\t\t}.bind(this));\r\n\t\t}\r\n\t\treturn this;\r\n\t}\r\n\taddData(entry) { //Addition of rows/cols into the data tables\r\n\t\tlet id = \"Form_AddData\";\r\n\t\tlet available = id + \"_Available\";\r\n\t\tlet selected = id + \"_Selected\";\r\n\t\tlet availableMenu = new TabControl({\r\n\t\t\tID: available,\r\n\t\t\tLayout: \"Menu\",\r\n\t\t\tTabs: [\r\n\t\t\t\t{Label: \"Areas\", Active: true, Content: {Type: \"HTML\", Value: this.available(\"Areas\", available, selected)} },\r\n\t\t\t\t{Label: \"Ranges\", Content: {Type: \"HTML\", Value: this.available(\"Ranges\", available, selected)} },\r\n\t\t\t\t{Label: \"Concentrations\", Content: {Type: \"HTML\", Value: this.available(\"Concentrations\", available, selected)} },\r\n\t\t\t]\r\n\t\t});\r\n\t\tlet html = \"\";\r\n\t\thtml += \"<fieldset style=\\\"width:350px; overflow: auto; float: left\\\"><legend>Data available</legend><p class=\\\"Note\\\">Click to select data</p><div id=\\\"\" + available + \"\\\"></div></fieldset>\";\r\n\t\thtml += \"<fieldset style=\\\"margin-left: 400px;\\\"><legend>Selected</legend><p class=\\\"Note\\\">Click to unselect data</p><div id=\\\"\" + selected + \"\\\" style=\\\"border-top: 1px solid silver; float: left\\\"></div></fieldset>\";\r\n\t\tForm.open({\r\n\t\t\tID: id,\r\n\t\t\tSize: 800,\r\n\t\t\tTitle: \"Add \" + entry,\r\n\t\t\tHTML: html,\r\n\t\t\tButtons: [\r\n\t\t\t\t{Label: \"Ok\", Click: function() {\r\n\t\t\t\t\tlet rows = GetId(selected).children;\r\n\t\t\t\t\tthis.updateSelectedData(entry, rows);\r\n\t\t\t\t\tForm.close(id);\r\n\t\t\t\t}.bind(this)},\r\n\t\t\t\t{Label: \"Cancel\", Click: function() {\r\n\t\t\t\t\tlet rows = GetId(selected).children;\r\n\t\t\t\t\tthis.updateSelectedData(entry, rows, {Cancel: true}); //Cancel flag\r\n\t\t\t\t\tForm.close(id);\r\n\t\t\t\t}.bind(this)}\r\n\t\t\t],\r\n\t\t\tonInit: function() {\r\n\t\t\t\tavailableMenu.init();\r\n\t\t\t\tlet rows = GetId(id).getElementsByClassName(\"Selectable_Row\");\r\n\t\t\t\tlet l = rows.length;\r\n\t\t\t\tfor(let i=0; i<l; i++) {\r\n\t\t\t\t\trows[i].addEventListener(\"click\", function(e) { //Initialize the click event on each row\r\n\t\t\t\t\t\tthis.moveRow(e.target, available, selected);\r\n\t\t\t\t\t}.bind(this));\r\n\t\t\t\t}\r\n\t\t\t}.bind(this),\r\n\t\t\tonCancel: function() {\r\n\t\t\t\tlet rows = GetId(selected).children;\r\n\t\t\t\tthis.updateSelectedData(entry, rows, {Cancel: true})\r\n\t\t\t}.bind(this),\r\n\t\t});\r\n\t}\r\n\tavailable(category, sourceID, targetID) { //Create an html list of the items available for the desired category\r\n\t\tlet id = sourceID + \"_\" + category;\r\n\t\tlet html = \"<div id=\\\"\" + id + \"\\\" style=\\\"border-top: 1px solid silver\\\">\";\r\n\t\tlet source = this[category];\r\n\t\tsource.forEach(function(s, i) {\r\n\t\t\tlet toDisplay = s.Name;\r\n\t\t\tif(s.Unit) {toDisplay = s.Unit + \" (\" + s.Values.length + \" values)\"}\r\n\t\t\tif(s.Type == \"Range\") {toDisplay += \" (\" + s.Values.length + \" items)\"}\r\n\t\t\thtml += \"<div class=\\\"Selectable_Row\\\" category=\\\"\" + category + \"\\\" originID=\\\"\" + id + \"\\\" originIndex=\\\"\" + i + \"\\\"\";\r\n\t\t\tif(s.Available == false) {html += \" style=\\\"display: none\\\"\"}\r\n\t\t\thtml += \">\" + toDisplay + \"</div>\";\r\n\t\t});\r\n\t\thtml += \"</div>\";\r\n\t\treturn html;\r\n\t}\r\n\tmoveRow(div, available, selected) { //Swap the clicked row from available/selected tables\r\n\t\tlet cat = div.getAttribute(\"category\");\r\n\t\tlet index = Number(div.getAttribute(\"originIndex\"));\r\n\t\tlet obj = this[cat][index];\r\n\t\tif(obj.Available) { //Data is available, move to the selected box\r\n\t\t\tobj.Available = false;\r\n\t\t\tGetId(selected).insertBefore(div, null); //Move the div\r\n\t\t}\r\n\t\telse { //Not available, remove it from the selected box\r\n\t\t\tobj.Available = true;\r\n\t\t\tlet target = GetId(div.getAttribute(\"originID\"));\r\n\t\t\tlet childs = target.children;\r\n\t\t\tlet l = childs.length;\r\n\t\t\tlet inserted = false;\r\n\t\t\tlet i = 0;\r\n\t\t\twhile(inserted == false && i<l) { //Find the insertion point\r\n\t\t\t\tif(childs[i].getAttribute(\"originIndex\") > index) { //We need the object with the index just above\r\n\t\t\t\t\ttarget.insertBefore(div, childs[i]);\r\n\t\t\t\t\tinserted = true;\r\n\t\t\t\t}\r\n\t\t\t\telse {i++}\r\n\t\t\t}\r\n\t\t\tif(inserted == false) {target.insertBefore(div, null)} //No insertion point left, append it at the end\r\n\t\t}\r\n\t}\r\n\tupdateSelectedData(entry, rows, I) { //Following selection by the user, update the array of items with the new selection\r\n\t\tlet l = rows.length;\r\n\t\tfor(let i=0; i<l; i++) { //For each selected item\r\n\t\t\tlet cat = rows[i].getAttribute(\"category\");\r\n\t\t\tlet index = rows[i].getAttribute(\"originIndex\");\r\n\t\t\tlet obj = this[cat][index];\r\n\t\t\tif(I && I.Cancel) {obj.Available = true} //Unmark selected items on cancel\r\n\t\t\telse {this.UI[entry].Array.push(this[cat][index])} //Add the resolved item to the corresponding array\r\n\t\t}\r\n\t\tthis.UI[entry].update(); //Update the respTable, which will trigger the compute method\r\n\t}\r\n\tresolveAllNames() { //Resolve the names for all the definitions available\r\n\t\tlet promises = [];\r\n\t\treturn new Promise(function(resolve) { //Return a promise that will resolve when the parsing is completed\r\n\t\t\tthis.Ranges.forEach(function(r, i) { //For each definition, start the fetching process\r\n\t\t\t\tlet d = r.Definition;\r\n\t\t\t\tif(d !== undefined) {\r\n\t\t\t\t\tpromises.push(this.resolveNames(d, i));\r\n\t\t\t\t}\r\n\t\t\t\telse {promises.push(undefined)} //Push something to maintain index synchronization with Ranges and Definitions arrays\r\n\t\t\t}, this);\r\n\t\t\tPromise.all(promises).then(function(names) { //When all the fetching is done, update the object property with the resolved names\r\n\t\t\t\tthis.ResolvedNames = names;\r\n\t\t\t\tresolve();\r\n\t\t\t}.bind(this));\r\n\t\t}.bind(this));\r\n\t}\r\n\tresolveNames(d, defIndex) { //Resolve the names for the definition passed\r\n\t\tlet a = d.Area;\r\n\t\t//\r\n\t\t//\r\n\t\t//\r\n\t\t//let factor = Math.ceil(a.Tagged / a.Replicates);\r\n\t\tlet factor = a.MaxRange;\r\n\t\t//\r\n\t\t//\r\n\t\t//\r\n\t\tlet args = {\r\n\t\t\tPlate: this.UI[\"Definition_\" + defIndex].Selected, //Name of the plate where to look the data\r\n\t\t\tFactor: factor, //This factor is necessary to find the data in case no well/plate mapping are available\r\n\t\t\tDefault: \"\", //Default fallback if the element needed is outside the list\r\n\t\t\tAreaName: a.Name, //To complete generic items\r\n\t\t\tColumn: d.Mapping[Mapper.definition().Name], //Index of the column containing the data to extract\r\n\t\t\tRangeIndexBase0: a.MaxRange, //Providing the maxRange ensures that the array is filled with generic items if there is not enough definitions available in the file\r\n\t\t\tFindAll: true,\r\n\t\t}\r\n\t\treturn new Promise(function(resolve) {\r\n\t\t\td.Mapper.find(d, args).then(function(array) {\r\n\t\t\t\tlet mode = Mapper.modeWellPlate(d.Mapping);\r\n\t\t\t\tswitch(mode) { //For mapping without well location, the array returned is the list of object available, can be returned as is. Otherwise, should convert the plate array to a flat array of item\r\n\t\t\t\t\tcase \"Plate\": //FALL-THROUGH\r\n\t\t\t\t\tcase \"Direct\": resolve(array); break;\r\n\t\t\t\t\tcase \"Well\": //FALL-THROUGH\r\n\t\t\t\t\tcase \"PlateWell\": \r\n\t\t\t\t\t\tlet items = [];\r\n\t\t\t\t\t\tthis.Ranges[defIndex].Values.forEach(function(v) { //Look at the individual items for this range\r\n\t\t\t\t\t\t\titems.push(array[v.Tags[0]]); //Get the index of the first well tagged for this rangeItem, and log its definition. We enforce here that other wells for this RangeItem share the same definition, even if this is wrong\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t\tresolve(items);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}.bind(this));\r\n\t\t}.bind(this));\r\n\t}\r\n\tupdateNames(range, index) { //Update the names for the rangeIndex provided, or all the ranges if nothing is passed\r\n\t\tlet source = this.Ranges; //Fallback that will be used if range is undefined\r\n\t\tif(range !== undefined) { //A specific range is provided\r\n\t\t\tsource = Array(this.Ranges.length);\r\n\t\t\tsource[index] = range; //This is to ensure we can use the position in the array to find the correct definitions\r\n\t\t}\r\n\t\tlet collection = GetId(\"Output\").getElementsByTagName(\"TH\");\r\n\t\tlet l = collection.length;\r\n\t\tfor(let i=0; i<l; i++) { //Travel the collection and search for matching names\r\n\t\t\tlet th = collection[i];\r\n\t\t\tlet string = th.innerHTML;\r\n\t\t\tif(th.hasAttribute(\"RootName\")) {string = th.getAttribute(\"RootName\")} //In this case, recover the saved generic name\r\n\t\t\telse {th.setAttribute(\"RootName\", string)} //Save the generic name before making modifications\r\n\t\t\tsource.forEach(function(r, j) { //For each range\r\n\t\t\t\tif(r !== undefined && this.ResolvedNames[j] !== undefined) { //When a single range is provided, only one element of the array is defined. And when the range has no definitions, the resolved names are absent\r\n\t\t\t\t\tlet name = r.Name + \" #\";\r\n\t\t\t\t\tlet n = name.length;\r\n\t\t\t\t\tlet pos = string.indexOf(name);\r\n\t\t\t\t\tif(pos > -1) { //The title includes this name\r\n\t\t\t\t\t\tpos += n; //Update position to start at the #\r\n\t\t\t\t\t\tlet end = string.indexOf(\" \", pos); //Find the position of the next space\r\n\t\t\t\t\t\tlet RangeIndex = Number(string.substring(pos, end)); //Extract the range index value\r\n\t\t\t\t\t\tif(end == -1) {RangeIndex = Number(string.substring(pos))} //In cases where the name is not succeded by a unit or another area, the rangeIndex is up to the end of the string\r\n\t\t\t\t\t\tth.innerHTML = string.replace(name + RangeIndex, this.ResolvedNames[j][RangeIndex - 1]); //Replace the generic name with the definition\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}, this);\r\n\t\t}\r\n\t}\r\n\tgetValues(selectedPlate) { //Retrieve all the parameter values for for the selected plate, as an 2D array the size of the plate\r\n\t\tlet o = {Items: 0, Values: [], Params: []} //Output object containing the data for one plate\r\n\t\tlet resultIndex = this.Results.SelectedIndices[0] + 1; //The index of the result file selected (1-based), unique\r\n\t\tthis.Params.forEach(function(p, i) { //Initialize empty array to receive the values for each selected parameters that is set as numeric\r\n\t\t\tif(p.Selected && p.Numeric) { //This parameter is selected and numeric type, continue\r\n\t\t\t\to.Params.push({Index: i, Name: p.Name, ResultIndex: resultIndex});\r\n\t\t\t\to.Values.push([]); //Create empty arrays to receive the values for each parameter\r\n\t\t\t}\r\n\t\t}, this);\r\n\t\tthis.waitMessage(o.Params); //This displays waiting message\r\n\t\tlet custom = function(well, plate, row, output, parser) { //The function to run on each line\r\n\t\t\tif(plate == selectedPlate) { //We are on the right plate\r\n\t\t\t\tlet wellIndex = well.Index;\r\n\t\t\t\toutput.Params.forEach(function(param, i) { //Log the values for all parameters\r\n\t\t\t\t\toutput.Values[i][wellIndex] = row[param.Index];\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn new Promise(function(resolve) {\r\n\t\t\tthis.Result.Mapper.scan(this.Result, {Custom: custom}, o).then(function(data) {\r\n\t\t\t\tresolve(data);\r\n\t\t\t});\r\n\t\t}.bind(this));\r\n\t}\r\n\twaitMessage(params) { //Display a waiting message\r\n\t\tlet msg = \"<span class=\\\"warning\\\">Parsing values, please wait...</span>\";\r\n\t\tparams.forEach(function(param, i) { //Process all parameters\r\n\t\t\tlet bloc = Report.getBloc(this, Report.blocName(param));\r\n\t\t\tbloc.Sections.forEach(function(s) {\r\n\t\t\t\tif(s.Summary === undefined) {s.replaceContent(msg)}\r\n\t\t\t});\r\n\t\t}, this);\r\n\t}\r\n\tcompute() { //Do the job\r\n\t\tlet rows = this.UI.Rows.Array;\r\n\t\tlet cols = this.UI.Cols.Array;\r\n\t\tif(rows.length == 0 || cols.length == 0 || this.Ready != true) {return this}\r\n\t\tlet plate = this.UI.Plate.Selected;\r\n\t\tlet aggregation = this.UI.DataView.Selected;\r\n\t\tthis.getValues(plate).then(function(data) {\r\n\t\t\tdata.Params.forEach(function(p, i) {\r\n\t\t\t\tlet section = Report.getBloc(this, Report.blocName(p)).getSection(\"Values\", {TableType: \"Grouped\"});\r\n\t\t\t\tlet table = this.valueTable(rows, cols, data, i, aggregation);\r\n\t\t\t\tsection.replaceContent(\"<p class=\\\"Title\\\">Data for plate: \" + plate + \"</p>\" + table.HTML);\r\n\t\t\t}, this);\r\n\t\t\tthis.updateNames();\r\n\t\t}.bind(this));\r\n\t}\r\n\tvalueTable(rows, cols, data, paramIndex, aggregation) { //The table that will hold the data\r\n\t\treturn Analyzer.groupedTable(rows, cols, data.Values[paramIndex], aggregation);\r\n\t}\r\n}"]}
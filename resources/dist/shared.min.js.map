{"version":3,"sources":["shared-forms/Form_Color.js","shared-forms/Form_Import.js","shared-objects/CSSCOLORS.js","shared-objects/Decimal.js","shared-objects/InputObject.js","shared-objects/InputParser.js","shared-objects/Mapper.js","shared-objects/Pair.js","shared-objects/Pairing.js","shared-objects/Reporter.js","shared-objects/Unit.js","shared-tools/GetId.js","shared-objects/InputObject/InputObject_File.js","shared-objects/InputObject/InputObject_Manual.js","shared-objects/InputParser/InputParser_Papa.js","shared-objects/InputParser/InputParser_XLS.js","shared-objects/InputParser/InputParser_XLSX.js","shared-objects/Mapper/Mapper_Direct.js","shared-objects/Mapper/Mapper_Plate.js","shared-objects/Mapper/Mapper_PlateWell.js","shared-objects/Mapper/Mapper_Well.js"],"names":["Form_Color","I","this","Selected","Caller","getValue","txt","CSSCOLORS","list","forEach","c","id","Form","open","ID","HTML","Title","Buttons","Label","Click","color","setValue","after","close","bind","onInit","span","GetId","collection","document","getElementsByClassName","l","length","i","item","addEventListener","e","target","style","backgroundColor","title","Form_Import","[object Object]","init","Single","Multiple","Chain","Controls","File","html","Size","Step1","bindEvents","onCancel","cancel","OnClose","Init","Anchors","Input","Table","InputType","InputSelection","Parsing","Parser","ParserOptions","Preview","PreviewBox","WaitMask","WaitMaskCurrent","WaitMaskTotal","WaitMaskList","LinkCtrl","new","Default","Accept","ManualName","Manual","Preserve","Index","RespTable","Fields","RowNumbers","onSelect","S","oldS","index","oldIndex","selectInput","List","ControlLeft","Change","changeInputType","NewLine","togglePreview","next","Icon","Type","Space","Color","Step2","back","done","Step","b","button","addInput","append","change","bar","buttonBar","me","Value","focus","download","FileName","insertAdjacentHTML","insertAdjacentElement","T","Length","alert","fileList","f","InputObject","addRow","data","m","Data","Name","input","undefined","showParsingControls","InputParser","parse","Limit","hideControls","replaceButtons","parsingStart","Array","selected","SelectedIndices","promises","a","noPrev","push","Promise","resolve","NoInit","NoPreview","row","n","parser","FirstParsed","Math","round","children","innerHTML","Complete","parsingUp","Status","Error","parsingError","all","then","parsingDone","update","display","showControls","bool","array","ParsedInputs","mask","childs","nextElementSibling","h","max","offsetHeight","w","offsetWidth","height","width","nbRows","error","name","onError","Source","SelectedRows","SelectedCols","Other","Info","Headers","empty","reset","type","Luminescence","source","findIndex","returnAsTxt","out","fetchIndex","corr","match","map","v","pow","cutOff","min","colors","r","g","Decimal","InputStr","toString","Sgn","sign","abs","ValueStr","Floor","floor","FloorStr","ExpPosition","indexOf","DecPosition","Power","log10","RawDecimalStr","substring","PowerOffset","Decimals","Number","DecimalStr","PureValueStr","replace","PureValue","d","nice","above","offset","p","Below","Loose","digit","op","reverse","niceNumber","ReturnAsObject","A","B","pureResults","power","result","isNaN","NoTilde","diff","toExponential","sgnToText","split","toFixed","decNeeded","tf","changeParser","InputObject_File","InputObject_Manual","console","RawData","WebWorker","TotalRows","TotalCols","Infinity","onChange","Options","NoHeaders","FirstRow","Min","FirstCol","SingleCol","SkipEmptyRows","InputParser_Papa","InputParser_XLSX","InputParser_XLS","Object","values","o","highlight","parseInt","LastCol","cleanRow","header","ApplyToHeader","dataFound","previewRow","resetParsing","firstParse","setLimit","preview","stream","parsingConfig","abort","Start","Last","j","previewHeader","ErrorDetails","insertRow","Mapper","Required","Optional","Guess","first","search","here","inputs","warn","Parameters","inputTable","anchors","NoControls","showMapping","buttons","Validate","validate","Done","BackToImport","unshift","slice","guess","mappingArray","assign","Mapping","t","nodeName","parentElement","rowIndex","col","cellIndex","param","className","includes","previous","OnChange","column","rows","cells","Select","parameter","fill","valid","plateCol","plate","wellCol","well","wellDefined","plateDefined","mapping","modeWellPlate","Mapper_PlateWell","Mapper_Plate","Mapper_Well","Mapper_Direct","output","Items","PlatesID","Column","LimitReached","scan","Numeric","value","cleanValue","GlobalMax","GlobalMin","start","AreaName","FindAll","RangeIndexBase0","Pair","State","Txt","Html","plural","broken","RangeName","Broken","pair","hasItem","elt","DefPlateIndex","DefPlateName","splice","unpaired","paired","validArray","range","Editor","Tables","Areas","find","def","Definition","PlateIndex","All","sourceArray","O","RangeIndex","oldName","newName","Pairing","Result","Pairs","results","ranges","Def","Auto","Ranges","Results","newSelect","ResultManager","draw","autoPairing","state","outerHTML","editPair","ctrl","Plates","NavBar","Lookup","register","Area","plateIndex","status","setDefPlate","pairing","PlateSelect","setLinkedPlate","rename","count","defID","val","Reporter","htmlHeader","Method","win","window","write","body","report","footer","openPage","k","isArray","key","keys","updated","Conc","combineConc","Tags","combineTags","flatConcNames","flatConcTags","allNames","uniqueIndex","uniqueNames","sort","join","controls","zFactor","combination","openReport","areas","R","concat","Values","Aggregate","Combinations","conc","Grouped","Definitions","D","Unit","Root","Shift","Invert","units","u","unit","getElementById","file","super","size","Format","lastIndexOf","Help","delimiter","tab","entries","fromEntries","PapaConfig","worker","step","complete","Papa","assignOptions","parsingOptions","processRow","Sheet","Worker","terminate","SharedStrings","reject","reader","FileReader","onerror","onload","ab","dv","DataView","getOffsets","cursor","getSheets","BIFFversion","getSharedStrings","readAsArrayBuffer","getUint16","SectorSize","dir","getUint32","DirStreamOffset","StreamSize","WorkbookSector","WorkbookOffset","read","end","byteLength","Sheets","newSheet","sheetOffset","sheetType","getUint8","td","TextDecoder","view","Uint8Array","decode","Offset","s","updateList","parseString","Str","sheet","wbOffset","wbSector","FAT","getFatArray","ordered","maxIndex","getInt32","temp","set","buffer","FATnb","sector","flags","fHighByte","fRichSt","ignored","Uint16Array","code","sst","self","Cursor","dataType","recLen","parsed","Row","Col","getFloat64","parseRK","More","stop","bytes","fX100","num","exponent","mantissa","NaN","WBoffset","biff","BIFF","firstRow","lastRow","ceil","blocs","Blocs","FirstCellOffset","RowIndex","firstCellOffset","getRows","cell","postMessage","cellRow","Buffer","SheetOffset","metaSheet","blob","Blob","URL","createObjectURL","getMeta","initWorker","parseEnd","sheetAB","buildSheetAB","onmessage","onmessageerror","message","ZIP","zip","DOMParser","async","str","xml","parseFromString","getElementsByTagName","sheets","attributes","sheetId","shared","inputParser","getSheetNames","chunkSize","MaxChunkSize","Position","LastRow","rowEnd","ColCount","colName","colIndex","valStart","remaining","JSZip","loadAsync","MinMax","scanMinMax","scanPreviewColumns","Interrupt","Custom","lines","Log","Plate","Factor","fillMissingElements","PlateCol","WellCol","Well","parseIndex","Rows","Cols","plateNb"],"mappings":"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IAAA,IAAA,KAAA,CAAA,IAAA,IAAA,KAAA,CAAA,GAAA,IAAA,KACA,CAAA,IAAA,IAAA,KAAA,CAAA,IAAA,IAAA,KAAA,CAAA,IAAA,IAAA,KAAA,CAAA,IAAA,IAAA,KAAA,CAAA,IAAA,IAAA,KAAA,CAAA,EAAA,IAAA,GAAA,CAAA,IAAA,IAAA,KAAA,CAAA,IAAA,IAAA,GAAA,CAAA,IAAA,IAAA,GAAA,CAAA,IAAA,IAAA,KACA,CAAA,IAAA,IAAA,KAAA,CAAA,IAAA,IAAA,KAAA,CAAA,IAAA,IAAA,KAAA,CAAA,IAAA,IAAA,KAAA,CAAA,IAAA,IAAA,KAAA,CAAA,IAAA,IAAA,KAAA,CAAA,GAAA,IAAA,KAAA,CAAA,IAAA,IAAA,KAAA,CAAA,IAAA,IAAA,GAAA,CAAA,EAAA,IAAA,KACA,CAAA,GAAA,IAAA,IAAA,CAAA,IAAA,IAAA,KAAA,CAAA,EAAA,IAAA,KAAA,CAAA,IAAA,IAAA,KAAA,CAAA,IAAA,IAAA,KAAA,CAAA,IAAA,IAAA,KAAA,CAAA,IAAA,IAAA,IAAA,CAAA,IAAA,IAAA,KAAA,CAAA,IAAA,IAAA,KAAA,CAAA,IAAA,IAAA,KACA,CAAA,IAAA,IAAA,IAAA,CAAA,IAAA,IAAA,KAAA,CAAA,IAAA,IAAA,KAAA,CAAA,EAAA,IAAA,KAAA,CAAA,IAAA,IAAA,KAAA,CAAA,IAAA,IAAA,GAAA,CAAA,IAAA,IAAA,KAAA,CAAA,IAAA,IAAA,KAAA,CAAA,IAAA,IAAA,IAAA,CAAA,EAAA,IAAA,KACA,CAAA,IAAA,IAAA,IAAA,CAAA,GAAA,IAAA,KAAA,CAAA,IAAA,IAAA,KAAA,CAAA,GAAA,IAAA,KAAA,CAAA,IAAA,GAAA,IAAA,CAAA,IAAA,IAAA,KAAA,CAAA,IAAA,IAAA,IAAA,CAAA,GAAA,IAAA,KAAA,CAAA,IAAA,IAAA,KAAA,CAAA,IAAA,EAAA,KACA,CAAA,GAAA,IAAA,KAAA,CAAA,IAAA,IAAA,IAAA,CAAA,IAAA,GAAA,GAAA,CAAA,IAAA,IAAA,IAAA,CAAA,IAAA,GAAA,KAAA,CAAA,IAAA,IAAA,KAAA,CAAA,IAAA,IAAA,KAAA,CAAA,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","file":"shared.min.js","sourcesContent":["//**********************************************************************\r\n// FORM_COLOR - Form displaying a list of colors for the user to choose\r\n//**********************************************************************\r\nfunction Form_Color(I) { //I.Caller should be a LinkCtrl Object, or an object with setValue() and getValue() methods defined\r\n\tthis.Selected = \"white\";\r\n\tif(I && I.Caller) {this.Selected = I.Caller.getValue()}\r\n\t//var txt = \"<div>Colors available:</div>\";\r\n\tvar txt = \"\";\r\n\tCSSCOLORS.list().forEach(function(c) { //Append all available colors\r\n\t\ttxt += \"<div class=\\\"ColorBlock\\\" style=\\\"float: left; background-color: \" + c + \"\\\" title=\\\"\" + c + \"\\\"></div>\";\r\n\t});\r\n\ttxt += \"<div style=\\\"clear: both; padding-top: 10px; text-align: center\\\">Selected:&nbsp;\";\r\n\ttxt += \"<span id=\\\"Form_ColorSelected\\\" class=\\\"ColorBlock\\\" style=\\\"background-color: \" + this.Selected + \"\\\" title=\\\"\" + this.Selected + \"\\\">&nbsp;&nbsp;&nbsp;&nbsp;</span>\";\r\n\ttxt += \"</div>\";\r\n\tvar id = \"Form_Color\";\r\n\tForm.open({\r\n\t\tID: id,\r\n\t\tHTML: txt,\r\n\t\tTitle: \"Color Picker\",\r\n\t\tButtons: [\r\n\t\t\t{\r\n\t\t\t\tLabel: \"Ok\",\r\n\t\t\t\tTitle: \"Apply the selected color\",\r\n\t\t\t\tClick: function() {\r\n\t\t\t\t\tif(I) {\r\n\t\t\t\t\t\tvar color = this.Selected;\r\n\t\t\t\t\t\tif(I.Caller) {I.Caller.setValue(color)}\r\n\t\t\t\t\t\tif(I.after) {I.after(color)}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tForm.close(id);\r\n\t\t\t\t}.bind(this),\r\n\t\t\t},\r\n\t\t\t{\r\n\t\t\t\tLabel: \"Cancel\",\r\n\t\t\t\tClick: function() {Form.close(id)}\r\n\t\t\t}\r\n\t\t],\r\n\t\tonInit: function() {\r\n\t\t\tvar span = GetId(\"Form_ColorSelected\");\r\n\t\t\tvar collection = document.getElementsByClassName(\"ColorBlock\");\r\n\t\t\tvar l = collection.length;\r\n\t\t\tfor(let i=0;i<l;i++) {\r\n\t\t\t\tcollection.item(i).addEventListener(\"click\", function(e) {\r\n\t\t\t\t\tvar c = e.target.style.backgroundColor;\r\n\t\t\t\t\tthis.Selected = c;\r\n\t\t\t\t\tspan.style.backgroundColor = c;\r\n\t\t\t\t\tspan.title = c;\r\n\t\t\t\t}.bind(this));\r\n\t\t\t}\r\n\t\t}.bind(this),\r\n\t});\r\n}","//*******************************************************************************************\r\n// FORM_IMPORT - Form with options for the selection and parsing of files used to import data\r\n//*******************************************************************************************\r\nclass Form_Import {\r\n\tconstructor() {}\r\n\t//Static Methods\r\n\tstatic open(I) { //Open the form. Optional title can be supplied\r\n\t\tthis.init(I); //Initialize the class\r\n\t\tif(I.Single) {this.Multiple = false} //Single input mode\r\n\t\telse {this.Multiple = true}\r\n\t\tthis.Chain = I.Chain; //Tell the form not to reset after parsing is done, so that the user can come back on this form if needed\r\n\t\tthis.Controls.File.Multiple = this.Multiple;\r\n\t\tlet title = \"Data Import\";\r\n\t\tif(I && I.Title) {title = I.Title}\r\n\t\tForm.open({\r\n\t\t\tID: this.ID,\r\n\t\t\tHTML: this.html(),\r\n\t\t\tTitle: title,\r\n\t\t\tSize: 800,\r\n\t\t\tButtons: this.Buttons.Step1,\r\n\t\t\tonInit: function() {this.bindEvents()}.bind(this), //Initialize the LinkCtrl inputs\r\n\t\t\tonCancel: function() {this.cancel()}.bind(this),\r\n\t\t});\r\n\t\tif(I && I.OnClose) {this.OnClose = I.OnClose} //The function to run at closure. It will receive the parsed data as an array of structured objects in parameter\r\n\t\treturn this;\r\n\t}\r\n\tstatic init(I) { //Initialize internal (private) properties if not set\r\n\t\tif(this.Init) {return}\r\n\t\telse {\r\n\t\t\tvar id = \"Form_Import\";\r\n\t\t\tthis.ID = id;\r\n\t\t\tthis.Anchors = {\r\n\t\t\t\tInput: id + \"_Input\",\r\n\t\t\t\tTable: id + \"_InputTable\",\r\n\t\t\t\tInputType: id + \"_InputType\",\r\n\t\t\t\t//InputOptions: id + \"_InputOptions\",\r\n\t\t\t\tInputSelection: id + \"_InputSelection\",\r\n\t\t\t\tParsing: id + \"_Parsing\",\r\n\t\t\t\tParser: id + \"_Parser\",\r\n\t\t\t\tParserOptions: id + \"_ParserOptions\",\r\n\t\t\t\tPreview: id + \"_Preview\",\r\n\t\t\t\tPreviewBox: id + \"_PreviewBox\",\r\n\t\t\t\tWaitMask: id + \"_WaitMask\",\r\n\t\t\t\tWaitMaskCurrent: id + \"_WaitMaskCurrent\",\r\n\t\t\t\tWaitMaskTotal: id + \"_WaitMaskTotal\",\r\n\t\t\t\tWaitMaskList: id + \"_WaitMaskList\",\r\n\t\t\t}\r\n\t\t\tthis.Controls = {\r\n\t\t\t\tFile: LinkCtrl.new(\"File\", {ID: this.Anchors.Input, Default: \"\", Accept: \".txt,.csv,.xls,.xlsx\"}),\r\n\t\t\t\tManualName: LinkCtrl.new(\"Text\", {ID: this.Anchors.Input, Default: \"\", Label: \"Name\", /*NewLine: true,*/ Title: \"Type a name for your data here\"}),\r\n\t\t\t\tManual: LinkCtrl.new(\"TextArea\", {ID: this.Anchors.Input, Default: \"\", Preserve: true, Index: 1, Title: \"Type or paste your data here\"}),\r\n\t\t\t\tTable: new RespTable({ID: this.Anchors.Table, Fields: [\"Name\", \"Format\", \"Source\", \"Type\"], RowNumbers: true, Preserve: true, onSelect: function(S, oldS, index, oldIndex) {this.selectInput(index, oldIndex)}.bind(this)}),\r\n\t\t\t\tInputType: LinkCtrl.new(\"Radio\", {ID: this.Anchors.InputType, List: [\"From file(s)\", \"Manual input\"], Default: 0, ControlLeft: true, Change: function() {this.changeInputType()}.bind(this), Title: \"Type of input desired\"}),\r\n\t\t\t\tPreview: LinkCtrl.new(\"Checkbox\", {ID: this.Anchors.Preview, Default: true, Label: \"Show\", NewLine: true, Change: function() {this.togglePreview()}.bind(this), Title: \"Tick to display a preview of the parsing results\"}),\r\n\t\t\t}\r\n\t\t\tthis.Buttons = { //Definitions of buttons used in the form\r\n\t\t\t\tStep1: [ //Form dialog, step 1\r\n\t\t\t\t\t{Label: \"Next\", Click: function() {this.next()}.bind(this)},\r\n\t\t\t\t\t{Label: \"Cancel\", Icon: {Type: \"Cancel\", Space: true, Color: \"Red\"}, Click: function() {this.cancel()}.bind(this)}\r\n\t\t\t\t],\r\n\t\t\t\tStep2: [ //Form dialog, step 2\r\n\t\t\t\t\t{Label: \"Back\", Icon: {Type: \"Back\", Space: true}, Click: function() {this.back()}.bind(this)},\r\n\t\t\t\t\t{Label: \"Done\", Icon: {Type: \"Ok\", Space: true, Color: \"Green\"}, Click: function() {this.done()}.bind(this)},\r\n\t\t\t\t\t{Label: \"Cancel\", Icon: {Type: \"Cancel\", Space: true, Color: \"Red\"}, Click: function() {this.cancel()}.bind(this)}\r\n\t\t\t\t],\r\n\t\t\t}\r\n\t\t\tthis.Step = 1; //Initialize the form at its first step\r\n\t\t\tthis.Init = true;\r\n\t\t}\r\n\t\treturn this;\r\n\t}\r\n\tstatic bindEvents() { //Initialize the LinkCtrl inputs and dynamic behaviour to the elements of the form\r\n\t\tvar b = LinkCtrl.button({Label: \"Add\", Title: \"Add these inputs to the list of selected inputs\", Click: function() {this.addInput()}.bind(this)});\r\n\t\tGetId(this.Anchors.InputSelection).append(b); //Button to add the input to the table\r\n\t\tthis.Controls.Table.init();\r\n\t\tthis.Controls.InputType.init().change(); //Trigger a change on init to append the correct html attached to the selected input\r\n\t}\r\n\tstatic changeInputType() { //Follows a change in the selected input type\r\n\t\tswitch(this.Controls.InputType.Selected) {\r\n\t\t\tcase \"From file(s)\": this.Controls.File.init(); break; //In case of file, simply init the LinkCtrl object\r\n\t\t\tcase \"Manual input\": //In this case, init two LinkCtrls and create buttons to insert a Tab and export the data\r\n\t\t\t\tthis.Controls.ManualName.init();\r\n\t\t\t\tlet bar = LinkCtrl.buttonBar([\r\n\t\t\t\t\t{Label: \"Insert Tab\", Click: function() {\r\n\t\t\t\t\t\tlet me = this.Controls.Manual;\r\n\t\t\t\t\t\tme.setValue(me.Value + \"\\t\");\r\n\t\t\t\t\t\tme.focus(); //Focus back on the textarea to facilitate typing\r\n\t\t\t\t\t}.bind(this), Title: \"Click to insert a Tabulation\"},\r\n\t\t\t\t\t{Label: \"Get as txt\", Click: function() {\r\n\t\t\t\t\t\tForm.download(this.Controls.Manual.getValue(), {FileName: \"Manual_input.txt\"});\r\n\t\t\t\t\t}.bind(this), Title: \"Click to download your manual input as a txt file\"},\r\n\t\t\t\t], true); //Set the buttons inline\r\n\t\t\t\tGetId(this.Anchors.Input).insertAdjacentHTML(\"beforeend\", \"&nbsp;\");\r\n\t\t\t\tGetId(this.Anchors.Input).insertAdjacentElement(\"beforeend\", bar);\r\n\t\t\t\tthis.Controls.Manual.init();\r\n\t\t\t\tbreak;\r\n\t\t\tdefault: break;\r\n\t\t}\r\n\t\treturn this;\r\n\t}\r\n\tstatic addInput() { //Add input to the input list\r\n\t\tvar T = this.Controls.Table;\r\n\t\tif(this.Multiple == false && T.Length > 0) {alert(\"Only one input allowed!\"); return this}\r\n\t\tswitch(this.Controls.InputType.Selected) {\r\n\t\t\tcase \"From file(s)\": //Add a file to the list of input\r\n\t\t\t\tvar fileList = this.Controls.File.getValue();\r\n\t\t\t\tvar l = fileList.length;\r\n\t\t\t\tfor(let i=0;i<l;i++) { //For each file. fileList is a file collection, not an array, so forEach doesn't work here\r\n\t\t\t\t\tvar f = InputObject.new(\"File\", fileList[i]);\r\n\t\t\t\t\tT.addRow(f);\r\n\t\t\t\t}\r\n\t\t\t\tthis.Controls.File.setValue([]); //Prepare for next import\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"Manual input\": //Add manually entered data\r\n\t\t\t\tvar data = this.Controls.Manual.getValue();\r\n\t\t\t\tif(data.length > 0) { //Don't input empty values\r\n\t\t\t\t\tvar m = InputObject.new(\"Manual\", {Data: data, Name: this.Controls.ManualName.getValue()});\r\n\t\t\t\t\tT.addRow(m);\r\n\t\t\t\t\tthis.Controls.Manual.setValue(\"\"); //Reset the fields for next import\r\n\t\t\t\t\tthis.Controls.ManualName.setValue(\"\");\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tdefault: return this;\r\n\t\t}\r\n\t\tif(T.Selected.length == 0) {T.setValue([0])}\r\n\t\treturn this;\r\n\t}\r\n\tstatic selectInput(index, oldIndex) {\r\n\t\tif(index[0] == oldIndex[0]) {return}\r\n\t\tlet T = this.Controls.Table;\r\n\t\tlet input = T.Selected[0];\r\n\t\tif(input !== undefined && this.Step == 2) {\r\n\t\t\tthis.showParsingControls(input); //Show controls and init the parsing\r\n\t\t\tinput.InputParser.parse({Limit: input.Controls.Limit.Selected, Input: input});\r\n\t\t}\r\n\t\treturn this;\r\n\t}\r\n\tstatic showParsingControls(input) { //Initialize the parsing controls for the input passed. Internal use only\r\n\t\tthis.Controls.Preview.init(); //Preview show/hide control\r\n\t\tinput.Controls.Limit.init(); //Preview Limit control\r\n\t\tinput.Controls.Parser.init(); //Control for the parser selection\r\n\t\tinput.InputParser.init(); //Init the LinkCtrl options for the parser\r\n\t}\r\n\tstatic next() { //Next step in the form input form\r\n\t\tlet T = this.Controls.Table;\r\n\t\tif(T.Length == 0) {alert(\"No input selected!\"); return}\r\n\t\tT.hideControls(); //Hide input table controls\r\n\t\tthis.Step++;\r\n\t\tForm.replaceButtons(this.ID, [{Label: \"Cancel\", Icon: {Type: \"Cancel\", Space: true, Color: \"Red\"}, Click: function() {this.close()}.bind(this)}]); //Remove next button\r\n\t\tthis.parsingStart(T.Array);\r\n\t\tlet input = T.Selected[0];\r\n//*****************************************\r\n//No input selected: force selection of the first element.\r\n//This can happen when going back to delete an item, then clicking next without selection\r\n\t\tif(input === undefined) {\r\n\t\t\tT.setValue([0]);\r\n\t\t\tinput = T.Selected[0];\r\n\t\t}\r\n//*****************************************\r\n\t\tlet selected = T.SelectedIndices[0];\r\n\t\tlet promises = [];\r\n//*****************************************\r\n//For Each input, trigger a change to create a parser object and parse the file.\r\n//Parsing is necessary to ensure something is done,\r\n//even if this item is not clicked later by the user to adjust the parsing configuration.\r\n//Only the selected item needs to build its preview\r\n\t\tT.Array.forEach(function(a, i) { //Start parsing of all inputs as asynchronous tasks (promises)\r\n\t\t\tlet noPrev = true;\r\n\t\t\tif(i == selected) {noPrev = false} //Only the selected input will need to prepare a preview\r\n\t\t\tpromises.push(\r\n\t\t\t\tnew Promise(function(resolve) {\r\n\t\t\t\t\ta.Controls.Parser.change(undefined, {\r\n\t\t\t\t\t\tNoInit: true, NoPreview: noPrev,\r\n\t\t\t\t\t\tStep: function(row, n, parser) {\r\n\t\t\t\t\t\t\tlet html = \"\";\r\n\t\t\t\t\t\t\tif(parser.FirstParsed == false) {html = \"(Pre-parsing) - \"}\r\n\t\t\t\t\t\t\tif(5000 * Math.round(n / 5000) - n == 0) { //Only once every 5000 rows to save FPS\r\n\t\t\t\t\t\t\t\tGetId(this.Anchors.WaitMaskList).children[i].children[1].innerHTML = html + n;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}.bind(this),\r\n\t\t\t\t\t\tComplete: function(n) {\r\n\t\t\t\t\t\t\tthis.parsingUp(i, n); //when the parsing is completed, update the file counter and resolve\r\n\t\t\t\t\t\t\ta.Status = undefined;\r\n\t\t\t\t\t\t\tresolve();\r\n\t\t\t\t\t\t}.bind(this),\r\n\t\t\t\t\t\tError: function(e) {\r\n\t\t\t\t\t\t\tthis.parsingError(i, e);\r\n\t\t\t\t\t\t\ta.Status = \"Error\";\r\n\t\t\t\t\t\t\tresolve();\r\n\t\t\t\t\t\t}.bind(this), //Catch the error here\r\n\t\t\t\t\t});\r\n\t\t\t\t}.bind(this))\r\n\t\t\t);\r\n\t\t}, this);\r\n//*****************************************\r\n\t\tPromise.all(promises).then(function() { //After all files have been parsed, swith to next tab\r\n\t\t\tthis.parsingDone();\r\n\t\t\tthis.showParsingControls(input);\r\n\t\t\tT.update(); //Update the table to reflect any file in error\r\n\t\t\tForm.replaceButtons(this.ID, this.Buttons.Step2); //Buttons for parsing\r\n\t\t}.bind(this));\r\n\t}\r\n\tstatic back() { //A step backward\r\n\t\tthis.Step--;\r\n\t\tGetId(this.Anchors.InputSelection).style.display = \"block\";\r\n\t\tGetId(this.Anchors.Parsing).style.display = \"none\";\r\n\t\tthis.Controls.Table.showControls();\r\n\t\tForm.replaceButtons(this.ID, this.Buttons.Step1);\r\n\t}\r\n\tstatic togglePreview() { //Toggle the visibility of the preview box\r\n\t\tvar bool = this.Controls.Preview.getValue();\r\n\t\tif(bool) {GetId(this.Anchors.PreviewBox).style.display = \"block\"}\r\n\t\telse {GetId(this.Anchors.PreviewBox).style.display = \"none\"}\r\n\t}\r\n\tstatic parsingStart(array) { //Display a wait message for the array of input\r\n\t\tthis.ParsedInputs = 0;\r\n\t\tlet n = array.length;\r\n\t\tGetId(this.Anchors.WaitMaskTotal).innerHTML = n;\r\n\t\tlet list = \"\";\r\n\t\tfor(let i=0;i<n;i++) {\r\n\t\t\tlist += \"<li><span>\" + array[i].Name + \": </span><span>0</span><span> Rows found</span></li>\";\r\n\t\t}\r\n\t\tGetId(this.Anchors.WaitMaskList).innerHTML = list;\r\n\t\tlet mask = GetId(this.Anchors.WaitMask);\r\n\t\tlet childs = mask.nextElementSibling.children;\r\n\t\tlet h = Math.max(childs[0].offsetHeight, childs[1].offsetHeight) + \"px\"; //Adjust the size of the mask, so that it fits on all the content\r\n\t\tlet w = mask.nextElementSibling.offsetWidth + \"px\";\r\n\t\tmask.style.height = h;\r\n\t\tmask.style.width = w;\r\n\t\tmask.style.display = \"block\";\r\n\t}\r\n\tstatic parsingUp(index, nbRows) { //One more file parsed\r\n\t\tthis.ParsedInputs++;\r\n\t\tGetId(this.Anchors.WaitMaskCurrent).innerHTML = this.ParsedInputs;\r\n\t\tlet list = GetId(this.Anchors.WaitMaskList).children[index];\r\n\t\tlist.children[1].innerHTML = nbRows;\r\n\t\tlist.insertAdjacentHTML(\"beforeend\", \". DONE\");\r\n\t\tlist.style.color = \"green\";\r\n\t}\r\n\tstatic parsingError(index, error) { //An error occured during file parsing\r\n\t\tlet list = GetId(this.Anchors.WaitMaskList).children[index];\r\n\t\tlet name = list.children[0].innerHTML;\r\n\t\tlist.innerHTML = \"<span>\" + name + \"ERROR</span>\";\r\n\t\tlist.style.color = \"red\";\r\n\t}\r\n\tstatic parsingDone() { //Display controls\r\n\t\tGetId(this.Anchors.WaitMask).style.display = \"none\";\r\n\t\tGetId(this.Anchors.InputSelection).style.display = \"none\";\r\n\t\tGetId(this.Anchors.Parsing).style.display = \"block\";\r\n\t\tthis.togglePreview();\r\n\t}\r\n\tstatic done() { //Done\r\n\t\tlet data = [];\r\n\t\tlet onError = false;\r\n\t\tthis.Controls.Table.Array.forEach(function(input) { //Loop the input objects\r\n\t\t\tlet parser = input.InputParser;\r\n\t\t\tif(input.Status !== undefined && input.Status == \"Error\") {onError = true}\r\n\t\t\telse { //Push only valid inputs\r\n\t\t\t\tdata.push({\r\n\t\t\t\t\tSource: input.Source,\r\n\t\t\t\t\tName: input.Name,\r\n\t\t\t\t\tSize: parser.SelectedRows + \" Rows &times; \" + parser.SelectedCols + \" Cols\",\r\n\t\t\t\t\tOther: parser.Info,\r\n\t\t\t\t\tHeaders: parser.Headers,\r\n\t\t\t\t\tParser: parser,\r\n\t\t\t\t\tInput: input,\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t});\r\n\t\tif(onError) { //At least one input is in error and won't be exported. Ask confirmation\r\n\t\t\tForm.open({\r\n\t\t\t\tID: this.ID + \"_Confirm\",\r\n\t\t\t\tHTML: \"<p style=\\\"color: tomato; padding:0em 1em\\\">Inputs on error will not be exported. Are you sure you want to continue?</p>\",\r\n\t\t\t\tTitle: \"Confirm export\",\r\n\t\t\t\tButtons: [\r\n\t\t\t\t\t{Label: \"Ok\", Icon: {Type: \"Ok\", Space: true, Color: \"Green\"}, Click: function() {\r\n\t\t\t\t\t\tForm.close(this.ID + \"_Confirm\"); //Close the confirmation popup\r\n\t\t\t\t\t\tthis.close(data); //Close the Form_Import\r\n\t\t\t\t\t}.bind(this)},\r\n\t\t\t\t\t{Label: \"Cancel\", Icon: {Type: \"Cancel\", Space: true, Color: \"Red\"}, Click: function() {Form.close(this.ID + \"_Confirm\")}.bind(this)}, //Just close the confirmation popup\r\n\t\t\t\t],\r\n\t\t\t\tonCancel: function() {Form.close(this.ID + \"_Confirm\")}.bind(this), //Similar to cancel\r\n\t\t\t});\r\n\t\t}\r\n\t\telse {this.close(data)} //Close straight\r\n\t}\r\n\tstatic reset() { //Reset prior to closure\r\n\t\tthis.Controls.Table.empty(); //Empty the input list\r\n\t\tthis.Step = 1; //Move back to step 1\r\n\t\treturn this;\r\n\t}\r\n\tstatic cancel() { //Cancelling import of data: reset the form and close it without calling OnClose method\r\n\t\tthis.reset();\r\n\t\tForm.close(this.ID);\r\n\t}\r\n\tstatic close(data) { //Close the form. Contrary to cancel, this will call OnClose normally and keep the form open if chain is needed\r\n\t\tif(this.OnClose) {this.OnClose(data)} //Send data to the close function\r\n\t\tif(this.Chain === undefined || this.Chain == false) { //Do not reset unless this form is not chained with another\r\n\t\t\tthis.cancel();\r\n\t\t}\r\n\t\treturn this;\r\n\t}\r\n\tstatic html() { //The html of the form\r\n\t\tvar html = \"\";\r\n\t\thtml += \"<div id=\" + this.Anchors.WaitMask + \" class=\\\"Form_Import_DisableMask\\\">\";\r\n\t\t\thtml += \"<p><b>Parsing in progress, Please wait...</b></p>\";\r\n\t\t\thtml += \"<p><i>Parsed: <span id=\" + this.Anchors.WaitMaskCurrent + \">0</span> / <span id=\" + this.Anchors.WaitMaskTotal + \"></span></i></p>\";\r\n\t\t\thtml += \"<ul id=\" + this.Anchors.WaitMaskList + \"></ul>\";\r\n\t\thtml += \"</div>\";\r\n\t\thtml += \"<div>\"; //Main body of the form\r\n\t\t\thtml += \"<div class=\\\"Form_Import_Left\\\">\";\r\n\t\t\t\thtml += \"<fieldset><legend>Inputs selected</legend>\"; //Input list\r\n\t\t\t\t\thtml += \"<div id=\\\"\" + this.Anchors.Table + \"\\\" style=\\\"width: 320px; overflow: auto\\\"></div>\";\r\n\t\t\t\thtml += \"</fieldset>\"; \r\n\t\t\thtml += \"</div>\";\r\n\t\t\thtml += \"<div class=\\\"Form_Import_Right\\\">\";\r\n\t\t\t\thtml += \"<fieldset id=\\\"\" + this.Anchors.InputSelection + \"\\\"><legend>Input selection</legend>\"; //Input field\r\n\t\t\t\t\thtml += \"<div id=\\\"\" + this.Anchors.InputType + \"\\\"></div>\";\r\n\t\t\t\t\thtml += \"<div id=\\\"\" + this.Anchors.Input + \"\\\"></div>\";\r\n\t\t\t\thtml += \"</fieldset>\";\r\n\t\t\t\thtml += \"<fieldset id=\\\"\" + this.Anchors.Parsing + \"\\\" style=\\\"display: none\\\"><legend>Parsing</legend>\"; //Parsing field, hidden at the first place\r\n\t\t\t\t\thtml += \"<div id=\\\"\" + this.Anchors.Parser + \"\\\" style=\\\"margin-bottom: 10px;\\\"></div>\";\r\n\t\t\t\t\thtml += \"<fieldset style=\\\"float: left;\\\"><legend><i>Options</i></legend>\";\r\n\t\t\t\t\t\thtml += \"<div id=\\\"\" + this.Anchors.ParserOptions + \"\\\"></div>\";\r\n\t\t\t\t\thtml += \"</fieldset>\";\r\n\t\t\t\t\thtml += \"<fieldset><legend><i>Preview</i></legend>\";\r\n\t\t\t\t\t\thtml += \"<div id=\\\"\" + this.Anchors.Preview + \"\\\"></div>\"; //Control checkbox\r\n\t\t\t\t\t\thtml += \"<div id=\\\"\" + this.Anchors.PreviewBox + \"\\\" class=\\\"Form_Import_Preview\\\"></div>\"; //Preview \r\n\t\t\t\t\thtml += \"</fieldset>\";\r\n\t\t\t\thtml += \"</fieldset>\";\r\n\t\t\thtml += \"</div>\";\r\n\t\thtml += \"</div>\";\r\n\t\treturn html;\r\n\t}\r\n}","//****************************************************\r\n// CSSCOLORS - Simple object for listing of css colors\r\n//****************************************************\r\nclass CSSCOLORS {\r\n\tconstructor() {}\r\n\t//Static methods\r\n\tstatic list(type) {\r\n\t\tswitch(type) {\r\n\t\t\tcase \"RGB\": return [ //RGB values\r\n\t\t\t\t[135,206,250],[144,238,144],[255,182,193],[221,160,221],[240,230,140],[211,211,211],[255,255,240],[224,255,255],[255,240,245],[127,255,212],\r\n\t\t\t\t[255,218,185],[176,224,230],[176,196,222],[255,160,122],[169,169,169],[218,112,214],[255,255,224],[250,250,210],[255,239,213],[173,255, 47],\r\n\t\t\t\t[255,255,  0],[  0,255,255],[255,228,181],[102,205,170],[240,255,255],[240,128,128],[245,255,250],[255,192,203],[188,143,143],[255,250,205],\r\n\t\t\t\t[127,255,  0],[255,250,240],[255,228,196],[255,250,250],[255,255,255],[152,251,152],[238,232,170],[220,220,220],[216,191,216],[ 64,224,208],\r\n\t\t\t\t[248,248,255],[175,238,238],[240,255,240],[255,248,220],[245,222,179],[  0,255,  0],[240,248,255],[124,252,  0],[255,215,  0],[255,245,238],\r\n\t\t\t\t[230,230,250],[245,245,245],[173,216,230],[210,180,140],[253,245,230],[250,128,114],[ 32,178,170],[245,245,220],[255,140,  0],[  0,191,255],\r\n\t\t\t\t[ 50,205, 50],[255,235,205],[  0,250,154],[135,206,235],[250,240,230],[192,192,192],[154,205, 50],[250,235,215],[189,183,107],[255,105,180],\r\n\t\t\t\t[218,165, 32],[255,228,225],[255,222,173],[  0,255,127],[222,184,135],[255,165,  0],[238,130,238],[143,188,143],[244,164, 96],[  0,206,209],\r\n\t\t\t\t[255,127, 80],[ 60,179,113],[233,150,122],[ 72,209,204],[255, 99, 71],[100,149,237],[205,133, 63],[ 95,158,160],[219,112,147],[255,  0,255],\r\n\t\t\t\t[ 30,144,255],[184,134, 11],[255, 69,  0],[210,105, 30],[255, 20,147],[119,136,153],[147,112,219],[107,142, 35],[186, 85,211],[128,128,128],\r\n\t\t\t\t[205, 92, 92],[255,  0,  0],[112,128,144],[ 70,130,180],[  0,139,139],[123,104,238],[128,128,  0],[ 46,139, 87],[ 34,139, 34],[  0,128,128],\r\n\t\t\t\t[ 65,105,225],[220, 20, 60],[  0,128,  0],[106, 90,205],[199, 21,133],[105,105,105],[160, 82, 45],[153, 50,204],[ 85,107, 47],[138, 43,226],\r\n\t\t\t\t[148,  0,211],[178, 34, 34],[165, 42, 42],[139, 69, 19],[  0,100,  0],[139,  0,139],[  0,  0,255],[ 47, 79, 79],[ 72, 61,139],[128,  0,128],\r\n\t\t\t\t[139,  0,  0],[128,  0,  0],[  0,  0,205],[ 75,  0,130],[ 25, 25,112],[  0,  0,139],[  0,  0,128],[  0,  0,  0]\r\n\t\t\t]\r\n\t\t\tcase \"RGBSimple\": return [\r\n\t\t\t\t[  0,  0,255],[  0,128,  0],[128,  0,  0],[255,165,  0],[238,130,238],[128,128,  0],[128,  0,128],[  0,139,139],[255,  0,  0],[128,128,128],\r\n\t\t\t\t[255,  0,255],[ 70,130,180],[154,205, 50],[250,128,114],[ 72, 61,139],[  0,  0,  0]\r\n\t\t\t]\r\n\t\t\tcase \"Hexa\": return [ //Corresponding hexadecimal values\r\n\t\t\t\t\"87CEFA\",\"90EE90\",\"FFB6C1\",\"DDA0DD\",\"F0E68C\",\"D3D3D3\",\"FFFFF0\",\"E0FFFF\",\"FFF0F5\",\"7FFFD4\",\"FFDAB9\",\"B0E0E6\",\"B0C4DE\",\"FFA07A\",\"A9A9A9\",\"DA70D6\",\"FFFFE0\",\"FAFAD2\",\"FFEFD5\",\"ADFF2F\",\r\n\t\t\t\t\"FFFF00\",\"00FFFF\",\"FFE4B5\",\"66CDAA\",\"F0FFFF\",\"F08080\",\"F5FFFA\",\"FFC0CB\",\"BC8F8F\",\"FFFACD\",\"7FFF00\",\"FFFAF0\",\"FFE4C4\",\"FFFAFA\",\"FFFFFF\",\"98FB98\",\"EEE8AA\",\"DCDCDC\",\"D8BFD8\",\"40E0D0\",\r\n\t\t\t\t\"F8F8FF\",\"AFEEEE\",\"F0FFF0\",\"FFF8DC\",\"F5DEB3\",\"00FF00\",\"F0F8FF\",\"7CFC00\",\"FFD700\",\"FFF5EE\",\"E6E6FA\",\"F5F5F5\",\"ADD8E6\",\"D2B48C\",\"FDF5E6\",\"FA8072\",\"20B2AA\",\"F5F5DC\",\"FF8C00\",\"00BFFF\",\r\n\t\t\t\t\"32CD32\",\"FFEBCD\",\"00FA9A\",\"87CEEB\",\"FAF0E6\",\"C0C0C0\",\"9ACD32\",\"FAEBD7\",\"BDB76B\",\"FF69B4\",\"DAA520\",\"FFE4E1\",\"FFDEAD\",\"00FF7F\",\"DEB887\",\"FFA500\",\"EE82EE\",\"8FBC8F\",\"F4A460\",\"00CED1\",\r\n\t\t\t\t\"FF7F50\",\"3CB371\",\"E9967A\",\"48D1CC\",\"FF6347\",\"6495ED\",\"CD853F\",\"5F9EA0\",\"DB7093\",\"FF00FF\",\"1E90FF\",\"B8860B\",\"FF4500\",\"D2691E\",\"FF1493\",\"778899\",\"9370DB\",\"6B8E23\",\"BA55D3\",\"808080\",\r\n\t\t\t\t\"CD5C5C\",\"FF0000\",\"708090\",\"4682B4\",\"008B8B\",\"7B68EE\",\"808000\",\"2E8B57\",\"228B22\",\"008080\",\"4169E1\",\"DC143C\",\"008000\",\"6A5ACD\",\"C71585\",\"696969\",\"A0522D\",\"9932CC\",\"556B2F\",\"8A2BE2\",\r\n\t\t\t\t\"9400D3\",\"B22222\",\"A52A2A\",\"8B4513\",\"006400\",\"8B008B\",\"0000FF\",\"2F4F4F\",\"483D8B\",\"800080\",\"8B0000\",\"800000\",\"0000CD\",\"4B0082\",\"191970\",\"00008B\",\"000080\",\"000000\"\r\n\t\t\t];\r\n\t\t\tcase \"HexaSimple\": return [\r\n\t\t\t\t\"0000FF\",\"008000\",\"800000\",\"FFA500\",\"EE82EE\",\"808000\",\"800080\",\"008B8B\",\"FF0000\",\"808080\",\"FF00FF\",\"4682B4\",\"9ACD32\",\"FA8072\",\"483D8B\",\"000000\"\r\n\t\t\t];\r\n\t\t\tcase \"Simple\": return [ //Alternative array of 16 unique, css lvl3, shuffled basic colors\r\n\t\t\t\t\"blue\",\"green\",\"maroon\",\"orange\",\"violet\",\"olive\",\"purple\",\"darkcyan\",\"red\",\"gray\",\"magenta\",\"steelblue\",\"yellowgreen\",\"salmon\",\"darkslateblue\",\"black\"\r\n\t\t\t];\r\n\t\t\tdefault: return [ //Array of 138 unique, css lvl3, shuffled color names\r\n\t\t\t\t\"lightskyblue\",\"lightgreen\",\"lightpink\",\"plum\",\"khaki\",\"lightgray\",\"ivory\",\"lightcyan\",\"lavenderblush\",\"aquamarine\",\"peachpuff\",\"powderblue\",\"lightsteelblue\",\"lightsalmon\",\"darkgray\",\"orchid\",\"lightyellow\",\"lightgoldenrodyellow\",\"papayawhip\",\"greenyellow\",\r\n\t\t\t\t\"yellow\",\"cyan\",\"moccasin\",\"mediumaquamarine\",\"azure\",\"lightcoral\",\"mintcream\",\"pink\",\"rosybrown\",\"lemonchiffon\",\"chartreuse\",\"floralwhite\",\"bisque\",\"snow\",\"white\",\"palegreen\",\"palegoldenrod\",\"gainsboro\",\"thistle\",\"turquoise\",\r\n\t\t\t\t\"ghostwhite\",\"paleturquoise\",\"honeydew\",\"cornsilk\",\"wheat\",\"lime\",\"aliceblue\",\"lawngreen\",\"gold\",\"seashell\",\"lavender\",\"whitesmoke\",\"lightblue\",\"tan\",\"oldlace\",\"salmon\",\"lightseagreen\",\"beige\",\"darkorange\",\"deepskyblue\",\r\n\t\t\t\t\"limegreen\",\"blanchedalmond\",\"mediumspringgreen\",\"skyblue\",\"linen\",\"silver\",\"yellowgreen\",\"antiquewhite\",\"darkkhaki\",\"hotpink\",\"goldenrod\",\"mistyrose\",\"navajowhite\",\"springgreen\",\"burlywood\",\"orange\",\"violet\",\"darkseagreen\",\"sandybrown\",\"darkturquoise\",\r\n\t\t\t\t\"coral\",\"mediumseagreen\",\"darksalmon\",\"mediumturquoise\",\"tomato\",\"cornflowerblue\",\"peru\",\"cadetblue\",\"palevioletred\",\"magenta\",\"dodgerblue\",\"darkgoldenrod\",\"orangered\",\"chocolate\",\"deeppink\",\"lightslategray\",\"mediumpurple\",\"olivedrab\",\"mediumorchid\",\"gray\",\r\n\t\t\t\t\"indianred\",\"red\",\"slategray\",\"steelblue\",\"darkcyan\",\"mediumslateblue\",\"olive\",\"seagreen\",\"forestgreen\",\"teal\",\"royalblue\",\"crimson\",\"green\",\"slateblue\",\"mediumvioletred\",\"dimgray\",\"sienna\",\"darkorchid\",\"darkolivegreen\",\"blueviolet\",\r\n\t\t\t\t\"darkviolet\",\"firebrick\",\"brown\",\"saddlebrown\",\"darkgreen\",\"darkmagenta\",\"blue\",\"darkslategray\",\"darkslateblue\",\"purple\",\"darkred\",\"maroon\",\"mediumblue\",\"indigo\",\"midnightblue\",\"darkblue\",\"navy\",\"black\"\r\n\t\t\t];\r\n\t\t}\r\n\t}\r\n\tstatic cutOff(I) { //The cutoff value to determine black/white font\r\n\t\tif(I && I.Luminescence) {return 0.17913} //Higher: black; Lower: white; this threshold ensures highest contrast ratios (min 4.58)\r\n\t\treturn 109; //Indices 1 to 109 = black font, higher = white font\r\n\t}\r\n\tstatic fetch(i, type) { //Return the color corresponding to index i\r\n\t\tvar source = this.list(type);\r\n\t\tvar l = source.length;\r\n\t\treturn source[i%l];\r\n\t}\r\n\tstatic fetchIndex(color, type) { //Return the index corresponding to the color name\r\n\t\tvar source = this.list(type);\r\n\t\treturn source.findIndex(function(c) {return c == color});\r\n\t}\r\n\tstatic fetchRGB(color, returnAsTxt) { //Return the rgb color corresponding to the color name provided. Specify in options the list and whether to return as an array of three numbers [R, G, B] or a css-compatible text string\r\n\t\tlet source = this.list(\"RGB\");\r\n\t\tlet index = this.fetchIndex(color);\r\n\t\tlet out = source[index];\r\n\t\tif(returnAsTxt) {return \"rgb(\" + out[0] + \",\" + out[1] + \",\" + out[2] + \")\"} //CSS-compatible string for rgb color\r\n\t\telse {return out} //Return the array\r\n\t}\r\n\tstatic font(name, type) { //Return the font color for the color name provided, within the desired list\r\n\t\tif(type !== undefined && type == \"RGB_Unnamed\") { //For colors without names (generic rgb)\r\n\t\t\tlet rgb = name.match(/\\d+/g); //Creates an array of RGB values out of the string\r\n\t\t\tlet corr = rgb.map(function(v) { //Compute RGB to determine color luminance, see https://www.w3.org/TR/WCAG20/#relativeluminancedef\r\n\t\t\t\tlet c = v/255;\r\n\t\t\t\tif(c <= 0.03928) {return c / 12.92}\r\n\t\t\t\telse {return Math.pow((c + 0.055) / 1.055, 2.4)}\r\n\t\t\t});\r\n\t\t\tlet L = 0.2126 * corr[0] + 0.7152 * corr[1] + 0.0722 * corr[2];\r\n\t\t\tif(L < this.cutOff({Luminescence: true})) {return \"white\"}\r\n\t\t\telse {return \"black\"}\r\n\t\t}\r\n\t\tlet source = this.list(type);\r\n\t\tlet index = source.findIndex(function(c) {return (c == name)});\r\n\t\tif(index > -1) {\r\n\t\t\tlet cut = this.cutOff();\r\n\t\t\tif(index < cut) {return \"black\"}\r\n\t\t\telse {return \"white\"}\r\n\t\t}\r\n\t\telse return \"black\"; //Default value if the color is not found in the list\r\n\t}\r\n\tstatic heatmap(c, min, max, colors) { //Return the heatmap color for the value c, normalized between min and max, following rgb color gradient given as 2d array [min[R, G, B], middle[R, G, B], max[R, G, B]]\r\n\t\tif(min == max) {return \"rgb(\" + colors[1][0] + \", \" + colors[1][1] + \", \" + colors[1][2] + \")\"} //Only one value, return the middle color\r\n\t\tc = (c - min) / (max - min); //normalize value\r\n\t\tif(c == 0.5) {return \"rgb(\" + colors[1][0] + \", \" + colors[1][1] + \", \" + colors[1][2] + \")\"} //Easy\r\n\t\tif(c < 0.5) { //First part of the gradient\r\n\t\t\tvar r = colors[0][0] + (colors[1][0] - colors[0][0]) * 2 * c;\r\n\t\t\tvar g = colors[0][1] + (colors[1][1] - colors[0][1]) * 2 * c;\r\n\t\t\tvar b = colors[0][2] + (colors[1][2] - colors[0][2]) * 2 * c;\r\n\t\t}\r\n\t\tif(c > 0.5) { //Second part of the gradient\r\n\t\t\tvar r = colors[1][0] + (colors[2][0] - colors[1][0]) * 2 * (c - 0.5);\r\n\t\t\tvar g = colors[1][1] + (colors[2][1] - colors[1][1]) * 2 * (c - 0.5);\r\n\t\t\tvar b = colors[1][2] + (colors[2][2] - colors[1][2]) * 2 * (c - 0.5);\r\n\t\t}\r\n\t\treturn \"rgb(\" + Math.round(r) + \", \" + Math.round(g) + \", \" + Math.round(b) + \")\";\r\n\t}\r\n\tstatic HMtemplates() { //Return an array of array of colors to be used as template for 3-coloured heatmaps\r\n\t\treturn [ //Array of Low-Medium-High colors to use as templates\r\n\t\t\t[\"lightblue\", \"white\", \"tomato\"],\r\n\t\t\t[\"blue\", \"white\", \"red\"],\r\n\t\t\t[\"lightgreen\", \"khaki\", \"tomato\"],\r\n\t\t\t[\"lightgreen\", \"white\", \"tomato\"],\r\n\t\t\t[\"green\", \"black\", \"red\"],\r\n\t\t\t[\"black\", \"yellow\", \"white\"],\r\n\t\t\t[\"black\", \"blue\", \"white\"],\r\n\t\t];\r\n\t}\r\n\t/*static font(i) { //Return the font color for the color of index i from the full list\r\n\t\tvar cut = this.cutOff();\r\n\t\tvar index = i % cut;\r\n\t\tif(index < cut) {return \"black\"}\r\n\t\telse {return \"white\"}\r\n\t}*/\r\n\t/*static hexa(name, I) { //Return the hexadecimal value corresponding to the color name provided\r\n\t\tvar out = \"\";\r\n\t\tif(I && I.Sharp) {out += \"#\"} //Add the sharp if needed\r\n\t\tif(I && I.Simple) {\r\n\t\t\tvar source = this.ListSimple;\r\n\t\t\tvar target = this.HexaSimple;\r\n\t\t}\r\n\t\telse {\r\n\t\t\tvar source = this.List;\r\n\t\t\tvar target = this.Hexa;\r\n\t\t}\r\n\t\tvar i = 0;\r\n\t\tvar l = source.length;\r\n\t\twhile(i<l) {\r\n\t\t\tif(source[i] == name) {return out + target[i]}\r\n\t\t\ti++\r\n\t\t}\r\n\t\treturn out + \"000000\"; //black is returned as default if nothing match the name provided\r\n\t}*/\r\n}","//****************************************************\r\n// DECIMAL object - For clean mathematics with numbers\r\n//****************************************************\r\nclass Decimal {\r\n\tconstructor(n) {\r\n\t\tthis.Input = n; //The input number\r\n\t\tthis.InputStr = n.toString(); //String representation of the input\r\n\t\tthis.Sgn = Math.sign(n); //Sign: -1; 0; 1\r\n\t\tthis.Value = Math.abs(n); //Exclude the sign\r\n\t\tthis.ValueStr = this.Value.toString(); //String of input without sign\r\n\t\tthis.Floor = Math.floor(this.Value); //Floor part\r\n\t\tthis.FloorStr = this.Floor.toString(); //Floor part as a string\r\n\t\tthis.ExpPosition = this.InputStr.indexOf(\"e\"); //Position of the exponential operator in the input string\r\n\t\tthis.DecPosition = this.ValueStr.indexOf(\".\"); //Position of the decimal separator, in the string without sign\r\n\t\tthis.Power = Math.floor(Math.log10(this.Value)) //Calculate the power, or exponent, of the number.\r\n\t\tif(this.ExpPosition > 0) { //Exponential notation used here\r\n\t\t\tthis.RawDecimalStr = this.ValueStr.substring(this.DecPosition + 1, this.ExpPosition); //Raw decimals parts, excluding the \"e+/-xxx\"\r\n\t\t\tthis.PowerOffset = - (this.RawDecimalStr.length - 1); //The offset power to use when working with the PureValue, in order to get back to the right number\r\n\t\t}\r\n\t\telse {\r\n\t\t\tif(this.DecPosition > 0) {this.RawDecimalStr = this.ValueStr.substring(this.DecPosition + 1)} //Raw decimals parts\r\n\t\t\telse {this.RawDecimalStr = \"\"} //Case where there are no decimals \r\n\t\t\tthis.PowerOffset = -(this.RawDecimalStr.length + this.Power); //The offset power to use when working with the PureValue, in order to get back to the right number\r\n\t\t}\r\n\t\tthis.Decimals = Number(this.RawDecimalStr); //Without leading zeros\r\n\t\tthis.DecimalStr = this.Decimals.toString(); //String of the pure decimal part, wihtout leading zeros\r\n\t\tif(this.ExpPosition > 0) { //Exponential notation used here\r\n\t\t\tthis.PureValueStr = this.ValueStr.substring(0, this.DecPosition) + this.RawDecimalStr; //The pure number value, without power or dot, as a string\r\n\t\t}\r\n\t\telse {\r\n\t\t\tif(this.Floor == 0) {this.PureValueStr = this.DecimalStr}\r\n\t\t\telse {this.PureValueStr = this.InputStr.replace(/[.]/, \"\")}\r\n\t\t}\r\n\t\tthis.PureValue = Number(this.PureValueStr); //The pure number value, without power or dot\r\n\t\treturn this;\r\n\t}\r\n\t//Static methods\r\n\tstatic sgnToText(d) { //Return the txt string corresponding to the sign for the decimal object d\r\n\t\tif(d.Sgn < 0) {return \"-\"}\r\n\t\telse {return \"\"}\r\n\t}\r\n\tstatic niceNumber(n, I) { //Return the \"nicest\" number which is the closest (above or below) to n. \"Nice\" is defined as being any powers of 2, 5 or 10. The Decimal object will be returned, except if the number is explicitly requested\r\n\t\tlet nice = 0; //The nice number to return. 0 is used as a default fallback\r\n\t\tlet above = true; //Whether the nice number should be bigger or smaller than the number provided\r\n\t\tlet offset = 0; //Offset for the root digits, to make sure they fall as a number between 0 and 10\r\n\t\tlet d = new Decimal(n);\r\n\t\tlet p = d.Power;\r\n\t\tlet array = [1, 1.2, 1.25, 1.5, 1.75, 2, 2.5, 4, 5, 6, 7.5, 8, 10]; //The array to compare the root digits with. Any of these numbers is considered \"nice\" and the aim is to select the closest\r\n\t\tif(I) {\r\n\t\t\tif(I.Power) {p = I.Power}\r\n\t\t\tif(I.Below) {above = false}\r\n\t\t\tif(I.Loose) {array = [1, 2, 4, 5, 10]} //In case a looser approximation is needed\r\n\t\t}\r\n\t\tif(d.Sgn == -1) {above = !above} //In this case, should switch above/below to its opposite\r\n\t\tvar digit = d.Value / Math.pow(10, p); //The root digits\r\n\t\tif(digit > 10) { //Bring it back down between 0 and 10\r\n\t\t\toffset = 10;\r\n\t\t\tdigit -= offset;\r\n\t\t}\r\n\t\tvar op = function(a, b) {return(a <= b)} //The comparison function\r\n\t\tif(above) { //Nice number should be bigger\r\n\t\t\tarray.reverse(); //This ensures the \"smallest among the bigger\" will be used\r\n\t\t\top = function(a, b) {return(a >= b)}\r\n\t\t}\r\n\t\tarray.forEach(function(a) {if(op(a, digit)) {nice = a}}); //Compare the root digits with all of the nice numbers avaliable and pick the closest one\r\n\t\tvar niceNumber = d.Sgn * (offset + nice) * Math.pow(10, p); //Restore the nice number to the right power and sign\r\n\t\tif(I && I.ReturnAsObject) {return(new Decimal(niceNumber))}\r\n\t\telse {return niceNumber}\r\n\t}\r\n\tstatic multiply(a, b, bool) { //Perform a \"clean\" multiplication with the numbers provided and return the corresponding number. This is to avoid rounding issues\r\n\t\tif(a == 0 || b == 0) {return 0} //Trivial, but problem of power with these cases that need to be excluded\r\n\t\tlet A = new Decimal(a);\r\n\t\tlet B = new Decimal(b);\r\n\t\tlet pureResults = A.PureValue * B.PureValue; //Calculate the pure number out of the inputs\r\n\t\tlet power = A.Power + A.PowerOffset + B.Power + B.PowerOffset; //Calculate the power\r\n\t\tlet result = pureResults * Math.pow(10, power);\r\n\t\tif(bool) {return new Decimal(result)} //Output\r\n\t\telse {return result}\r\n\t}\r\n\tstatic format(n, digit, I) { //Output the number in a string format, keeping digit as precision and using scientific notation whenever required. In case of rounding, displays a leading tilde if true\r\n\t\tlet d = new Decimal(n);\r\n\t\tif(digit == 0 || isNaN(digit)) {return d.InputStr} //no formatting, return a string to be consistent with the other outputs\r\n\t\tlet out = \"~\"; //Output string\r\n\t\tif(I && I.NoTilde) {out = \"\"} \r\n\t\tlet f = d.FloorStr.length;\r\n\t\tif(d.DecPosition > 0) { //Case xx[...]xx.xx[...]xx, the number has decimals\r\n\t\t\tif(d.ValueStr.length <= (digit+1 )) {return d.InputStr} //Trivial case, no rounding. +1 for decimal place\r\n\t\t\tlet diff = d.RawDecimalStr.length - d.DecimalStr.length; //This will get the number of leading zeros for decimals, if any\r\n\t\t\tif(d.Floor == 0) { //Case 0.xx[...]xx\r\n\t\t\t\tif(diff > 0) { //Case 0.00[...]00xxx\r\n\t\t\t\t\tif(d.DecimalStr.length <= digit) {return d.Input.toExponential(d.DecimalStr.length-1)} //Simple case, no rounding necessary\r\n\t\t\t\t\telse { //Rounding required\r\n\t\t\t\t\t\tout += Decimal.sgnToText(d); //Add the sign\r\n\t\t\t\t\t\tlet array = d.DecimalStr.split(\"\");\r\n\t\t\t\t\t\tif(Number(array[digit]) > 4) {array[digit-1]++} //Rounding\r\n\t\t\t\t\t\tfor(let i=0;i<digit;i++) { //Add the decimals\r\n\t\t\t\t\t\t\tif(i == 1) {out += \".\" + array[i]} //Ensures the dot is added only if something comes behind\r\n\t\t\t\t\t\t\telse {out += array[i]}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\treturn out + \"e-\" + (diff + 1); //Add the power and return\r\n\t\t\t\t\t} \r\n\t\t\t\t}\r\n\t\t\t\telse { //Case 0.xx[...]xx\r\n\t\t\t\t\tif(d.DecimalStr.length <= digit) {return d.InputStr} //Simplest case, no rounding necessary\r\n\t\t\t\t\telse { //Round\r\n\t\t\t\t\t\tout += Decimal.sgnToText(d);\r\n\t\t\t\t\t\tout += d.Input.toFixed(digit);\r\n\t\t\t\t\t\treturn out;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse { //Case xx[...]xx.xx[...]xx\r\n\t\t\t\tif(f > (digit - 1)) {return out + d.Input.toExponential(digit-1)} //More digits in the floor than required. Use std sci notation\r\n\t\t\t\telse { //Case xx.xxx[...]xx, too much decimals\r\n\t\t\t\t\tlet decNeeded = digit - f; //How many decimals should be taken\r\n\t\t\t\t\tout += Decimal.sgnToText(d) + d.FloorStr + \".\";\r\n\t\t\t\t\tlet array = d.DecimalStr.split(\"\");\r\n\t\t\t\t\tif(Number(array[decNeeded]) > 4) {array[decNeeded-1]++} //Rounding\r\n\t\t\t\t\tfor(let i=0;i<decNeeded;i++) {out += array[i]}\r\n\t\t\t\t\treturn out;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\telse { //Case xx[...]xx, no decimals; or exponential notation\r\n\t\t\tif(d.ValueStr.length <= digit) {return d.InputStr} //Trivial case, no rounding\r\n\t\t\tvar p = f; //in the remaining, may need to round. First look for trailing zeros\r\n\t\t\twhile (d.FloorStr.substring(p, p - 1) == \"0\") {p--}\r\n\t\t\tvar power = f - p; //Get the power\r\n\t\t\tif(power > 0) { //Case xx[...]xx00[...]00\r\n\t\t\t\tvar TrueFloor = d.FloorStr.substring(0, p); //Get only the significant digits\r\n\t\t\t\tvar tf = TrueFloor.length;\r\n\t\t\t\tif(tf > 0 && tf <= digit) {return d.Input.toExponential(tf-1)} //Exact, no rounding required\r\n\t\t\t\telse {return out + d.Input.toExponential(digit-1)} //Need to round\r\n\t\t\t}\r\n\t\t\telse {return out + d.Input.toExponential(digit-1)} //No trailing zeros, need to round\r\n\t\t}\r\n\t}\r\n\t//Methods\r\n}\r\n\r\n\r\n/*function Decimal(n) {\r\n\tthis.Input = n; //The input number\r\n\t//Constructor\r\n\tthis.InputStr = n.toString(); //String representation of the input\r\n\tthis.Sgn = Math.sign(n); //Sign: -1; 0; 1\r\n\tthis.Value = Math.abs(n); //Exclude the sign\r\n\tthis.ValueStr = this.Value.toString(); //String of input without sign\r\n\tthis.Floor = Math.floor(this.Value); //Floor part\r\n\tthis.FloorStr = this.Floor.toString(); //Floor part as a string\r\n\tthis.ExpPosition = this.InputStr.indexOf(\"e\"); //Position of the exponential operator in the input string\r\n\tthis.DecPosition = this.ValueStr.indexOf(\".\"); //Position of the decimal separator, in the string without sign\r\n\tthis.Power = Math.floor(Math.log10(this.Value)) //Calculate the power, or exponent, of the number.\r\n\tif(this.ExpPosition > 0) { //Exponential notation used here\r\n\t\tthis.RawDecimalStr = this.ValueStr.substring(this.DecPosition + 1, this.ExpPosition); //Raw decimals parts, excluding the \"e+/-xxx\"\r\n\t\tthis.PowerOffset = - (this.RawDecimalStr.length - 1); //The offset power to use when working with the PureValue, in order to get back to the right number\r\n\t}\r\n\telse {\r\n\t\tif(this.DecPosition > 0) {this.RawDecimalStr = this.ValueStr.substring(this.DecPosition + 1)} //Raw decimals parts\r\n\t\telse {this.RawDecimalStr = \"\"} //Case where there are no decimals \r\n\t\tthis.PowerOffset = -(this.RawDecimalStr.length + this.Power); //The offset power to use when working with the PureValue, in order to get back to the right number\r\n\t}\r\n\tthis.Decimals = Number(this.RawDecimalStr); //Without leading zeros\r\n\tthis.DecimalStr = this.Decimals.toString(); //String of the pure decimal part, wihtout leading zeros\r\n\tif(this.ExpPosition > 0) { //Exponential notation used here\r\n\t\tthis.PureValueStr = this.ValueStr.substring(0, this.DecPosition) + this.RawDecimalStr; //The pure number value, without power or dot, as a string\r\n\t}\r\n\telse {\r\n\t\tif(this.Floor == 0) {this.PureValueStr = this.DecimalStr}\r\n\t\telse {this.PureValueStr = this.InputStr.replace(/[.]/, \"\")}\r\n\t}\r\n\tthis.PureValue = Number(this.PureValueStr); //The pure number value, without power or dot\r\n\t//Methods\r\n\tthis.sgnToText = function() { //Return the txt string corresponding to the sign\r\n\t\tif(this.Sgn < 0) {return \"-\"}\r\n\t\telse {return \"\"}\r\n\t}\r\n\tthis.format = function(digit, tilde) { //Output the number in a string format, keeping digit as precision and using scientific notation whenever required. In case of rounding, displays a leading tilde if true\r\n\t\tif(digit == 0) {return this.InputStr} //no formatting, return a string to be consistent with the other outputs\r\n\t\tif(tilde) {var out = \"~\"} else {var out = \"\"} //Prepare output\r\n\t\tvar f = this.FloorStr.length;\r\n\t\tif(this.DecPosition > 0) { //Case xx[...]xx.xx[...]xx, the number has decimals\r\n\t\t\tif(this.ValueStr.length <= (digit+1 )) {return this.InputStr} //Trivial case, no rounding. +1 for decimal place\r\n\t\t\tvar diff = this.RawDecimalStr.length - this.DecimalStr.length; //This will get the number of leading zeros for decimals, if any\r\n\t\t\tif(this.Floor == 0 && diff > 0) { //Case 0.00[...]00xxx\r\n\t\t\t\tif(this.DecimalStr.length <= digit) {return this.Input.toExponential(this.DecimalStr.length-1)} //Simple case, no rounding necessary\r\n\t\t\t\telse {return this.roundSCI(this.DecimalStr, -(diff+1), digit, out)} //Rounding required\r\n\t\t\t}\r\n\t\t\tif(this.Floor == 0 && diff == 0) { //Case 0.xx[...]xx\r\n\t\t\t\tif(this.DecimalStr.length <= digit) {return this.InputStr} //Simplest case, no rounding necessary\r\n\t\t\t\telse { //Avoiding e-1\r\n\t\t\t\t\tvar array = this.DecimalStr.split(\"\");\r\n\t\t\t\t\tout += this.sgnToText() + \"0.\"; //Add the sign\r\n\t\t\t\t\tif(Number(array[digit]) > 4) {array[digit-1]++} //Rounding\r\n\t\t\t\t\tfor(let i=0;i<digit;i++) {out += array[i]} //Add the decimals\r\n\t\t\t\t\treturn out;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t//In all these remaining cases, Floor is > 0\r\n\t\t\tif(f > (digit-1)) {return out + this.Input.toExponential(digit-1)} //Case xx[...]xx.xx[...]xx, with more digits in the floor than required. Use std sci notation\r\n\t\t\telse { //Case xx.xxx[...]xx, few decimals will be needed\r\n\t\t\t\tvar decNeeded = digit - f; //How many decimals should be taken\r\n\t\t\t\tvar array = this.DecimalStr.split(\"\");\r\n\t\t\t\tif(Number(array[decNeeded]) > 4) {array[decNeeded-1]++} //Rounding\r\n\t\t\t\tout += this.sgnToText() + this.FloorStr + \".\";\r\n\t\t\t\tfor(let i=0;i<decNeeded;i++) {out += array[i]}\r\n\t\t\t\treturn out;\r\n\t\t\t}\r\n\t\t}\r\n\t\telse { //Case xx[...]xx, no decimals; or exponential notation\r\n\t\t\tif(this.ValueStr.length <= digit) {return this.InputStr} //Trivial case, no rounding\r\n\t\t\tvar p = f; //in the remaining, may need to round. First look for trailing zeros\r\n\t\t\twhile (this.FloorStr.substring(p, p - 1) == \"0\") {p--}\r\n\t\t\tvar power = f - p; //Get the power\r\n\t\t\tif(power > 0) { //Case xx[...]xx00[...]00\r\n\t\t\t\tvar TrueFloor = this.FloorStr.substring(0, p); //Get only the significant digits\r\n\t\t\t\tvar tf = TrueFloor.length;\r\n\t\t\t\tif(tf > 0 && tf <= digit) {return this.Input.toExponential(tf-1)} //Exact, no rounding required\r\n\t\t\t\telse {return out + this.Input.toExponential(digit-1)} //Need to round\r\n\t\t\t}\r\n\t\t\telse {return out + this.Input.toExponential(digit-1)} //No trailing zeros, need to round\r\n\t\t}\r\n\t}\r\n\tthis.roundSCI = function(object, power, digit, out) { //return a string of the scientific notation of object (decimal or floor), using power for the exponential, with digit as precision, displaying \"~\" if tilde\r\n\t\tvar array = object.split(\"\");\r\n\t\tout += this.sgnToText(); //Add the sign\r\n\t\tif(Number(array[digit]) > 4) {array[digit-1]++} //Rounding\r\n\t\tfor(let i=0;i<digit;i++) { //Add the decimals\r\n\t\t\tif(i == 1) {out += \".\" + array[i]} //Ensures the dot is added only if something comes behind\r\n\t\t\telse {out += array[i]}\r\n\t\t} \r\n\t\treturn out + \"e\" + power; //Add the power and return\r\n\t}\r\n\tthis.formatConc = function(unit, digit, html) { //Format the number with its unit, using html space if true\r\n\t\tvar space = \" \";\r\n\t\tif(html) {space = \"&nbsp;\"}\r\n\t\tswitch(unit) {\r\n\t\t\tcase \"MOI\": return(unit + space + this.format(digit, true)); // invert in case of MOI\r\n\t\t\tdefault: return(this.format(digit, true) + space + unit);\r\n\t\t}\r\n\t}\r\n\tthis.niceNumber = function(I) { //Return the \"nicest\" number which is the closest (above or below) to this number. \"Nice\" is defined as being any powers of 2, 5 or 10. The Decimal object will be returned, except if the number is explicitly requested\r\n\t\tvar nice = 0;\r\n\t\tvar above = true;\r\n\t\tvar p = this.Power;\r\n\t\tvar array = [1, 1.2, 1.25, 1.5, 1.75, 2, 2.5, 4, 5, 6, 7.5, 8, 10];\r\n\t\tif(I) {\r\n\t\t\tif(I.Power) {p = I.Power}\r\n\t\t\tif(I.Below) {above = false}\r\n\t\t\tif(I.Loose) {array = [1, 2, 4, 5, 10]} //In case only a loose approximation is needed\r\n\t\t}\r\n\t\tif(this.Sgn == -1) {above = !above} //In this case, should switch above/below to its opposite\r\n\t\tvar digit = this.Value / Math.pow(10, p);\r\n\t\tif(digit > 10) {var offset = 10}\r\n\t\telse {var offset = 0}\r\n\t\tdigit -= offset;\r\n\t\tvar op = function(a, b) {return(a <= b)}\r\n\t\tif(above) { //Nice number should be bigger\r\n\t\t\tarray.reverse(); //This ensures the \"smallest among the bigger\" will be used\r\n\t\t\top = function(a, b) {return(a >= b)}\r\n\t\t}\r\n\t\tarray.forEach(function(a) {if(op(a, digit)) {nice = a}});\r\n\t\tvar niceNumber = this.Sgn * (offset + nice) * Math.pow(10, p);\r\n\t\tif(I && I.ReturnAsNumber) {return niceNumber}\r\n\t\telse {return(new Decimal(niceNumber))}\r\n\t}\r\n\tthis.multiply = function(a, I) { //Perform a \"clean\" multiplication with the number provided and return the corresponding number. This is to avoid rounding issues\r\n\t\tif(a == 0 || this.Input == 0) {return 0} //Trivial, but problem of power with these cases that need to be excluded\r\n\t\tvar input = new Decimal(a);\r\n\t\tvar pureResults = input.PureValue * this.PureValue; //Calculate the pure number out of the inputs\r\n\t\tvar power = input.Power + input.PowerOffset + this.Power + this.PowerOffset; //Calculate the power\r\n\t\tvar resultStr = pureResults + \"e\" + power; //Make up a string\r\n\t\tvar result = eval(resultStr); //Evaluate the result\r\n\t\tif(I && I.ReturnAsObject) {return new Decimal(result)} //Output\r\n\t\telse {return result}\r\n\t}\r\n}*/","//********************************************************************************\r\n// INPUTOBJECT - Object for input files/data and tracking of their parsing options\r\n//********************************************************************************\r\nclass InputObject {\r\n\tconstructor() {\r\n\t\tthis.Controls = {\r\n\t\t\tParser: LinkCtrl.new(\"Select\", {\r\n\t\t\t\tID: Form_Import.Anchors.Parser, Label: \"Parser\", Default: 0, List: [\"TXT/CSV\", \"XLSX\", \"XLS\"], \r\n\t\t\t\tTitle: \"The parser to use to parse this input\",\r\n\t\t\t\tChange: function(v, I) {\r\n\t\t\t\t\tif(I) {I.Input = this}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tI = {Input: this}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tthis.changeParser(I);\r\n\t\t\t\t}.bind(this)\r\n\t\t\t}),\r\n\t\t\tLimit: LinkCtrl.new(\"Select\", { //The limit to the number of lines to parse for the preview\r\n\t\t\t\tID: Form_Import.Anchors.Preview, Index: 1, Default: 0, Label: \"Limit\", Preserve: true, List: [\"20\", \"100\", \"500\", \"1000\", \"All\"], Title: \"Only this number of rows will be displayed in the preview. Prevent big files from crashing the browser.\",\r\n\t\t\t\tChange: function() { //on change, trigger a new parsing of the input and supply the new limit to use\r\n\t\t\t\t\tthis.InputParser.parse({Limit: this.Controls.Limit.Selected, Input: this});\r\n\t\t\t\t}.bind(this),\r\n\t\t\t}),\r\n\t\t}\r\n\t}\r\n\tstatic new(type, data) { //Create a new child InputObject\r\n\t\tswitch(type) {\r\n\t\t\tcase \"File\": return new InputObject_File(data); break; //File passed in data\r\n\t\t\tcase \"Manual\": return new InputObject_Manual(data); break; //Plain input passed in data\r\n\t\t\tdefault:\r\n\t\t\t\tconsole.error(\"Unknown type requested for InputObject (\" + type + \"). Aborted.\");\r\n\t\t\t\treturn;\r\n\t\t}\r\n\t}\r\n\t//Methods\r\n\tchangeParser(I) { //Change in the parser selected\r\n\t\tthis.InputParser = InputParser.new({Type: this.Controls.Parser.Selected, Data: this.RawData, Name: this.Name}); //Create a new parser object\r\n\t\tif(I) {I.Limit = this.Controls.Limit.Selected}\r\n\t\telse {\r\n\t\t\tI = {Limit: this.Controls.Limit.Selected}\r\n\t\t}\r\n\t\tthis.InputParser.parse(I); //Parse\r\n\t\tif(I && I.NoInit) {return}\r\n\t\tthis.InputParser.init(); //Init the LinkCtrl options for the parser\r\n\t}\r\n}","//****************************************************************\r\n// INPUTPARSER - Object for parsing of data from file/manual input\r\n//****************************************************************\r\nclass InputParser {\r\n\tconstructor(I) {\r\n\t\tthis.RawData = I.Data; //Raw data to use for the parsing\r\n\t\tthis.Name = I.Name; //Name of the input\r\n\t\tthis.WebWorker = true; //Whether to use WebWorker for parsing\r\n\t\tthis.TotalRows = 0; //Total number of rows available in the raw data\r\n\t\tthis.TotalCols = 0; //Total number of columns available in the raw data\r\n\t\tthis.SelectedRows = 0; //Effectively selected number of rows\r\n\t\tthis.SelectedCols = 0; //Effectively selected number of columns\r\n\t\tthis.Headers = []; //Array of string summarizing the headers found in the input after parsing\r\n\t\tthis.Info = \"\"; //Additional info regarding the parsing\r\n\t\tthis.Limit = Infinity; //This corresponds to the limit of rows to show in the preview\r\n\t\tthis.FirstParsed = false; //Indicate that the data need to be fully parsed once to initialize total rows/cols counts\r\n\t\tthis.Error = false; //Whether an error was encountered during parsing\r\n\t\tlet target = Form_Import.Anchors.ParserOptions; //Target ID for the options\r\n\t\tlet onChange = function() {this.parse()}.bind(this); //function() {this.clean()}.bind(this)\r\n\t\tthis.Options = {\r\n\t\t\tNoHeaders: LinkCtrl.new(\"Checkbox\", {ID: target, Label: \"No headers\", Default: false, Change: onChange, NewLine: true, Title: \"If ticked, arbitrary, default headers will be used instead of the values found in the first line\"}),\r\n\t\t\tFirstRow: LinkCtrl.new(\"Number\", {ID: target, Label: \"First Row\", Default: 1, Min: 1, Preserve: true, NewLine: true, Index: 1, Change: onChange, Title: \"Line at which the import is started\"}),\r\n\t\t\tFirstCol: LinkCtrl.new(\"Number\", {ID: target, Label: \"First Column\", Default: 1, Min: 1, Preserve: true, NewLine: true, Index: 2, Change: onChange, Title: \"Column at which the import is started\"}),\r\n\t\t\tSingleCol: LinkCtrl.new(\"Checkbox\", {ID: target, Label: \"Single column\", Default: false, Preserve: true, NewLine: true, Index: 3, Change: onChange,  Title: \"If ticked, only one column of data will be selected for import\"}),\r\n\t\t\tSkipEmptyRows: LinkCtrl.new(\"Checkbox\", {ID: target, Label: \"Skip empty rows\", Default: true, Preserve: true, NewLine: true, Index: 4, Change: onChange, Title: \"Whether empty rows are skipped\"}),\r\n\t\t}\r\n\t\treturn this;\r\n\t}\r\n\t//Static Methods\r\n\tstatic new(I) { //Create a new InputParser object of the desired type\r\n\t\tswitch(I.Type) { //Create the desired element\r\n\t\t\tcase \"TXT/CSV\": return new InputParser_Papa(I);\r\n\t\t\tcase \"XLSX\": return new InputParser_XLSX(I);\r\n\t\t\tcase \"XLS\": return new InputParser_XLS(I);\r\n\t\t\tdefault: //Exit if the type is unknown\r\n\t\t\t\tconsole.error(\"Unknown type requested for InputParser (\" + I.Type + \"). Aborted.\");\r\n\t\t\t\treturn;\r\n\t\t}\r\n\t}\r\n\tstatic highlight(txt) { //Returns an html string containing the text highlighted with a specific style\r\n\t\treturn \"<b><i><span style=\\\"color: salmon\\\">\" + txt + \"</span></b></i>\"\r\n\t}\r\n\t//Methods\r\n\tinit() { //Display controls for available options\r\n\t\tObject.values(this.Options).forEach(function(o) {o.init()});\r\n\t\treturn this;\r\n\t}\r\n\tresetParsing(I) { //Reset previous parsing data before parsing again\r\n\t\tthis.SelectedRows = 0;\r\n\t\tthis.SelectedCols = 0;\r\n\t\tthis.Error = false;\r\n\t\tif(I && I.NoPreview) {return this}\r\n\t\tGetId(Form_Import.Anchors.PreviewBox).innerHTML = \"<p>\" + InputParser.highlight(\"Preparing preview, please wait...\") + \"</p>\";\r\n\t\treturn this;\r\n\t}\r\n\tsetLimit(I) {\r\n\t\tif(I && I.Limit != \"All\") { //Set the limit of rows for preview\r\n\t\t\tthis.Limit = parseInt(I.Limit);\r\n\t\t}\r\n\t\telse {this.Limit = Infinity}\r\n\t\treturn this;\r\n\t}\r\n\tparsingOptions() { //Return an object holding parsing options that need to be recalled to clean the row as they come\r\n\t\tlet o = {\r\n\t\t\tNoHeaders: this.Options.NoHeaders.getValue(),\r\n\t\t\tFirstRow: this.Options.FirstRow.getValue() - 1, //Index of the first row\r\n\t\t\tFirstCol: this.Options.FirstCol.getValue() - 1, //Index of the first col\r\n\t\t\tSingleCol: this.Options.SingleCol.getValue(),\r\n\t\t\tSkipEmptyRows: this.Options.SkipEmptyRows.getValue(),\r\n\t\t\tLastCol: this.TotalCols, //Index of the last column to explore\r\n\t\t\tFirstParsed: this.FirstParsed,\r\n\t\t\tIndex: 0, //Tracker for row index\r\n\t\t\tSelected: -1, //Tracker for the number of selected rows\r\n\t\t};\r\n\t\tif(o.SingleCol) {o.LastCol = o.FirstCol + 1} //Only one column is needed\r\n\t\treturn o;\r\n\t}\r\n\tprocessRow(row, parser, f, o) { //Process the incoming row from the parser\r\n\t\trow = this.cleanRow(row, o);\r\n\t\tif(row) { //The row is valid\r\n\t\t\tif(o.Selected == -1) { //First selected row, prepare the header\r\n\t\t\t\tthis.header(row, o); //Prepare the header\r\n\t\t\t\tif(o.NoHeaders || this.FirstParsed == false || o.ApplyToHeader) { //In special cases, this row is processed normally and we move to the next\r\n\t\t\t\t\tf(row, 0, parser, o);\r\n\t\t\t\t\to.Selected = 1;\r\n\t\t\t\t}\r\n\t\t\t\telse {o.Selected = 0} //In normal cases ignore the header and the next row will be the first row of data\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tf(row, o.Selected, parser, o);\r\n\t\t\t\to.Selected++;\r\n\t\t\t}\r\n\t\t}\r\n\t\to.Index++;\r\n\t}\r\n\tcleanRow(data, o) { //Clean the row received so that it fits the config\r\n\t\tif(o.FirstParsed == false) {return data} //There is no cleaning needed when processing the file for the first time\r\n\t\tif(o.Index >= o.FirstRow) { //If the current row index is higher than the index requested for first line, this line should be processed\r\n\t\t\tlet row = [];\r\n\t\t\tlet dataFound = false;\r\n\t\t\tfor(let i = o.FirstCol; i < o.LastCol; i++) { //Go through the data and check for empty values\r\n\t\t\t\tif(data[i] === undefined || data[i] == \"\") {row.push(\"\")}\r\n\t\t\t\telse { //Value found, push it\r\n\t\t\t\t\trow.push(data[i]);\r\n\t\t\t\t\tdataFound = true; //At least one value found\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif(o.SkipEmptyRows && dataFound == false) {return undefined} //Empty row is excluded\r\n\t\t\telse {return row}\r\n\t\t}\r\n\t\telse {return undefined}\r\n\t}\r\n\tparse(I) { //Parse the input using provided options\r\n\t\tlet T = Form_Import.Controls.Table;\r\n\t\tif(this.Error) {\r\n\t\t\tthis.previewRow([], undefined, {Error: true});\r\n\t\t\tif(I && I.Input) {I.Input.Status = \"Error\"; T.update()}\r\n\t\t\treturn this;\r\n\t\t}\r\n\t\tthis.resetParsing(I); //Reset previous parsing data\r\n\t\tif(this.FirstParsed == false) {this.firstParse(I); return this}\r\n\t\tif(I) {this.setLimit(I)}\r\n\t\tlet name = this.Name;\r\n\t\tlet preview = true;\r\n\t\tif(I && I.NoPreview) {preview = false}\r\n\t\tthis.stream(function(row, selected, parser, parsingConfig) { //Step function\r\n\t\t\tif(preview) {\r\n\t\t\t\tlet s = T.Selected[0];\r\n\t\t\t\tif(s.Name != name) {parser.abort()} //Kill the parsing if another row is clicked in between\r\n\t\t\t\telse {\r\n\t\t\t\t\tif(selected == 0) {this.previewRow(row, parsingConfig, {Start: true})}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tif(selected < this.Limit && preview) {this.previewRow(row, parsingConfig)} //Push for the preview, only a subset\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif(I && I.Step) {I.Step(row, selected, parser)}\r\n\t\t}.bind(this), function(selected, parsingConfig) { //Completion function\r\n\t\t\tif(selected == -1) { //No rows were found\r\n\t\t\t\tthis.SelectedRows = 0;\r\n\t\t\t\tthis.SelectedCols = 0;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tthis.SelectedRows = selected; \r\n\t\t\t\tthis.SelectedCols = this.Headers.length;\r\n\t\t\t}\r\n\t\t\tif(preview && T.Selected[0].Name == name) { //Preview is not shown if a different file is selected at the moment it should be displayed\r\n\t\t\t\tthis.previewRow([], parsingConfig, {Last: true});\r\n\t\t\t}\r\n\t\t\tif(I && I.Input) {I.Input.Status = undefined; T.update()}\r\n\t\t\tif(I && I.Complete) {I.Complete(selected)}\r\n\t\t}.bind(this), {ApplyToHeader: true}); //We need to count the header row as a selected row in case the file contains the header\r\n\t}\r\n\tchunk(f, I) { //Chunk a piece of the input and apply the provided function on each chunk\r\n\t\t\r\n\t}\r\n\tbulk(f) { //Apply the supplied function to the entire bulk of data, once the streaming is complete. This is sure to crash for big files\r\n\t\tlet out = [];\r\n\t\tthis.stream(function(row, selected, parser, parsingConfig) { //Step function\r\n\t\t\tout.push(row); //Accumulate all the data\r\n\t\t}.bind(this), function(selected, parsingConfig) { //Completion function\r\n\t\t\tf(out); //Execute function on the bulk\r\n\t\t});\r\n\t}\r\n\theader(row, o) { //Prepare the header based on row parsed\r\n\t\tthis.Headers = [];\r\n\t\tif(o.NoHeaders) { //No headers in the file, generate arbitraries column names\r\n\t\t\trow.forEach(function(r, j) { //For each column, prepare an arbitrary header\r\n\t\t\t\tthis.Headers.push(\"Col_\" + (j+1));\r\n\t\t\t}, this);\r\n\t\t}\r\n\t\telse {\r\n\t\t\trow.forEach(function(r, j) { //In this case, just complete empty values with arbitrary headers\r\n\t\t\t\tif(r == \"\") {this.Headers.push(\"Col_\" + (j+1))}\r\n\t\t\t\telse {this.Headers.push(r)}\r\n\t\t\t}, this);\r\n\t\t}\r\n\t\treturn this;\r\n\t}\r\n\tpreviewHeader() { //Header for the preview\r\n\t\tlet out = \"<tr>\";\r\n\t\tthis.Headers.forEach(function(h) { //Preview of the headers\r\n\t\t\tout += \"<th>\" + h + \"</th>\";\r\n\t\t});\r\n\t\tout += \"</tr>\";\r\n\t\treturn out;\r\n\t}\r\n\tpreviewRow(row, o, I) { //Receives a row for the preview and append it to the preview window\r\n\t\tlet out = \"\";\r\n\t\tif(I && I.Start) {\r\n\t\t\tout += \"<div><p>\" + InputParser.highlight(\"Preparing preview, please wait...\") + \"</p>\";\r\n\t\t\tout += \"* Total available Rows: <b>\" + this.TotalRows + \"</b>; Columns: <b>\" + this.TotalCols + \"</b>\";\r\n\t\t\tout += \"</div><div><table>\"; //Headings and Table are wrapped in a div for styling\r\n\t\t\tout += this.previewHeader();\r\n\t\t\tout += \"</table></div>\";\r\n\t\t\tGetId(Form_Import.Anchors.PreviewBox).innerHTML = out;\r\n\t\t\tif(o.NoHeaders) {out = \"\"}\r\n\t\t\telse {return this}\r\n\t\t}\r\n\t\tif(I && I.Last) {\r\n\t\t\tlet selected = this.SelectedRows;\r\n\t\t\tout += \"* Total available Rows: <b>\" + this.TotalRows + \"</b>; Columns: <b>\" + this.TotalCols + \"</b>\"; //Reset previous content in out\r\n\t\t\tout += \"<br>* Selected Rows: <b>\" + selected + \"</b>\";\r\n\t\t\tif(o.NoHeaders == false) {out += \" (including header row)\"}\r\n\t\t\tout\t+= \"; Columns: <b>\" + this.SelectedCols + \"</b>\";\r\n\t\t\tif(selected > this.Limit) {\r\n\t\t\t\tout += InputParser.highlight(\"<br>Now showing only \" + this.Limit + \" rows.\");\r\n\t\t\t}\r\n\t\t\tGetId(Form_Import.Anchors.PreviewBox).children[0].innerHTML = out;\r\n\t\t\treturn this;\r\n\t\t}\r\n\t\tif(I && I.Error) {\r\n\t\t\tout = \"<p>\" + InputParser.highlight(\"Parsing failed!\") + \"</p><p>Reason:<br>\" + this.ErrorDetails + \"</p><p>Try with a different parser or validate the input before trying again</p>\";\r\n\t\t\tGetId(Form_Import.Anchors.PreviewBox).innerHTML = out;\r\n\t\t\treturn this;\r\n\t\t}\r\n\t\trow.forEach(function(c, j) { //For each value\r\n\t\t\tout += \"<td>\"\r\n\t\t\tif(c == \"\") {out += InputParser.highlight(\"&Oslash;\")}\r\n\t\t\telse {out += c}\r\n\t\t\tout += \"</td>\";\r\n\t\t});\r\n\t\tGetId(Form_Import.Anchors.PreviewBox).children[1].children[0].insertRow().insertAdjacentHTML(\"beforeend\", out);\r\n\t}\r\n}","//******************************************************************************************************************\r\n// MAPPER object - Allow mapping of columns to specific contents and searching of data within file using the mapping\r\n//******************************************************************************************************************\r\nclass Mapper {\r\n\tconstructor() {return this}\r\n\t//Static Methods\r\n\tstatic well(I) { //Required for results, not for definitions\r\n\t\tlet bool = true;\r\n\t\tif(I && I.Required) {bool = false}\r\n\t\treturn {Name: \"Well ID\", Optional: bool, Guess: function(h, first) {return h.search(/well/i) > -1}}\r\n\t}\r\n\tstatic plate() {return {Name: \"Plate ID\", Optional: true, Guess: function(h, first) {return (h.search(/barcode/i) > -1 || h.search(/plate/i) > -1)}}}\r\n\tstatic definition() {return {Name: \"Definition\"}} //Required\r\n\tstatic import() {return {Name: \"Import\", Multiple: true}} //Required\r\n\tstatic numeric() {\r\n\t\treturn {Name: \"Numeric\", Multiple: true, Optional: true, Guess: function(h, first) {\r\n\t\t\tif(first.search !== undefined) {return first.search(/[a-z]/gi) == -1}\r\n\t\t\telse {return true}\r\n\t\t}}\r\n\t}\r\n\tstatic anchors(here) { //Return the text for the anchors requested\r\n\t\tlet id = \"Mapper\";\r\n\t\tswitch(here) {\r\n\t\t\tcase \"Table\": return id + \"_inputTable\";\r\n\t\t\tcase \"Param\": return id + \"_Parameters\";\r\n\t\t\tdefault: return id;\r\n\t\t}\r\n\t}\r\n\tstatic map(inputs, I) { //Allow mapping of columns for the passed array of inputs, with mapping configuration passed as object in option\r\n//*****************************************************************************************\r\n//\tValidate: true/false, check for mandatory field and reject the mapping if not complete,\r\n//\tBackToImport: true/false, indicates whether it is possible to go back to the Form_Import on closure of this form\r\n//\tDone: function(), run after mapping is closed by the user\r\n//\tParameters: [], array of objects with the following structure:\r\n//\t\tName, Optional: true/false, Multiple: true/false,\r\n//\t\tGuess: function(h, f) [a function accepting the header h and first element f, that return true if the parameter should be selected],\r\n//*****************************************************************************************\r\n\t\tif(inputs === undefined || inputs.length == 0) {console.warn(\"No inputs provided to the mapper\"); return} //No inputs passed\r\n\t\tif(I === undefined || I.Parameters == undefined || I.Parameters.length == 0) {console.warn(\"Mandatory options not passed to the mapper\"); return} //No parameters to map\r\n\t\tlet inputTable = new RespTable({ //RespTable to navigate between the inputs\r\n\t\t\tID: Mapper.anchors(\"Table\"),\r\n\t\t\tArray: inputs,\r\n\t\t\tFields: [\"Name\", \"Size\"],\r\n\t\t\tPreserve: true, RowNumbers: true, NoControls: true,\r\n\t\t\tonSelect: function(array) {\r\n\t\t\t\tif(array.length > 0) {Mapper.showMapping(array[0], inputTable, I)}\r\n\t\t\t},\r\n\t\t});\r\n\t\tlet html = \"\"; //Prepare the html for the form\r\n\t\thtml += \"<div id=\\\"\" + Mapper.anchors(\"Table\") + \"\\\" style=\\\"float:left; width:300px; overflow:auto;\\\"><p><b>Inputs available:</b></p></div>\";\r\n\t\thtml += \"<div style=\\\"margin-left:320px\\\">\";\r\n\t\t\thtml += \"<p><b>Parameter mapping:</b></p>\";\r\n\t\t\thtml += \"<div id=\\\"\" + Mapper.anchors(\"Param\") + \"\\\" style=\\\"max-height:500px; overflow:auto\\\"></div>\"; \r\n\t\thtml += \"</div>\";\r\n\t\tlet id = \"Form_ParameterMapping\";\r\n\t\tlet buttons = [ //Buttons that will be applied to the form\r\n\t\t\t{Label: \"Done\", Icon: {Type: \"Ok\", Space: true, Color: \"Green\"}, Click: function() { //Mapping is completed\r\n\t\t\t\tif(I.Validate) {\r\n\t\t\t\t\tif(Mapper.validate(inputs, I) == false) {return}\r\n\t\t\t\t}\r\n\t\t\t\tif(I.Done) {I.Done()}\r\n\t\t\t\tif(I.BackToImport) { //In this case, need to close the Form_Import as well\r\n\t\t\t\t\tForm_Import.cancel(); //Reset and close the form without calling OnClose again\r\n\t\t\t\t}\r\n\t\t\t\tForm.close(id);\r\n\t\t\t}},\r\n\t\t];\r\n\t\tif(I.BackToImport) { //In this case, add a button to close this form, allowing to return to the Form_Import\r\n\t\t\tbuttons.unshift({Label: \"Back to parsing\", Icon: {Type: \"Back\", Space: true}, Click: function() { //Add the button at the beginning of the array\r\n\t\t\t\tinputs.slice(0, I.Index); //Newly elements added must be rejected from the input list\r\n\t\t\t\tForm.close(id);\r\n\t\t\t}}); \r\n\t\t}\r\n\t\tForm.open({\r\n\t\t\tID: id,\r\n\t\t\tHTML: html,\r\n\t\t\tTitle: \"Parameter mapping\",\r\n\t\t\tSize: 800,\r\n\t\t\tButtons: buttons,\r\n\t\t\tonInit: function() { //Initialize the respTable on open\r\n\t\t\t\tinputTable.init();\r\n\t\t\t\tlet sel = inputTable.Selected;\r\n\t\t\t\tif(sel.length == 0) {inputTable.setValue([0])} //Force selection of the first element if nothing selected\r\n\t\t\t\tMapper.showMapping(inputTable.Selected[0], inputTable, I);\r\n\t\t\t},\r\n\t\t});\r\n\t}\r\n//************************************************************************************************************\r\n//Since this method will first run asynchronously to parse the first line of the file for guessing,\r\n//we need to check that the input selected at the end is same as the one passed, before appending the preview.\r\n//So it is better to also pass the inputTable here, instead of the selected result object alone\r\n//************************************************************************************************************\r\n\tstatic showMapping(input, inputTable, I) { //Show the mapping table for the selected input\r\n\t\tif(input.FirstRow === undefined) { //Parse the first row so that mapping can be guessed based on the values found\r\n\t\t\tGetId(Mapper.anchors(\"Param\")).innerHTML = \"<p class=\\\"Error\\\">Processing file, please wait...</p>\";\r\n\t\t\tinput.Parser.stream(function(row, selected, parser) { //Extract only the first row\r\n\t\t\t\tinput.FirstRow = row;\r\n\t\t\t\tparser.abort();\r\n\t\t\t}, function() { //When parsing is done, process the array\r\n\t\t\t\tMapper.guess(input, I);\r\n\t\t\t\tif(input.Name == inputTable.Selected[0].Name) {Mapper.mappingArray(input, inputTable, I)} //Prevent display if something else is clicked in between\r\n\t\t\t});\r\n\t\t}\r\n\t\telse {Mapper.mappingArray(input, inputTable, I)} //First column already parsed, the method can run synchronously\r\n\t}\r\n\tstatic guess(input, I) { //For the input provided, compute a guess for the mapping using the functions provided by the user\r\n\t\tinput.Parser.Headers.forEach(function(h, i) { //Loop the input headers\r\n\t\t\tI.Parameters.forEach(function(p, j) { //Loop the parameters to map\r\n\t\t\t\tif(p.Guess && p.Guess(h, input.FirstRow[i])) { //Try the provided guess function and assign the mapping is correct\r\n\t\t\t\t\tMapper.assign(input, p, i);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t});\r\n\t}\r\n\tstatic mappingArray(input, inputTable, I) { //Build the array allowing mapping of parameters for the input\r\n\t\tlet html = \"<span class=\\\"FootNote\\\">Fields marked with * are mandatory</span>\";\r\n\t\thtml += \"<table class=\\\"RespTable\\\"><thead><tr><th>#</th><th>Name</th>\";\r\n\t\tI.Parameters.forEach(function(p) {\r\n\t\t\thtml += \"<th>\" + p.Name;\r\n\t\t\tif(!p.Optional) {html += \"<span class=\\\"Error\\\">*</span>\"}\r\n\t\t\tif(p.Multiple) {html += \"<br><span class=\\\"Hyperlink\\\">All</span>&nbsp;/&nbsp;<span class=\\\"Hyperlink\\\">None</span>\"}\r\n\t\t\thtml += \"</th>\";\r\n\t\t});\r\n\t\thtml += \"</tr></thead>\";\r\n\t\tinput.Parser.Headers.forEach(function(h, i) { //Loop the input headers to build table rows\r\n\t\t\thtml += \"<tr><td>\" + (i + 1) + \"</td><td>\" + h + \"</td>\"; //#, Name\r\n\t\t\tI.Parameters.forEach(function(p, j) { //Loop the parameters to map\r\n\t\t\t\thtml += \"<td style=\\\"transform: scale(0.8)\\\" class=\\\"RespTable_Row\";\r\n\t\t\t\tif(input.Mapping !== undefined && input.Mapping[p.Name] !== undefined) { //Reuse existing config if defined\r\n\t\t\t\t\tif(p.Multiple) { //In this case, mapping is an array with true/false\r\n\t\t\t\t\t\tif(input.Mapping[p.Name][i]) {html += \" RespTable_Selected Mapped\" + j}\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse { //In this case, the mapping directly holds the value\r\n\t\t\t\t\t\tif(input.Mapping[p.Name] == i) {html += \" RespTable_Selected Mapped\" + j}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\thtml += \"\\\"></td>\";\r\n\t\t\t});\r\n\t\t\thtml += \"</tr>\";\r\n\t\t});\r\n\t\thtml += \"</table>\";\r\n\t\tlet target = GetId(Mapper.anchors(\"Param\"));\r\n\t\ttarget.innerHTML = html; //Append the html\r\n\t\ttarget.children[1].addEventListener(\"click\", function(e) { //Bind events to the table\r\n\t\t\tlet t = e.target;\r\n\t\t\tswitch(t.nodeName) {\r\n\t\t\t\tcase \"TD\": //Table cells are responsive\r\n\t\t\t\t\tlet row = t.parentElement.rowIndex - 1; //The clicked row minus the table header\r\n\t\t\t\t\tlet col = t.cellIndex; //Clicked column\r\n\t\t\t\t\tif(col > 1) { //The 2 first columns are # and name and can be ignored\r\n\t\t\t\t\t\tlet param = I.Parameters[col - 2];\r\n\t\t\t\t\t\tif(param.Multiple) { //Multiple choices allowed\r\n\t\t\t\t\t\t\tif(t.className.includes(\"RespTable_Selected\")) {t.className = \"RespTable_Row\"} //When selected, turn it off\r\n\t\t\t\t\t\t\telse {t.className = \"RespTable_Row RespTable_Selected Mapped\" + (col - 2)} //The opposite\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse { //Only one choice\r\n\t\t\t\t\t\t\tif(t.className.includes(\"RespTable_Selected\")) { //Strategy differs if optional or not\r\n\t\t\t\t\t\t\t\tif(param.Optional) {t.className = \"RespTable_Row\"} //When selected, turn it off\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\telse { //Select this cell and unselect the others\r\n\t\t\t\t\t\t\t\tlet previous = target.getElementsByClassName(\"Mapped\" + (col - 2));\r\n\t\t\t\t\t\t\t\tif(previous && previous[0]) {previous[0].className = \"RespTable_Row\"}\r\n\t\t\t\t\t\t\t\tt.className = \"RespTable_Row RespTable_Selected Mapped\" + (col - 2);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tMapper.assign(input, param, row);\r\n\t\t\t\t\t\tif(I.OnChange) {I.OnChange(input)}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tinputTable.update();\r\n\t\t\t\tbreak;\r\n\t\t\t\tcase \"SPAN\": //To select all or nothing at once\r\n\t\t\t\t\tlet column = t.parentElement.cellIndex;\r\n\t\t\t\t\tlet c = \"RespTable_Row\"; //The new class\r\n\t\t\t\t\tlet bool = false;\r\n\t\t\t\t\tif(t.innerHTML == \"All\") { //Select all\r\n\t\t\t\t\t\tc = \"RespTable_Row RespTable_Selected Mapped\" + (column - 2);\r\n\t\t\t\t\t\tbool = true;\r\n\t\t\t\t\t} \r\n\t\t\t\t\tinput.Parser.Headers.forEach(function(h, i) {\r\n\t\t\t\t\t\ttarget.children[1].rows[i + 1].cells[column].className = c;\r\n\t\t\t\t\t\tMapper.assign(input, I.Parameters[column - 2], i, {Select: bool});\r\n\t\t\t\t\t});\r\n\t\t\t\t\tif(I.OnChange) {I.OnChange(input)}\r\n\t\t\t\t\tinputTable.update();\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\tstatic assign(input, parameter, index, I) { //For the input given, assign the parameter to the provided index (as the index in Header array)\r\n\t\tif(input.Mapping === undefined) {input.Mapping = {}} //Initialize a mapping object if needed\r\n\t\tlet name = parameter.Name;\r\n\t\tif(parameter.Multiple) { //The strategy is different is they are multiple assignments or just one\r\n\t\t\tif(input.Mapping[name] === undefined) { //For multiple assignement, held an array of boolean to indicate selected or not. Initialize the array here if not done\r\n\t\t\t\tinput.Mapping[name] = Array(input.Parser.Headers.length).fill(false);\r\n\t\t\t}\r\n\t\t\tif(I) { //To force a selection\r\n\t\t\t\tif(I.Select) {input.Mapping[name][index] = true}\r\n\t\t\t\telse {input.Mapping[name][index] = false}\r\n\t\t\t}\r\n\t\t\telse {input.Mapping[name][index] = !input.Mapping[name][index]} //Normal case, switch the value\r\n\t\t}\r\n\t\telse { //Only one mapping possible\r\n\t\t\tif(parameter.Optional && input.Mapping[name] == index) {input.Mapping[name] = -1} //This will neutralize the selection without initiating a guess when editing the mapping\r\n\t\t\telse {input.Mapping[name] = index}\r\n\t\t}\r\n\t}\r\n\tstatic validate(inputs, I) { //Validate that all mandatory assignments are done in the inputs\r\n\t\tlet l = I.Parameters.length;\r\n\t\tlet valid = true;\r\n\t\tlet i = 0;\r\n\t\twhile(valid && i < l) { //Loop the parameters\r\n\t\t\tlet p = I.Parameters[i];\r\n\t\t\tif(p.Optional === undefined || p.Optional == false) { //Need to validate only the required parameters\r\n\t\t\t\tlet n = inputs.length;\r\n\t\t\t\tlet j = 0;\r\n\t\t\t\twhile(valid && j < n) { //Loop over the inputs\r\n\t\t\t\t\tif(inputs[j].Mapping === undefined || inputs[j].Mapping[p.Name] === undefined) {valid = false} //Nothing defined, reject\r\n\t\t\t\t\telse { //Something is here, but it doesn't mean it's ok yet\r\n\t\t\t\t\t\tif(p.Multiple) { //For this specific case, need to ensure at least one is selected\r\n\t\t\t\t\t\t\tvalid = inputs[j].Mapping[p.Name].includes(true); //Will be false if all values are false\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif(!valid) { //Stop as soon as a required parameter is not assigned\r\n\t\t\t\t\t\talert(\"Parameter \\\"\" + p.Name + \"\\\" has not been assigned for input \\\"\" + inputs[j].Name + \"\\\".\");\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tj++;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\ti++;\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n\tstatic modeWellPlate(m) { //For the mapping object provided, return the mode needed to find the items: [plate only, well only, plate & well, direct]\r\n\t\tlet plateCol = m[Mapper.plate().Name];\r\n\t\tlet wellCol = m[Mapper.well().Name];\r\n\t\tlet wellDefined = false;\r\n\t\tlet plateDefined = false;\r\n\t\tif(wellCol !== undefined && wellCol > -1) {wellDefined = true}\r\n\t\tif(plateCol !== undefined && plateCol > -1) {plateDefined = true}\r\n\t\tif(wellDefined && plateDefined) {return \"PlateWell\"} //Both are defined\r\n\t\telse { //At least one is not defined\r\n\t\t\tif(wellDefined) {return \"Well\"}\r\n\t\t\tif(plateDefined) {return \"Plate\"}\r\n\t\t}\r\n\t\treturn \"Direct\";\r\n\t}\r\n//*********************************************************************************************\r\n//Justification for the definition of four independent mapper classes: the only alternative\r\n//way is to check the mode desired (PlateWell, Plate, Well, Direct) within the stream function,\r\n//then start the right subfunctions. But since this test needs to be performed for each line\r\n//of the file, it seems more efficient to define separate functions and run then without this\r\n//switch. It makes more lines of code, but the parsing runs faster, especially for big files.\r\n//Since the 4 classes are written independently in separated files, this way of doing also\r\n//does not reduce the code readability and maintenance.\r\n//*********************************************************************************************\r\n\tstatic new(mapping) { //Return the mapper object that fits the mapping provided\r\n\t\tswitch(Mapper.modeWellPlate(mapping)) {\r\n\t\t\tcase \"PlateWell\": return new Mapper_PlateWell(mapping);\r\n\t\t\tcase \"Plate\": return new Mapper_Plate(mapping);\r\n\t\t\tcase \"Well\": return new Mapper_Well(mapping);\r\n\t\t\tcase \"Direct\": return new Mapper_Direct(mapping);\r\n\t\t}\r\n\t}\r\n//*********************************************************************************************\r\n\tstatic scan(o, I) { //Scan the file and execute some actions as described in the options passed: Preview(limit), Log, Min/Max. Returns a promise\r\n\t\tif(o === undefined) {return Promise.resolve({Error: \"No file selected\"})}\r\n\t\tif(I === undefined) {console.warn(\"Mapper.scan is missing parameters to run\"); return Promise.resolve({Error: \"Internal error, check console for details\"})}\r\n\t\tlet output = { //Output object\r\n\t\t\tItems: 0, //The number of valid items\r\n\t\t\tPlatesID: [], //To log the plate names\r\n\t\t}\r\n\t\tif(I.Preview) {\r\n\t\t\toutput.Preview = \"\"; //To build a preview of the rows within the limit provided\r\n\t\t\toutput.Column = o.Mapping[I.Preview.Column]; //The column(s) to use for the preview content\r\n\t\t\toutput.Limit = (I.Preview.Limit || 50); //How many lines in the preview\r\n\t\t\toutput.LimitReached = false; //Whether the max number of lines has been reached\r\n\t\t}\r\n\t\treturn o.Mapper.scan(o, I, output);\r\n\t}\r\n\tstatic cleanValue(v) { //Clean the value recovered from the Mapper, to ensure smooth conversion to a number and correct handling of empty/crashing strings\r\n\t\tif(v == \"\" || v == \"Infinity\") {return undefined}\r\n\t\telse {return Number(v)}\r\n\t}\r\n\tstatic scanMinMax(o, row) { //Evaluate Min/Max and update the properties for the object passed\r\n\t\to.Parameters.forEach(function(p, i) { //For each numerical parameter, update the global min/max values\r\n\t\t\tif(p.Numeric) {\r\n\t\t\t\t//let value = Number(row[i]);\r\n\t\t\t\tlet value = Mapper.cleanValue(row[i]);\r\n\t\t\t\tif(value > p.GlobalMax) {p.GlobalMax = value}\r\n\t\t\t\tif(value < p.GlobalMin) {p.GlobalMin = value}\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\tstatic scanPreviewColumns(output, row, start) { //Append row data to the preview\r\n\t\tif(output.Items < output.Limit) { //Limit not reached\r\n\t\t\tlet column = output.Column;\r\n\t\t\tif(output.Items > 0) {output.Preview += \"\\n\"}\r\n\t\t\toutput.Preview += start;\r\n\t\t\tif(column !== undefined) { //Should add the column(s) to the preview\r\n\t\t\t\tif(column.length) { //In this case we have an array of booleans\r\n\t\t\t\t\tcolumn.forEach(function(c, i) {\r\n\t\t\t\t\t\tif(c) {output.Preview += \" \" + row[i]}\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t\telse {output.Preview += \" \" + row[column]} //Only one value\r\n\t\t\t}\r\n\t\t}\r\n\t\telse {output.LimitReached = true} //Limit reached\r\n\t}\r\n\tstatic fillMissingElements(out, I, start, index) { //Check that the definition has enough elements and complete with generic names if required\r\n\t\tlet name = \"\";\r\n\t\tif(I.AreaName) {name = I.AreaName + \" \"}\r\n\t\tif(I.FindAll && out.length < I.RangeIndexBase0) { //This means the definition is missing elements\r\n\t\t\twhile(index < I.RangeIndexBase0) { //Complete with generic names\r\n\t\t\t\t//out.push(I.Default + \" #\" + (start + index + 1));\r\n\t\t\t\tout.push(name + \"#\" + (start + index + 1));\r\n\t\t\t\tindex++;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn out;\r\n\t}\r\n}","//**************************************************************************************************\r\n// Object - To handle data pairing between results and definitions, at the single result plate level\r\n//**************************************************************************************************\r\nclass Pair {\r\n\tconstructor() {\r\n\t\tthis.Table = []; //An array of objet containing the information required to recover the corresponding plates from the linked definitions\r\n\t\treturn this;\r\n\t}\r\n\t//Static Methods\r\n\tstatic unpaired() { //Return an object indicating that the current Pair object is empty (result plate unpaired)\r\n\t\tlet txt = \"There are currently no definition plates paired to this result plate\";\r\n\t\tlet html = \"<span style=\\\"font-size: 0.8em; font-style: italic\\\" title=\\\"\" + txt + \"\\\">Unpaired</span>&nbsp;\";\r\n\t\treturn {State: \"unpaired\", Txt: txt, Html: html}\r\n\t}\r\n\tstatic paired(p, n) { //Return an object indicating the current Pairs for the pair object provided\r\n\t\tlet plural = \" is\";\r\n\t\tif(n > 1) {plural = \"s are\"}\r\n\t\tlet txt = \"Currently \" + n + \" definition plate\" + plural + \" paired to this result plate:\\n\";\r\n\t\tlet broken = 0;\r\n\t\tp.Table.forEach(function(t, i) {\r\n\t\t\tif(i > 0) {txt += \"\\n\"}\r\n\t\t\ttxt += \"- Range: \" + t.RangeName + \"; Plate: \" + t.Name + \" (#\" + (t.Index + 1) + \")\";\r\n\t\t\tif(t.Broken) {\r\n\t\t\t\tbroken++;\r\n\t\t\t\ttxt += \" *Link Broken!*\";\r\n\t\t\t}\r\n\t\t});\r\n\t\tlet html = \"<span class=\\\"\";\r\n\t\tif(broken > 0) { //At least one definition is broken\r\n\t\t\thtml += \"Error\\\" style=\\\"font-size: 0.8em\\\" title=\\\"\" + txt + \"\\\">Pair broken (\" + broken + \"/\" + n + \")</span>&nbsp;\";\r\n\t\t\treturn {State: \"broken\", Txt: txt, Html: html, Length: n}\r\n\t\t}\r\n\t\telse { //All is fine\r\n\t\t\thtml += \"Success\\\" style=\\\"font-size: 0.8em\\\" title=\\\"\" + txt + \"\\\">Paired (\" + n + \")</span>&nbsp;\";\r\n\t\t\treturn {State: \"paired\", Txt: txt, Html: html, Length: n}\r\n\t\t}\r\n\t}\r\n\tstatic hasItem(pair, I) { //For the pair passed, checked if the item defined in the object is defined and return the index if yes\r\n\t\treturn pair.Table.findIndex(function(t) {\r\n\t\t\treturn(t.RangeName == I.RangeName);\r\n\t\t});\r\n\t}\r\n\t//Methods\r\n\tregister(I) { //Register the item provided\r\n\t\tlet previous = Pair.hasItem(this, I);\r\n\t\tif(previous > -1) { //This definition already has an item defined, update it\r\n\t\t\tlet elt = this.Table[previous];\r\n\t\t\telt.Index = I.DefPlateIndex;\r\n\t\t\telt.Name = I.DefPlateName;\r\n\t\t\telt.Broken = false;\r\n\t\t}\r\n\t\telse { //Nothing defined for this definition, define it\r\n\t\t\tthis.Table.push({ //Push a new element for this definition in the table\r\n\t\t\t\tRangeName: I.RangeName,\r\n\t\t\t\tIndex: I.DefPlateIndex,\r\n\t\t\t\tName: I.DefPlateName,\r\n\t\t\t\tBroken: false,\r\n\t\t\t});\r\n\t\t}\r\n\t\treturn this;\r\n\t}\r\n\tremove(I) { //Remove the elt matching the definition provided for this pair\r\n\t\tlet index = Pair.hasItem(this, I);\r\n\t\tif(index > -1) { //If it exists...\r\n\t\t\tthis.Table.splice(index, 1); //...Remove the element\r\n\t\t}\r\n\t\treturn this;\r\n\t}\r\n\tstate() { //Return the state of the Pair as an object containing overall status and text/html strings of the pair content\r\n\t\tlet n = this.Table.length;\r\n\t\tif(n == 0) {return Pair.unpaired()}\r\n\t\telse {return Pair.paired(this, n)}\r\n\t}\r\n\tupdate(I) { //Check that all the definitions and plate listed in this object still exist and match the definition. Update when needed and report the current state\r\n\t\tlet n = this.Table.length;\r\n\t\tif(n == 0) {return Pair.unpaired()}\r\n\t\tlet validArray = []; //An array to push the definitions still existing\r\n\t\tthis.Table.forEach(function(t, i) { //Loop the paired definitions\r\n\t\t\tlet range = Editor.Tables.Areas.Array.find(function(a) {return a.Name == t.RangeName});\r\n\t\t\tif(range !== undefined) { //This range still exist\r\n\t\t\t\tlet def = range.Definition;\r\n\t\t\t\tif(def !== undefined) { //If the definition still exists, try to salvage the plates\r\n\t\t\t\t\tif(def.PlateIndex.getValue() == t.Index && def.PlateIndex.Selected == t.Name) { //This is the expected plate\r\n\t\t\t\t\t\tt.Broken = false;\r\n\t\t\t\t\t\tvalidArray.push(t); //Push the valid pair\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse { //This is not the expected plate\r\n\t\t\t\t\t\tif(def.PlateIndex.List[t.Index] == t.Name) { //The plate exist where expected in the definition, keep it and report as broken\r\n\t\t\t\t\t\t\tif(I === undefined || I.All == false) { //Broken state should not be triggered when updating all pairs following edition of the definitions\r\n\t\t\t\t\t\t\t\tt.Broken = true;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tvalidArray.push(t); //Push the valid pair\r\n\t\t\t\t\t\t} \r\n\t\t\t\t\t}\r\n\t\t\t\t} //All other cases means the definition has changed and we should delete the entry\r\n\t\t\t} //If the range doesn't exist, the validArray will be empty\r\n\t\t});\r\n\t\tthis.Table = validArray; //Update the array\r\n\t\tn = validArray.length;\r\n\t\tif(n == 0) {return Pair.unpaired()} //Report the status\r\n\t\telse {return Pair.paired(this, n)}\r\n\t}\r\n\tsetDefPlate() { //Set the value of the PlateSelect for all the paired definition to their paired values\r\n\t\tthis.Table.forEach(function(t) {\r\n\t\t\tlet range = Editor.Tables.Areas.Array.find(function(a) {return a.Name == t.RangeName});\r\n\t\t\tlet def = range.Definition;\r\n\t\t\tif(def !== undefined) {def.PlateIndex.setValue(t.Index)} //If the definition exist, set the plate\r\n\t\t\tt.Broken = false;\r\n\t\t});\r\n\t\treturn this;\r\n\t}\r\n\tgetDefPlate(sourceArray) { //Return the paired values stored for each definition\r\n\t\tlet O = []; //Output array\r\n\t\tsourceArray.forEach(function(r, i) { //For each range in the source array\r\n\t\t\tlet pair = this.Table.find(function(t) {return r.Name == t.RangeName});\r\n\t\t\tif(pair !== undefined) {O.push({RangeIndex: i, DefPlateIndex: pair.Index})} //If the definition exist, add it to the output\r\n\t\t}, this);\r\n\t\treturn O;\r\n\t}\r\n\trename(oldName, newName) { //Rename the definition with oldName to newName\r\n\t\tthis.Table.forEach(function(t) { //For each element in Table\r\n\t\t\tif(t.RangeName == oldName) {t.RangeName = newName} //Rename when needed\r\n\t\t});\r\n\t\treturn this;\r\n\t}\r\n}","//***********************************************************************\r\n//PAIRING Object - To handle data pairing between results and definitions\r\n//***********************************************************************\r\nclass Pairing {\r\n\tconstructor(r) {\r\n\t\tthis.Result = r;\r\n\t\tthis.Pairs = Array(r.PlatesID.length); //An array of pair object. Each item corresponds to the pairing data for the plate at the same index in the PlatesID array\r\n\t\t//this.Mode = undefined;\r\n\t\treturn this;\r\n\t}\r\n\t//Static Methods\r\n\tstatic form(results, ranges) { //Open a form to manipulate data pairing\r\n\t\tlet id = \"Form_Pairing\";\r\n\t\tlet Anchors = {\r\n\t\t\tDef: id + \"_Def\",\r\n\t\t\tResult: id + \"_Res\",\r\n\t\t\tAuto: id + \"_Auto\",\r\n\t\t\tPreview: id + \"_Preview\",\r\n\t\t}\r\n\t\tlet action = function(r) {\r\n\t\t\tPairing.preview(Tables, Anchors.Preview); //Build the preview of pairing\r\n\t\t}\r\n\t\tlet Tables = {\r\n\t\t\tRanges: new RespTable({ID: Anchors.Def, Array: ranges, Fields: [\"Name\", \"DefInfo\"], Headers: [\"Range\", \"Properties\"], NoControls: true}),\r\n\t\t\tResults: new RespTable({ID: Anchors.Result, Array: results, Fields: [\"Name\", \"Plate Count\"], NoControls: true,\r\n\t\t\t\tonSelect: function(newSelect) {action(newSelect[0])}\r\n\t\t\t}),\r\n\t\t}\r\n\t\tForm.open({\r\n\t\t\tID: id,\r\n\t\t\tHTML:\r\n\t\t\t\t\"<fieldset style=\\\"width: 350px; float: left; overflow: auto\\\" title=\\\"Select a result file to display the corresponding pairing table below\\\">\" +\r\n\t\t\t\t\t\"<legend>Results available</legend><div id=\\\"\" + Anchors.Result + \"\\\"></div></fieldset>\" +\r\n\t\t\t\t\"<fieldset style=\\\"width: 350px; float: left; overflow: auto\\\">\" +\r\n\t\t\t\t\t\"<legend>Definitions available</legend><div id=\\\"\" + Anchors.Def + \"\\\"></div></fieldset>\" +\r\n\t\t\t\t\"<fieldset style=\\\"width: 500px; clear: both; overflow: auto; float: left\\\">\" +\r\n\t\t\t\t\t\"<legend>Pairing Table</legend><div id=\\\"\" + Anchors.Preview + \"\\\" style=\\\"max-height: 300px; overflow: auto;\\\"></div></fieldset>\" +\r\n\t\t\t\t\"<fieldset style=\\\"width: 200px; float: left\\\">\" +\r\n\t\t\t\t\t\"<legend>Auto-pairing</legend><div id=\\\"\" + Anchors.Auto + \"\\\"></div></fieldset>\",\r\n\t\t\tTitle: \"Data pairing\",\r\n\t\t\tSize: 800,\r\n\t\t\tButtons: [\r\n\t\t\t\t{Label: \"Reset\", Icon: {Type: \"Reset\", Space: true, Color: \"Red\"}, Click: function() {\r\n\t\t\t\t\tlet r = Tables.Results.Selected[0]; //The selected result file\r\n\t\t\t\t\tr.Pairing = new Pairing(r); //Reset the pairing object\r\n\t\t\t\t\tPairing.preview(Tables, Anchors.Preview); //Build the preview\r\n\t\t\t\t}, Title: \"Delete all pairing data for the selected result\"},\r\n\t\t\t\t{Label: \"Done\", Icon: {Type: \"Ok\", Space: true, Color: \"Green\"}, Click: function() { //Finished edited the pairing\r\n\t\t\t\t\tlet result = Tables.Results.Selected[0]; //The selected result object\r\n\t\t\t\t\tEditor.ResultManager.Results.update(); //Update the table to have the correct result file selected\r\n\t\t\t\t\tEditor.ResultManager.draw(result); //Redraw to set the linked plate and update the display\r\n\t\t\t\t\tForm.close(id);\r\n\t\t\t\t} }\r\n\t\t\t],\r\n\t\t\tonInit: function() {\r\n\t\t\t\tlet b = LinkCtrl.buttonBar([\r\n\t\t\t\t\t{Label: \"By plate name\", Click: function() {\r\n\t\t\t\t\t\tPairing.autoPairing(\"Name\", Tables);\r\n\t\t\t\t\t\tPairing.preview(Tables, Anchors.Preview); //Re-build the preview after auto-pairing\r\n\t\t\t\t\t}, Title: \"Click to automatically pair the plates of the selected result and definition, using their names\"},\r\n\t\t\t\t\t{Label: \"By plate index\", Click: function() {\r\n\t\t\t\t\t\tPairing.autoPairing(\"Index\", Tables);\r\n\t\t\t\t\t\tPairing.preview(Tables, Anchors.Preview); //Re-build the preview after auto-pairing\r\n\t\t\t\t\t}, Title: \"Click to automatically pair the plates of the selected result and definition, using their index\"},\r\n\t\t\t\t]);\r\n\t\t\t\tGetId(Anchors.Auto).insertAdjacentElement(\"beforeend\", b);\r\n\t\t\t\tObject.values(Tables).forEach(function(t) {t.init()}); //Init the tables\r\n\t\t\t\tPairing.preview(Tables, Anchors.Preview); //Build the pairing preview for the selected elements on opening of the form \r\n\t\t\t},\r\n\t\t});\r\n\t}\r\n\tstatic preview(Tables, target) { //Build the html preview of the items paired and display it in the element with ID target\r\n\t\tlet r = Tables.Results.Selected[0]; //The selected result file\r\n\t\tlet html = \"\";\r\n\t\tlet b = LinkCtrl.button({Label: \"\", Icon: {Type: \"Edit\"}, Title: \"Click here to edit the pairing for this plate\"});\r\n\t\tif(r.Pairing === undefined) {r.Pairing = new Pairing(r)}\r\n\t\thtml = \"<table class=\\\"Table PreviewTable\\\"><tr><th>Result Plate</th><th>Status</th></tr>\";\r\n\t\tr.PlatesID.forEach(function(p, i) {\r\n\t\t\thtml += \"<tr><td>\" + p + \"</td><td>\";\r\n\t\t\tlet pair = r.Pairing.Pairs[i];\r\n\t\t\tif(pair !== undefined) {\r\n\t\t\t\tif(pair.state !== undefined) {html += pair.state().Html}\r\n\t\t\t\t//\r\n\t\t\t\t//\r\n\t\t\t\telse {html += pair} //We assume in this case that a text is present, yet to be decided\r\n\t\t\t\t//\r\n\t\t\t\t//\r\n\t\t\t}\r\n\t\t\telse {html += Pair.unpaired().Html}\r\n\t\t\thtml += \"</td><td class=\\\"Pairing_Edit_TR\\\">\" + b.outerHTML + \"</td></tr>\";\r\n\t\t});\r\n\t\thtml += \"</table>\";\r\n\t\tlet t = GetId(target);\r\n\t\tt.innerHTML = html;\r\n\t\tlet collection = t.getElementsByClassName(\"Pairing_Edit_TR\");\r\n\t\tlet l = collection.length;\r\n\t\tfor(let i=0; i<l; i++) {\r\n\t\t\tcollection[i].children[0].addEventListener(\"click\", function(e) {\r\n\t\t\t\tPairing.editPair(r, /*d,*/ i, Tables, target);\r\n\t\t\t});\r\n\t\t}\r\n\t}\r\n\tstatic editPair(r, /*d,*/ i, Tables, target) { //Open a form for edition of the pair for result r, plate index i, definition d. On edit, update the preview using Tables and target\r\n\t\tlet d = Tables.Ranges.Selected[0].Definition; //The selected definition\r\n\t\tlet id = \"Form_Pairing_Inner\";\r\n\t\tlet Anchors = {\r\n\t\t\tOptions: id + \"_Options\",\r\n\t\t}\r\n\t\tlet ctrl = { //LinkCtrl objects in the form\r\n\t\t\tPlates: LinkCtrl.new(\"Select\", {ID: Anchors.Options, Default: 0, List: d.PlatesID, NavBar: true, Lookup: true}),\r\n\t\t};\r\n\t\tForm.open({\r\n\t\t\tID: id,\r\n\t\t\tHTML: \"<fieldset><legend>Plates available</legend><div id=\\\"\" + Anchors.Options + \"\\\"></div></fieldset>\",\r\n\t\t\tTitle: \"Edit pairing\",\r\n\t\t\tButtons: [\r\n\t\t\t\t{Label: \"Ok\", Icon: {Type: \"Ok\", Space: true, Color: \"Green\"}, Click: function() {\r\n\t\t\t\t\tif(r.Pairing.Pairs[i] === undefined) {r.Pairing.Pairs[i] = new Pair()}\r\n\t\t\t\t\tr.Pairing.Pairs[i].register({RangeName: d.Area.Name, DefPlateIndex: ctrl.Plates.getValue(), DefPlateName: ctrl.Plates.Selected});\r\n\t\t\t\t\tPairing.preview(Tables, target);\r\n\t\t\t\t\tForm.close(id);\r\n\t\t\t\t}.bind(this)},\r\n\t\t\t\t{Label: \"Cancel\", Icon: {Type: \"Cancel\", Space: true, Color: \"Red\"}, Click: function() {Form.close(id)}}\r\n\t\t\t],\r\n\t\t\tonInit: function() {\r\n\t\t\t\tObject.values(ctrl).forEach(function(c) {c.init()}); //Init the controls\r\n\t\t\t},\r\n\t\t});\r\n\t}\r\n\tstatic setLinkedPlate(result, plateIndex, target) { //For the result object passed, set the correct plates for the linked definition and show the pairing data in the provided target\r\n\t\tif(result.Pairing === undefined) { //No pairing set\r\n\t\t\tthis.status(target, Pair.unpaired());\r\n\t\t} \r\n\t\telse { //Pairing available\r\n\t\t\tlet pair = result.Pairing.Pairs[plateIndex];\r\n\t\t\tif(pair === undefined || pair.setDefPlate === undefined) {this.status(target, Pair.unpaired())} //Pairing object but empty pair at this location\r\n\t\t\telse { //Pair object exist, get its status\r\n\t\t\t\tlet O = pair.setDefPlate().state();\r\n\t\t\t\tthis.status(target, O);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tstatic status(target, I) { //Update the html output in target to match the state provided. Use the options provided when needed to build the message\r\n\t\tlet ctrl = LinkCtrl.button({ //The button to edit the pairing\r\n\t\t\tLabel: \"\", Icon: {Type: \"Setting\"}, Title: \"Click here to edit the pairing setting\", Click: function() {Editor.pairing()}\r\n\t\t});\r\n\t\tlet html = \"\";\r\n\t\tswitch(I.State) {\r\n\t\t\tcase \"unpaired\":\r\n\t\t\t\thtml = I.Html;\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"paired\":\r\n\t\t\t\thtml = I.Html;\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"broken\":\r\n\t\t\t\tctrl = LinkCtrl.button({ //The button to restore the pairing will replace the button to access the settings\r\n\t\t\t\t\tLabel: \"\", Icon: {Type: \"Reset\"}, Click: function() {\r\n\t\t\t\t\t\tlet result = Editor.Tables.Results.Selected[0]; //The selected result\r\n\t\t\t\t\t\tlet plateIndex = Editor.ResultManager.PlateSelect.getValue(); //The selected result plate (index)\r\n\t\t\t\t\t\tPairing.setLinkedPlate(result, plateIndex, target); //Set the correct plates. This will call the status() method as well and update the display\r\n\t\t\t\t\t}, Title: \"Click here to set the definition plates as defined in the pairing setting\"\r\n\t\t\t\t});\r\n\t\t\t\thtml = I.Html;\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\t\tGetId(target).innerHTML = html; //Update the message\r\n\t\tGetId(target).insertAdjacentElement(\"beforeend\", ctrl); //Insert the button\r\n\t}\r\n\tstatic update(target) { //Check and update the selected result to reflect current Pairing status\r\n\t\tlet r = Editor.ResultManager.Results.Selected[0]; //The selected result\r\n\t\tif(r === undefined) {return} //Nothing to do if no results are selected\r\n\t\tlet index = Editor.ResultManager.PlateSelect.getValue(); //The selected plate\r\n\t\tif(r.Pairing !== undefined && r.Pairing.Pairs[index] !== undefined && r.Pairing.Pairs[index].update !== undefined) {\r\n\t\t\tlet O = r.Pairing.Pairs[index].update();\r\n\t\t\tPairing.status(target, O);\r\n\t\t}\r\n\t}\r\n\tstatic updateAll(target) { //Update all the pairing data for all the result file. This is typically necessary when definitions are edited/deleted\r\n\t\tEditor.ResultManager.Results.Array.forEach(function(r) { //For each result file\r\n\t\t\tif(r.Pairing !== undefined) { //If the result has a pairing defined\r\n\t\t\t\tlet index = -1; //We use this to track the selected plate. Default is a faulty value for all plates\r\n\t\t\t\tif(r.Selected) { //If this result file is selected, get the selected plate index to update the status of the pairing\r\n\t\t\t\t\tindex = Editor.ResultManager.PlateSelect.getValue(); //The selected plate\r\n\t\t\t\t}\r\n\t\t\t\tr.Pairing.Pairs.forEach(function(p, i) { //For each pair\r\n\t\t\t\t\tif(p !== undefined && p.update !== undefined) { //If this item is a pair object, update it\r\n\t\t\t\t\t\tlet O = p.update({All: true});\r\n\t\t\t\t\t\tif(i == index) {Pairing.status(target, O)} //Update the display for the element currently visible\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t}, this);\r\n\t}\r\n\tstatic resize(result) {\r\n\t\tif(result.Pairing === undefined) {return} //Nothing to do in that case\r\n\t\tlet n = result.PlatesID.length;\r\n\t\tlet l = result.Pairing.Pairs.length;\r\n\t\tif(l == n) {return} //Same size, nothing to change\r\n\t\tif(l < n) { //Add missing elements\r\n\t\t\twhile(l < n) {\r\n\t\t\t\tresult.Pairing.Pairs.push(new Pair());\r\n\t\t\t\tl++;\r\n\t\t\t}\r\n\t\t}\r\n\t\telse { //Too much elements, need to remove the excess\r\n\t\t\tresult.Pairing.Pairs.splice(n, l-n);\r\n\t\t}\r\n\t}\r\n\tstatic rename(oldName, newName) { //Travel the pair objects and rename the definition using old/new name parameters provided\r\n\t\tEditor.ResultManager.Results.Array.forEach(function(r) { //For every result available\r\n\t\t\tif(r.Pairing !== undefined) { //If a pairing object exist\r\n\t\t\t\tr.Pairing.Pairs.forEach(function(p) {\r\n\t\t\t\t\tif(p !== undefined && p.rename !== undefined) { //If a pair object is defined here, do the rename\r\n\t\t\t\t\t\tp.rename(oldName, newName);\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\tstatic autoPairing(type, Tables) {\r\n\t\tlet r = Tables.Results.Selected[0]; //Selected result\r\n\t\tlet d = Tables.Ranges.Selected[0].Definition; //Selected definition\r\n\t\tlet count = 0; //How many pairs are found\r\n\t\tlet defID = d.PlatesID;\r\n\t\tif(type == \"Name\") { //Pair by name\r\n\t\t\tr.PlatesID.forEach(function(p, i) { //For each plate in the PlatesID array of the result object, search for a match in the Definition array\r\n\t\t\t\tlet val = defID.findIndex(function(e) {return e == p}); //Search for a match\r\n\t\t\t\tif(val > -1) { //Pair if a match is found\r\n\t\t\t\t\tif(r.Pairing.Pairs[i] === undefined) {r.Pairing.Pairs[i] = new Pair()} //Create a new pair when needed\r\n\t\t\t\t\tr.Pairing.Pairs[i].register({RangeName: d.Area.Name, DefPlateIndex: val, DefPlateName: defID[val]});\r\n\t\t\t\t\tcount++;\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}\r\n\t\telse { //Pair by index\r\n\t\t\tr.PlatesID.forEach(function(p, i) { //For each plate in the PlatesID array of the result object, match with the equivalent index in the Definition array, if it exists\r\n\t\t\t\tlet val = defID[i];\r\n\t\t\t\tif(val !== undefined) { //Pair if a match is found\r\n\t\t\t\t\tif(r.Pairing.Pairs[i] === undefined) {r.Pairing.Pairs[i] = new Pair()} //Create a new pair when needed\r\n\t\t\t\t\tr.Pairing.Pairs[i].register({RangeName: d.Area.Name, DefPlateIndex: i, DefPlateName: val});\r\n\t\t\t\t\tcount++;\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}\r\n\t\tif(count == 0) {alert(\"no matches found!\")}\r\n\t\telse {\r\n\t\t\tlet plural = \"\";\r\n\t\t\tif(count > 1) {plural = \"es\"}\r\n\t\t\talert(count + \" match\" + plural + \" found\");\r\n\t\t}\r\n\t}\r\n\t//Methods\r\n\t\r\n}","//********************************************************************************\r\n// REPORTER object - Allow construction of specific report pages for data analysis\r\n//********************************************************************************\r\nclass Reporter {\r\n\tconstructor() {return this}\r\n\t//Static Methods\r\n\tstatic htmlHeader(title) {\r\n\t\tlet h = \"<!DOCTYPE HTML>\\n\";\r\n\t\th += \"<html>\\n\";\r\n\t\th += \"<head>\\n\";\r\n\t\th += \"\\t<meta http-equiv=\\\"content-type\\\" content=\\\"text/html; charset=UTF-8\\\">\\n\";\r\n\t\th += \"\\t<title>\" + title + \"</title>\\n\";\r\n\t\th += \"\\t<link href=\\\"dist/ui-styles.css\\\" rel=\\\"stylesheet\\\" type=\\\"text/css\\\">\\n\";\r\n\t\th += \"\\t<link href=\\\"dist/analyzer-styles.css\\\" rel=\\\"stylesheet\\\" type=\\\"text/css\\\">\\n\";\r\n\t\th += \"\\t<link href=\\\"dist/shared-styles.css\\\" rel=\\\"stylesheet\\\" type=\\\"text/css\\\">\\n\";\r\n\t\th += \"\\t<script type=\\\"text/javascript\\\" src=\\\"dist/ui.min.js\\\"></script>\\n\";\r\n\t\th += \"\\t<script type=\\\"text/javascript\\\" src=\\\"dist/shared.min.js\\\"></script>\\n\";\r\n\t\th += \"\\t<script type=\\\"text/javascript\\\" src=\\\"dist/analyzer.min.js\\\"></script>\\n\";\r\n\t\th += \"\\t<script type=\\\"text/javascript\\\" src=\\\"dependencies/jszip.min.js\\\"></script>\\n\";\r\n\t\treturn h;\r\n\t}\r\n\tstatic header(I) { //Prepare the header for the html report page\r\n\t\tlet title = (I.Title || \"Report\");\r\n\t\tlet html = this.htmlHeader(I.Method);\r\n\t\thtml +=\"\\t<script type=\\\"text/javascript\\\">window.onload = function() {Analyzer.init({Method: \\\"\" + I.Method + \"\\\", Title: \\\"\" + title + \"\\\"})}</script>\\n\"; //Script to init the Analyzer on loading the page\r\n\t\thtml += \"</head>\\n\";\r\n\t\thtml += \"<body style=\\\"font-family: arial; font-size: 16px\\\">\\n\";\r\n\t\thtml += \"<div id=\\\"Header\\\">\\n\"; //Header\r\n\t\thtml += \"\\t<p><b>\" + title + \"</b></p>\\n\";\r\n\t\thtml += \"</div>\\n\";\r\n\t\thtml += \"<div id=\\\"Main\\\">\\n\";  //Opening of the main report div\r\n\t\treturn html;\r\n\t}\r\n\tstatic footer() { //Prepare the footer for the html report\r\n\t\tlet f = \"</div>\\n\"; //Closure of Main report div\r\n\t\tf += \"<div id=\\\"Footer\\\">\\n\"; //Footer\r\n\t\tf += \"\\t<p>Generated&nbsp;<script>document.write(Date())</script>.</p>\\n\";\r\n\t\tf += \"</div>\\n\";\r\n\t\tf += \"</body>\\n\";\r\n\t\tf += \"</html>\\n\";\r\n\t\treturn f;\r\n\t}\r\n\tstatic openPage(html) { //Open a page with html as content\r\n\t\tlet win = window.open(); //Show report\r\n\t\twin.document.write(html); //Write the html content\r\n\t\twin.document.close();\r\n\t\twin.focus(); //Focus on the newly opened page\r\n\t}\r\n\tstatic openReport(body, I) { //Open the report as a new HTML page\r\n\t\tlet report = this.header(I) + body + this.footer(); //Assemble the report\r\n\t\tthis.openPage(report);\r\n\t}\r\n\tstatic printable(html) { //Open a blank page containing only the html provided, that can be used for copy-pasting or printing operations\r\n\t\tlet h = this.htmlHeader(\"Printable\");\r\n\t\th += \"</head>\\n\";\r\n\t\th += \"<body style=\\\"font-family: arial; font-size: 16px\\\">\\n\";\r\n\t\tthis.openPage(h + html + \"\\n</body></html>\");\r\n\t}\r\n\tstatic combination(o, I) { //Compute the combinations of unique elements by checking concentrations and tags overlap\r\n\t\tlet out = {};\r\n\t\tObject.values(o).forEach(function(array, k) { //The object contains different categories. Each will be treated separately and the results returned as arrays in their initial categories\r\n\t\t\tif(Array.isArray(array)) { //Values that are not arrays are ignored\r\n\t\t\t\tlet key = Object.keys(o)[k]; //The key corresponding to the value\r\n//************************************************\r\n//Not sure at this point about the order, so doing\r\n//like this makes it more flexible for the future\r\n\t\t\t\tlet updated = array;\r\n\t\t\t\tif(I.Conc) {updated = this.combineConc(updated)}\r\n\t\t\t\tif(I.Tags) {updated = this.combineTags(updated)}\r\n//************************************************\r\n\t\t\t\tout[key] = updated;\r\n\t\t\t}\r\n\t\t}, this);\r\n\t\treturn out;\r\n\t}\r\n\tstatic combineConc(array) { //For the array of objects supplied, use the concentrations data to divide the original arrays into individual arrays of aggregated objects with their own tags\r\n\t\tlet flatConcNames = [];\r\n\t\tlet flatConcTags = [];\r\n\t\tarray.forEach(function(a) { //Loop the array of objects provided. Each element is an object with a name, as well as Tags/Concs properties defined as arrays\r\n\t\t\ta.Conc.forEach(function(c, i) { //Loop the concentrations\r\n\t\t\t\tlet name = a.Name;\r\n\t\t\t\tif(c.length > 0) {name += \" \" + c}\r\n\t\t\t\tlet index = flatConcNames.indexOf(name);\r\n\t\t\t\tif(index == -1) {flatConcNames.push(name); flatConcTags.push([a.Tags[i]])} //Does not exist, create it\r\n\t\t\t\telse {flatConcTags[index].push(a.Tags[i])} //Update existing entry\r\n\t\t\t});\r\n\t\t});\r\n\t\tlet output = [];\r\n\t\tflatConcNames.forEach(function(n, i) {\r\n\t\t\toutput.push({Name: n, Tags: flatConcTags[i]});\r\n\t\t});\r\n\t\treturn output;\r\n\t}\r\n\tstatic combineTags(array) { //For the array of objects supplied, use the tags data to divide the original arrays into individual arrays of aggregated objects with their own tags\r\n\t\tlet allNames = [];\r\n\t\tlet uniqueIndex = [];\r\n\t\tarray.forEach(function(a) { //In the first pass, travel each area tags array and collect all names appearing for each index\r\n\t\t\ta.Tags.forEach(function(t) { //Go throught the tags\r\n\t\t\t\tlet index = uniqueIndex.indexOf(t);\r\n\t\t\t\tif(index == -1) { //New entry found\r\n\t\t\t\t\tuniqueIndex.push(t);\r\n\t\t\t\t\tallNames.push([a.Name]);\r\n\t\t\t\t}\r\n\t\t\t\telse {allNames[index].push(a.Name)} //Update existing entry\r\n\t\t\t});\r\n\t\t});\r\n\t\tlet output = [];\r\n\t\tlet uniqueNames = [];\r\n\t\tallNames.forEach(function(n, i) { //In the second pass, travel the name array and accumulate unique names with their tags\r\n\t\t\tlet name = n.sort().join(\" / \"); //Sort the name array so that we can compare always the same final name\r\n\t\t\tlet index = uniqueNames.indexOf(name);\r\n\t\t\tif(index == -1) { //New entry found\r\n\t\t\t\tuniqueNames.push(name);\r\n\t\t\t\toutput.push({Name: name, Tags: [uniqueIndex[i]]});\r\n\t\t\t}\r\n\t\t\telse {output[index].Tags.push(uniqueIndex[i])} //Update existing entry\r\n\t\t});\r\n\t\treturn output;\r\n\t}\r\n\tstatic zFactor(controls/*, results*/) { //Compute z-score for the result file passed, using the controls provided\r\n\t\twindow.zFactor = {Controls: this.combination(controls, {Conc: true, Tags: true})/*, Results: results*/}\r\n\t\tthis.openReport(\"\", {Title: \"Control Report\", /*FileName: result.Name,*/ Method: \"zFactor\"});\r\n\t}\r\n\tstatic aggregate(areas/*, results*/) { //Compute stats for the result file passed, using the areas provided\r\n\t\tareas.R.forEach(function(range) {\r\n\t\t\tareas.A = areas.A.concat(range.Values); //Concat all individual rangeIndex to the areas\r\n\t\t});\r\n\t\twindow.Aggregate = {Combinations: this.combination({A: areas.A}, {Conc: true, Tags: true})/*, Results: results*/, Ranges: areas.R}\r\n\t\tthis.openReport(\"\", {Title: \"Column Report\", /*FileName: result.Name,*/ Method: \"Aggregate\"});\r\n\t}\r\n\tstatic grouped(areas, conc/*, results*/) { //Compute stats for the result file passed, using the areas provided and organizing data as two-entry tables\r\n\t\twindow.Grouped = {Areas: areas.A, Conc: conc/*, Results: results*/, Ranges: areas.R, Definitions: areas.D}\r\n\t\tthis.openReport(\"\", {Title: \"Grouped Report\", /*FileName: result.Name,*/ Method: \"Grouped\"});\r\n\t}\r\n}","//************************************\r\n// UNIT object - Class to handle units\r\n//************************************\r\nclass Unit {\r\n\tconstructor() {}\r\n\t//Static Methods\r\n\tstatic units() { //Returns an array with all the available unit objects\r\n\t\treturn [\r\n\t\t\t{Name: \"M\"},\r\n\t\t\t{Name: \"mM\", Root: \"M\", Shift: -3},\r\n\t\t\t{Name: \"µM\", Root: \"M\", Shift: -6},\r\n\t\t\t{Name: \"nM\", Root: \"M\", Shift: -9},\r\n\t\t\t{Name: \"pM\", Root: \"M\", Shift: -12},\r\n\t\t\t{Name: \"g/L\"},\r\n\t\t\t{Name: \"g/mL\"},\r\n\t\t\t{Name: \"mg/mL\", Root: \"g/mL\", Shift: -3},\r\n\t\t\t{Name: \"µg/mL\", Root: \"g/mL\", Shift: -6},\r\n\t\t\t{Name: \"ng/mL\", Root: \"g/mL\", Shift: -9},\r\n\t\t\t{Name: \"pg/mL\", Root: \"g/mL\", Shift: -12},\r\n\t\t\t{Name: \"%\"},\r\n\t\t\t{Name: \"u/mL\"},\r\n\t\t\t{Name: \"ku/mL\", Root: \"u/mL\", Shift: 3},\r\n\t\t\t{Name: \"Mu/mL\", Root: \"u/mL\", Shift: 6},\r\n\t\t\t{Name: \"MOI\", Invert: true},\r\n\t\t\t{Name: \"×\"},\r\n\t\t\t{Name: \"a.u\"},\r\n\t\t];\r\n\t}\r\n\tstatic list(I) { //Returns a list of all the available units\r\n\t\tlet l = this.units();\r\n\t\tif(I && I.Name) {return l.map(function(u) {return u.Name})} //Only the names\r\n\t\treturn l;\r\n\t}\r\n\tstatic shiftForUnit(unit) { //For the unit provided, return the shift needed to reach the mother unit, in log scale\r\n\t\tlet l = this.units();\r\n\t\tlet here = l.find(function(u) {return u.Name == unit});\r\n\t\treturn (here.Shift || 0);\r\n\t}\r\n\tstatic rootForUnit(unit) { //For the unit provided, return the shift needed to reach the mother unit, in log scale\r\n\t\tlet l = this.units();\r\n\t\tlet here = l.find(function(u) {return u.Name == unit});\r\n\t\treturn (here.Root || unit);\r\n\t}\r\n}","function GetId(id) {return document.getElementById(id)}","//*******************************************************************************\r\n// INPUTOBJECT_FILE - Object for input file and tracking of their parsing options\r\n//*******************************************************************************\r\nclass InputObject_File extends InputObject {\r\n\tconstructor(file) {\r\n\t\tsuper();\r\n\t\tthis.RawData = file; //Raw data for the input: original file object from the browser\r\n\t\tthis.Source = \"File\";\r\n\t\tthis.Type = file.type;\r\n\t\tthis.Name = file.name;\r\n\t\tthis.Size = file.size;\r\n\t\tthis.Format = file.name.substring(file.name.lastIndexOf(\".\")); //Get the extension for the file\r\n\t\tif(this.Format == \".xlsx\") {this.Controls.Parser.Value = 1} //Set default value for files recognized as excel\r\n\t\tif(this.Format == \".xls\") {this.Controls.Parser.Value = 2}\r\n\t\tthis.InputParser = InputParser.new({Type: this.Controls.Parser.Selected, Data: this.RawData, Name: this.Name}); //Parser Object and its configuration\r\n\t\treturn this;\r\n\t}\r\n}","//**********************************************************************************************\r\n// INPUTOBJECT_MANUAL - Object from manual input of data, with tracking of their parsing options\r\n//**********************************************************************************************\r\nclass InputObject_Manual extends InputObject {\r\n\tconstructor(data) {\r\n\t\tsuper();\r\n\t\tvar d = data.Data;\r\n\t\tif(d === undefined) {console.warn(\"No data transfered to InputObject manual. Aborted\"); return this}\r\n\t\tthis.RawData = d; //Raw data for the input: original data submitted by the user\r\n\t\tthis.Source = \"Manual\";\r\n\t\tthis.Type = \"txt/plain\"; //Mimickry\r\n\t\tthis.Size = d.length;\r\n\t\tif(data.Name && data.Name.length > 0) { //Use provided name\r\n\t\t\tthis.Name = data.Name;\r\n\t\t}\r\n\t\telse { //Create a name based on the first characters within the input\r\n\t\t\tthis.Name = d.substring(0, 7);\r\n\t\t\tif(this.Size > 7) {this.Name += \"[...]\"}\r\n\t\t}\r\n\t\tthis.Format = \"-\"; //No extension because no file, so just a filler is used\r\n\t\tthis.Controls.Parser.List = [\"TXT/CSV\"]; //Excel not needed\r\n\t\tthis.InputParser = InputParser.new({Type: this.Controls.Parser.Selected, Data: this.RawData, Name: this.Name}); //Parser Object and its configuration\r\n\t\treturn this;\r\n\t}\r\n}","//**************************************************************\r\n// INPUTPARSER_PAPA - Object for parsing of data using papaParse\r\n//**************************************************************\r\nclass InputParser_Papa extends InputParser {\r\n\tconstructor(I) {\r\n\t\tsuper(I);\r\n\t\tthis.Type = \"Papa\";\r\n\t\tthis.Help = \"Parsing of text or csv files, based on the PapaParse library\";\r\n\t\tlet target = Form_Import.Anchors.ParserOptions; //Target ID for the options\r\n\t\tObject.assign(this.Options, {\r\n\t\t\tdelimiter: LinkCtrl.new(\"Text\", {\r\n\t\t\t\tID: target, Label: \"Delimiter\", Default: \"\", Preserve: true, /*NewLine: true,*/ Index: 5, Size: 5,\r\n\t\t\t\tChange: function() {this.parse()}.bind(this), Title: \"Delimiter used for parsing columns. Leave empty for auto-detection\",\r\n\t\t\t}),\r\n//*****************************************************\r\n//Not sure if it is useful because auto works just fine\r\n//*****************************************************\r\n\t\t\t/*newline: LinkCtrl.new(\"Text\", {\r\n\t\t\t\tID: target, Label: \"New line\", Default: \"\", Preserve: true, NewLine: true, Index: 6, Size: 5,\r\n\t\t\t\tChange: function() {this.parse()}.bind(this), Title: \"Character used as new line for parsing rows. Leave empty for auto-detection\",\r\n\t\t\t}),*/\r\n//*****************************************************\r\n\t\t});\r\n\t}\r\n\t//Methods\r\n\tinit() { //Display controls for available options\r\n\t\tObject.values(this.Options).forEach(function(o) {o.init()});\r\n\t\tlet tab = LinkCtrl.button({ID: \"insert-Tab\", Label: \"TAB\", Title: \"Click to insert a Tabulation\", Click: function() {this.Options.delimiter.setValue(\"\\t\").change()}.bind(this)});\r\n\t\tGetId(Form_Import.Anchors.ParserOptions).insertAdjacentElement(\"beforeend\", tab);\r\n\t\treturn this;\r\n\t}\r\n\tassignOptions(c) { //Assign the value of the options of the inputParser to the parsing config\r\n\t\tlet entries = Object.entries(this.Options).map(function(array) {return [array[0], array[1].getValue()]}); //Convert the LinkCtrl into their values\r\n\t\tObject.assign(c, Object.fromEntries(entries)); //Append the key/value pairs to Papa config\r\n\t\treturn c;\r\n\t}\r\n\tfirstParse(I) { //Parse the entire file to get nb of rows and columns available\r\n\t\tthis.TotalCols = 0; //Reset previous data\r\n\t\tthis.TotalRows = 0;\r\n\t\tlet PapaConfig = {\r\n\t\t\tworker: this.WebWorker, \r\n\t\t\theader: false,\r\n\t\t\tstep: function(R, parser) {\r\n\t\t\t\tparser.FirstParsed = false;\r\n\t\t\t\tlet l = R.data.length;\r\n\t\t\t\tif(l > this.TotalCols) {this.TotalCols = l}\r\n\t\t\t\tthis.TotalRows++;\r\n\t\t\t\tif(I && I.Step) {I.Step(R.data, this.TotalRows, parser)}\r\n\t\t\t}.bind(this),\r\n\t\t\tcomplete: function() { //After complete, parse again to get a preview\r\n\t\t\t\tthis.FirstParsed = true;\r\n\t\t\t\tthis.parse(I);\r\n\t\t\t}.bind(this),\r\n\t\t\terror: function(e) {\r\n\t\t\t\tthis.Error = true;\r\n\t\t\t\tthis.ErrorDetails = e;\r\n\t\t\t\tthis.parse(I); //We call the parse again so that the error message and status are reflected in the preview box and the input table\r\n\t\t\t\tif(I && I.Error) {I.Error(e)}\r\n\t\t\t}.bind(this),\r\n\t\t}\r\n\t\tPapa.parse(this.RawData, this.assignOptions(PapaConfig));\r\n\t}\r\n\tstream(f, complete, I) { //Stream the input and send the row to the function provided as argument\r\n\t\tlet o = this.parsingOptions();\r\n\t\tif(I && I.ApplyToHeader) {o.ApplyToHeader = true}\r\n\t\tlet PapaConfig = {\r\n\t\t\theader: false,\r\n\t\t\tworker: this.WebWorker,\r\n\t\t\tstep: function(R, parser) {\r\n\t\t\t\tparser.FirstParsed = this.FirstParsed;\r\n\t\t\t\tthis.processRow(R.data, parser, f, o);\r\n\t\t\t}.bind(this),\r\n\t\t\tcomplete: function() {\r\n\t\t\t\tif(complete) {complete(o.Selected, o)}\r\n\t\t\t},\r\n\t\t}\r\n\t\tPapa.parse(this.RawData, this.assignOptions(PapaConfig));\r\n\t}\r\n\t/*\r\n\tchunk(f, I) { //Chunk a piece of the input and apply the provided function on each chunk\r\n\t\tlet o = this.parsingOptions();\r\n\t\tif(I) {\r\n\t\t\tif(I.Start) {o.FirstRow += I.Start}\r\n\t\t\tlet rows = (I.Rows || 1000);\r\n\t\t}\r\n\t\tlet selected = -1; //Tracker for selected rows\r\n\t\tlet chunk = [];\r\n\t\tlet PapaConfig = {\r\n\t\t\theader: false,\r\n\t\t\tworker: this.WebWorker,\r\n\t\t\tstep: function(R, parser) {\r\n\t\t\t\tlet row = this.cleanRow(R.data, o);\r\n\t\t\t\tif(row) {\r\n\t\t\t\t\tif(selected >= rows) {parser.abort()}\r\n\t\t\t\t\tif(selected == -1) { //First selected row, exclude the header if present\r\n\t\t\t\t\t\tif(this.Options.NoHeaders.getValue()) {chunk.push(row); selected = 1}\r\n\t\t\t\t\t\telse {selected = 0}\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {chunk.push(row); selected++;}\r\n\t\t\t\t}\r\n\t\t\t\to.Index++;\r\n\t\t\t}.bind(this),\r\n\t\t\tcomplete: function() {f(chunk)},\r\n\t\t}\r\n\t\tPapa.parse(this.RawData, this.assignOptions(PapaConfig));\r\n\t}\r\n\t*/\r\n\t/*\r\n\tchunk(f, complete, I) { //Chunk a piece of the input and apply the provided function on each chunk\r\n\t\tPapa.LocalChunkSize = 500000; //500 kB\r\n\t\tvar r = this.Options.FirstRow.getValue() - 1; //Index of the first row\r\n\t\tvar c = this.Options.FirstCol.getValue() - 1; //Index of the first col\r\n\t\tvar i = 0; //Tracker for row index\r\n\t\tvar selected = 0;\r\n\t\tvar PapaConfig = {\r\n\t\t\theader: false,\r\n\t\t\tchunk: function(C, parser) {\r\n\t\t\t\tif(I && I.Pause) {parser.pause()} //Need pause/resume to ensure the function can run on each chunk one after the other\r\n\t\t\t\tvar clean_chunk = [];\r\n\t\t\t\tC.data.forEach(function(R) {\r\n\t\t\t\t\tvar row = this.cleanRow({Index: i, Data: R, FirstRow: r, FirstCol: c});\r\n\t\t\t\t\ti++;\r\n\t\t\t\t\tif(row) { //Exclude the header\r\n\t\t\t\t\t\tif(selected == 0) {selected++}\r\n\t\t\t\t\t\telse {clean_chunk.push(row)}\r\n\t\t\t\t\t}\r\n\t\t\t\t}, this);\r\n\t\t\t\tf(clean_chunk, parser);\r\n\t\t\t}.bind(this),\r\n\t\t\tcomplete: function() {\r\n\t\t\t\tif(complete) {complete()}\r\n\t\t\t},\r\n\t\t}\r\n\t\tif(I && I.Pause) {\r\n\t\t\tPapaConfig.worker = false; //Need this to access the pause/resume functions in the step\r\n\t\t}\r\n\t\telse {PapaConfig.worker = this.WebWorker}\r\n\t\tvar entries = Object.entries(this.Options).map(function(array) {return [array[0], array[1].getValue()]}); //Convert the LinkCtrl into their values\r\n\t\tObject.assign(PapaConfig, Object.fromEntries(entries)); //Append the key/value pairs to Papa config\r\n\t\tPapa.parse(this.RawData, PapaConfig);\r\n\t}\r\n\t*/\r\n}\r\n\r\n","//***********************************************************************\r\n// INPUTPARSER_XLS - A parser for xls files that fully supports streaming\r\n//***********************************************************************\r\nclass InputParser_XLS extends InputParser {\r\n\tconstructor(I) {\r\n\t\tsuper(I);\r\n\t\tthis.Type = \"XLS\";\r\n\t\tthis.Help = \"Parsing of .xls Excel files with streaming capabilities\";\r\n\t\tlet target = Form_Import.Anchors.ParserOptions; //Target ID for the options\r\n\t\tthis.Options = Object.assign(this.Options, { //These options require a new parsing to be performed\r\n\t\t\tSheet: LinkCtrl.new(\"Select\", {ID: target, Label: \"Sheet\", Default: 0, List: [], Preserve: true, NewLine: true, Index: 5, Change: function() {\r\n\t\t\t\tif(this.Worker) {this.Worker.terminate()}\r\n\t\t\t\tthis.FirstParsed = false; //Need to reevaluate available rows/cols\r\n\t\t\t\tthis.parse();\r\n\t\t\t}.bind(this), Title: \"The sheet to import\"}),\r\n\t\t});\r\n\t\tthis.Worker = undefined; //WebWorker used to process the file\r\n\t\tthis.SharedStrings = undefined;\r\n\t}\r\n\t//Static methods\r\n\tstatic getMeta(parser) { //A promise that fulfills after metaData are collected, or reject with the error\r\n\t\treturn new Promise(function(resolve, reject) {\r\n\t\t\tlet reader = new FileReader();\r\n\t\t\treader.onerror = function(e) { //Handle reading errors\r\n\t\t\t\treject(reader.error); //The function receives an event as argument but the error description is in the reader property\r\n\t\t\t}\r\n\t\t\treader.onload = function(e) { //After opening the file, process it\r\n\t\t\t\tlet ab = e.target.result; //ArrayBuffer\r\n\t\t\t\tlet dv = new DataView(e.target.result);\r\n\t\t\t\ttry {\r\n\t\t\t\t\tInputParser_XLS.getOffsets(parser, dv) //Metadata\r\n\t\t\t\t\tlet cursor = InputParser_XLS.getSheets(parser, ab, dv); //Sheets informations\r\n\t\t\t\t\tif(parser.BIFFversion == 6) {InputParser_XLS.getSharedStrings(parser, ab, dv, cursor)} //Sharedstring are only present for BIFF8\r\n\t\t\t\t}\r\n\t\t\t\tcatch(e) {reject(e); return}\r\n\t\t\t\tresolve();\r\n\t\t\t}\r\n\t\t\treader.readAsArrayBuffer(parser.RawData); //Start the file reading process\r\n\t\t});\r\n\t}\r\n\tstatic getOffsets(parser, dv) { //Recover meta data from the file and store them in the object property\r\n\t\tlet version = dv.getUint16(26, true); //Read the coumpound file version to know the sector size\r\n\t\tswitch(version) {\r\n\t\t\tcase 3: parser.SectorSize = 512; break;\r\n\t\t\tcase 4: parser.SectorSize = 4096; break;\r\n\t\t\tdefault: throw(new Error(\"Unknown CPF version\"));\r\n\t\t}\r\n\t\tlet dir = (dv.getUint32(48, true) + 1) * parser.SectorSize; //Calculate offset based on sector#, this points to the directory stream\r\n\t\tparser.DirStreamOffset = dir;\r\n\t\tparser.StreamSize = (dv.getUint32(dir + 128 + 124, true) << 32) + dv.getUint32(dir + 128 + 120, true); //Workbook stream size, read as a Uint64\r\n\t}\r\n\tstatic getSheets(parser, ab, dv) { //Collect the sheet informations\r\n\t\tlet WorkbookSector = dv.getUint32(parser.DirStreamOffset + 128 + 116, true);\r\n\t\tlet WorkbookOffset = (WorkbookSector + 1 ) * parser.SectorSize;\r\n\t\tparser.WorkbookSector = WorkbookSector;\r\n\t\tparser.WorkbookOffset = WorkbookOffset;\r\n\t\tlet cursor = WorkbookOffset + 4;\r\n\t\tparser.BIFFversion = dv.getUint16(cursor, false); //Biff version, can be read as big endian. It should be 6 for BIFF8, but can be lower for older versions\r\n\t\tcursor += 4; //The BOF is 16 bytes long for BIFF8 but only 8 for earlier versions, so we try not to go to far to be sure not to miss the BoundSheet stream\r\n\t\tlet read = dv.getUint16(cursor, true); //Initial value\r\n\t\tlet end = dv.byteLength; //Safety against infinite while loop...\r\n\t\twhile(read != 133 && cursor < end) { //Loop until the BoundSheet code (85 00) is found\r\n\t\t\tcursor += 1;\r\n\t\t\tread = dv.getUint16(cursor, true);\r\n\t\t}\r\n\t\tif(read != 133) {throw(new Error(\"Could not find BoundSheet stream...\"))}\r\n\t\tcursor += 2; //Skip the 2 bytes corresponding to the BoundSheet code\r\n\t\tparser.Sheets = []; //Prepare an array for the sheets\r\n\t\tlet list = []; //Array of sheet name that is used to populate the select control\r\n\t\tlet newSheet = true;\r\n\t\twhile(newSheet && cursor < end) { //Collect all the sheet information\r\n\t\t\tlet sheetOffset = dv.getUint32(cursor + 2, true) + WorkbookOffset; //Sheet offset is from the start of the workbook offset\r\n\t\t\tlet sheetType = dv.getUint8(cursor + 6, true); //SheetType, must be 0 for a worksheet\r\n\t\t\tcursor += 8; //Name length read at offset 8 from BoundSheet code\r\n\t\t\tlet l = dv.getUint16(cursor, true); //Name length\r\n\t\t\tif(parser.BIFFversion < 6) { //In older version of BIFF, the length is coded with only one byte, not 2...\r\n\t\t\t\tl = dv.getUint8(cursor, true);\r\n\t\t\t\tcursor += 1;\r\n\t\t\t}\r\n\t\t\telse {cursor += 2} //Position the cursor just after the name length, at the start of the string\r\n\t\t\tif(sheetType == 0) { //Sheets other than worksheets are ignored\r\n\t\t\t\tlet td = new TextDecoder(\"windows-1252\"); //Let's hope text encoding is same for everyone since it is 1 byte per character...\r\n\t\t\t\tlet view = new Uint8Array(ab, cursor, l);\r\n\t\t\t\tlet name = td.decode(view);\r\n\t\t\t\tparser.Sheets.push({Name: name, Offset: sheetOffset});\r\n\t\t\t\tlist.push(name);\r\n\t\t\t}\r\n\t\t\tcursor += l; //Position the cursor just after the sheet name\r\n\t\t\tif(dv.getUint16(cursor, true) != 133) {newSheet = false} //Last sheet has been read\r\n\t\t\telse {cursor += 2} //Position the cursor just after the boundsheet code to prepare for reading the next sheet\r\n\t\t}\r\n\t\tif(cursor > end) {throw(new Error(\"EOF reached after sheets metadata\"))}\r\n\t\tlet l = parser.Sheets.length - 1;\r\n\t\tfor(let i=0; i<l; i++) { //Define the length of each sheet based on the offset of the sheet above\r\n\t\t\tlet s = parser.Sheets[i];\r\n\t\t\ts.Length = parser.Sheets[i+1].Offset - s.Offset;\r\n\t\t}\r\n\t\tlet lastSheet = parser.Sheets[l];\r\n\t\tlastSheet.Length = parser.StreamSize; //For the last sheet, use the WB stream size as limit\r\n\t\tparser.Options.Sheet.updateList(list);\r\n\t\treturn cursor;\r\n\t}\r\n\tstatic getSharedStrings(parser, ab, dv, cursor) { //Gather the shared strings. This only applies for BIFF8 (version 6)\r\n\t\tparser.SharedStrings = []; //Reset previous values\r\n\t\tlet read = dv.getUint16(cursor, true); //Initial value\r\n\t\tlet end = dv.byteLength; //Safety against infinite while loop...\r\n\t\twhile(read != 252 && cursor < end) { //Loop until the SharedString code (FC 00) is found\r\n\t\t\tcursor += 1;\r\n\t\t\tread = dv.getUint16(cursor, true);\r\n\t\t}\r\n\t\tif(read != 252) {throw(new Error(\"Could not find SharedString stream...\"))}\r\n\t\tlet n = dv.getUint16(cursor + 2, true); //The size of the record, in bytes\r\n\t\tlet offset = 12; //Position the cursor at the beginning of the first string\r\n\t\twhile(offset < n) { //Get all the shared strings\r\n\t\t\tlet o = this.parseString(ab, dv, cursor + offset);\r\n\t\t\tparser.SharedStrings.push(o.Str);\r\n\t\t\toffset += o.Offset;\r\n\t\t}\r\n\t}\r\n\tstatic buildSheetAB(ab, sheet, SectorSize, wbOffset, wbSector, BIFFversion) { //For older versions of BIFF, there seems to be cases where the FAT are not in a direct sequence and the arraybuffer needs reshuffling\r\n\t\tif(BIFFversion == 6) {return ab.slice(sheet.Offset, sheet.Offset + sheet.Length)} //BIFF for which there is no INDEX / DBCELL needs reshuffling\r\n\t\tlet dv = new DataView(ab);\r\n\t\tlet FAT = InputParser_XLS.getFatArray(dv, SectorSize); //Get the array of FAT, storing how the sectors are chained\r\n\t\tlet ordered = new Uint8Array(ab.byteLength); //A typed array containing the arraybuffer data in the right order\r\n\t\tlet maxIndex = SectorSize / 4; //Limited number of sectors per FAT, depending on the sector size (they are all stored over 4 bytes)\r\n\t\tlet i = 0;\r\n\t\tlet j = Math.floor(wbSector / maxIndex); //j is the index within the FAT array; Which index to use is calculated from the index\r\n\t\tlet next = dv.getInt32(FAT[j] + wbSector * 4, true); //Index of the next sector in chain after the wbSector. Signed int is used to quickly recognize Free Sector (FFFF FFFF; -1) that mark the end of the track\r\n\t\tlet start = wbOffset; //Offset for the start of the workbook\r\n\t\tlet temp = new Uint8Array(ab.slice(start, start + SectorSize)); //First piece of the buffer\r\n\t\tordered.set(temp); //Set the first piece at the 0 position\r\n\t\t//console.log(FAT, next, start, temp);\r\n\t\twhile(next > -1) { //Loop until the end of the FAT sectors (EOC or FS)\r\n\t\t\t//console.log(next, i, j);\r\n\t\t\tstart = (next + 1) * SectorSize;\r\n\t\t\ttemp = new Uint8Array(ab.slice(start, start + SectorSize)); //Next piece of the buffer\r\n\t\t\tordered.set(temp, (i + 1) * SectorSize);\r\n\t\t\ti++;\r\n\t\t\tj = Math.floor(next / maxIndex); //Update the FAT array index to use to find this sector index\r\n\t\t\tnext = dv.getInt32(FAT[j] + (next - (j * maxIndex)) * 4, true); //Need to offset next to get the correct byteOffset location in the FAT array index\r\n\t\t}\r\n\t\t//console.log(ordered);\r\n\t\tstart = sheet.Offset - wbOffset; //Since the buffer is reshuffled and starts directly with the workbook sector, the wbOffset should be removed from the sheet offset to get to the right position\r\n\t\treturn ordered.buffer.slice(start, start + sheet.Length);\r\n\t}\r\n\tstatic getFatArray(dv, SectorSize) { //Get the array of FAT. Each element of FAT is a sector storing the next sector in chain for a given sector index\r\n\t\tlet FATnb = dv.getUint32(44, true); //Number of expected FAT sectors\r\n\t\tlet FAT = []; //Array of FAT, will be used to store their offset\r\n\t\tlet i = 76; //From this location, gather the FAT sectors\r\n\t\tlet sector = dv.getInt32(76, true); //We use the signed int to quickly recognize FS (FFFF FFFF; -1) value that mark the end of the track\r\n\t\twhile(sector != -1 && i < 512) { //Gather the FAT sectors from the header\r\n\t\t\tFAT.push((sector + 1) * SectorSize);\r\n\t\t\ti += 4;\r\n\t\t\tsector = dv.getInt32(i, true); //Refresh the sector\r\n\t\t}\r\n\t\tif(dv.getUint32(72, true) > 0) { //If additional DIFAT are required to locate all the FAT, traverse them the same way\r\n\t\t\tlet n = 109; //The number of FAT already counted from the header\r\n\t\t\ti = (dv.getUint32(68, true) + 1) * SectorSize; //1st DIFAT location, the others just follow\r\n\t\t\tsector = dv.getInt32(i, true); //Here again, we use the signed integer\r\n\t\t\twhile(sector != -1 && n < FATnb) { //Gather all the remaining FAT sectors\r\n\t\t\t\tFAT.push((sector + 1) * SectorSize);\r\n\t\t\t\ti += 4;\r\n\t\t\t\tn++;\r\n\t\t\t\tsector = dv.getInt32(i, true); //Here again, we use the signed integer\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn FAT;\r\n\t}\r\n\tstatic parseString(ab, dv, cursor) { //Parse a string record starting at the cursor position given; also returns the offset needed to reach the next record\r\n\t\tlet td = new TextDecoder(\"windows-1252\"); //Sorry for other text encoding, it will be for future updates...\r\n\t\tlet l = dv.getUint16(cursor, true); //Size of the string (characters)\r\n\t\tlet flags = dv.getUint8(cursor + 2, true);\r\n\t\tlet offset = 3; //Position the cursor after the meta\r\n\t\tlet fHighByte = flags & 1; //0000 0001\r\n\t\tlet fExtSt = flags & 4; //0000 0100\r\n\t\tlet fRichSt = flags & 8; //0000 1000\r\n\t\tlet ignored = 0; //Additional Bytes ignored because of weird format shit\r\n\t\tif(fExtSt) {ignored += dv.getUint32(cursor + offset, true); offset += 4}\r\n\t\tif(fRichSt) {ignored += dv.getUint16(cursor + offset, true) * 4; offset += 2} //cRun * 4 Bytes each\r\n\t\tlet view = [];\r\n\t\tif(fHighByte) { //Each character is encoded over 2 bytes\r\n\t\t\ttd = new TextDecoder(\"utf-8\");\r\n\t\t\tl = 2 * l;\r\n\t\t\tview = new Uint16Array(ab, cursor + offset, l);\r\n\t\t}\r\n\t\telse {view = new Uint8Array(ab, cursor + offset, l)}\r\n\t\treturn {Str: td.decode(view), Offset: offset + ignored + l}\r\n\t}\r\n\tstatic initWorker(parser) {\r\n\t\tlet onMessage = function(e) { //What to do inside the worker when a message is received\r\n\t\t\t//console.log(\"Receiving data in worker\", e.data);\r\n\t\t\tlet buffer = e.data.Buffer; //Incoming arrayBuffer containing the excel sheet\r\n\t\t\tlet l = buffer.byteLength;\r\n\t\t\tlet sst = e.data.SharedStrings; //Shared strings for resolution of string\r\n\t\t\tlet WBoffset = e.data.WBoffset;\r\n\t\t\toffset = e.data.SheetOffset; //Offset of the sheet from the beginning of the file\r\n\t\t\tlet dv = new DataView(buffer);\r\n\t\t\tself.metaSheet(dv, WBoffset, l); //Init the parsing by checking sheet structural info and placing the cursor at the right location for cell reading\r\n\t\t\t//console.log(\"Meta done\", self.Blocs, self.BIFF);\r\n\t\t\tself.parse(buffer, dv, offset, sst, l);\r\n\t\t\t//console.log(\"Worker Done\");\r\n\t\t\tpostMessage({Done: true}); //Process end\r\n\t\t}\r\n\t\tlet metaSheet = function(dv, WBoffset, l) { //Init the parsing by checking sheet structural info and placing the cursor at the right location for cell reading\r\n\t\t\tif(dv.getUint16(0, true) != 2057) {throw(new Error(\"Sheet BOF location incorrect\")); return} //Worksheet BOF code: 0908\r\n\t\t\tlet cursor = dv.getUint16(2, true) + 4; //Position the cursor at the end of the BOF record\r\n\t\t\tlet biff = dv.getUint16(4, false); //Should be 6 for BIFF5-8\r\n\t\t\tself.BIFF = biff; //Biff version for the sheet\r\n\t\t\tif(biff == 6) { //For these versions, we expect the Index to follow immediately the BOF\r\n\t\t\t\tif(dv.getUint16(cursor, true) != 523) {throw(new Error(\"No index available after BOF\")); return} //Index code: 0B02\r\n\t\t\t\tlet length = dv.getUint16(cursor + 2, true); //Length of the index record\r\n\t\t\t\tlet firstRow = dv.getUint32(cursor + 8, true);\r\n\t\t\t\tlet lastRow = dv.getUint32(cursor + 12, true);\r\n\t\t\t\tif(self.BIFFversion < 6) { //In lower versions, the first/last Rows are encoded over 2 bytes\r\n\t\t\t\t\tfirstRow = dv.getUint16(cursor + 8, true);\r\n\t\t\t\t\tlastRow = dv.getUint16(cursor + 10, true);\r\n\t\t\t\t\tcursor += 16; //Position the cursor at the first Row bloc location\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tcursor += 20; //Position the cursor at the first Row bloc location\r\n\t\t\t\t}\r\n\t\t\t\tlet n = Math.ceil((lastRow - firstRow) / 32); //Blocs of 32 Rows required to fit all the data\r\n\t\t\t\tlet blocs = [];\r\n\t\t\t\tfor(let i=0; i<n; i++) { //Store the offset for each DBCEll\r\n\t\t\t\t\tblocs.push(dv.getUint32(cursor + 4 * i, true) + WBoffset); //Offsets are encoded by 4 bytes and the workbook offset should be added\r\n\t\t\t\t}\r\n\t\t\t\tif(blocs.length == 0) {throw(new Error(\"Could not find any Row bloc offset\")); return}\r\n\t\t\t\tself.Blocs = blocs;\r\n\t\t\t}\r\n\t\t\telse { //In older versions of excel, there is no Index, so need to go through all the Cell Table until the first CELL record is found\r\n\t\t\t\tlet end = dv.byteLength; //Safety against infinite while loop...\r\n\t\t\t\tlet read = dv.getUint16(cursor, true); //Initial value\r\n\t\t\t\twhile(read != 520 && cursor < end) { //Loop until the ROW code (08 02) is found\r\n\t\t\t\t\tcursor += 1;\r\n\t\t\t\t\tread = dv.getUint16(cursor, true);\r\n\t\t\t\t}\r\n\t\t\t\tif(read != 520) {throw(new Error(\"Could not find Cell Table stream...\"))}\r\n\t\t\t\twhile(read == 520 && cursor < end) { //Now loop until the last ROW record\r\n\t\t\t\t\tcursor += 20; //All row record are 16 Bytes + 2 bytes code + 2 bytes length = 20 bytes total\r\n\t\t\t\t\tread = dv.getUint16(cursor, true);\r\n\t\t\t\t}\r\n\t\t\t\tif(cursor >= end) {throw(new Error(\"Could not find any Cell records...\"))}\r\n\t\t\t\tself.FirstCellOffset = cursor; //Save the location of the first cell record\r\n\t\t\t\t//console.log(cursor);\r\n\t\t\t}\r\n\t\t}\r\n\t\tlet parse = function(ab, dv, offset, sst, l) { //Parse the sheet data\r\n\t\t\tself.RowIndex = 0; //Starting row Index\r\n\t\t\tif(self.Blocs) { //The file has DBCell sectors and needs to be parsed bloc per bloc\r\n\t\t\t\tlet n = self.Blocs.length; //Number of blocs\r\n\t\t\t\tself.Blocs.forEach(function(o, i) { //For each bloc\r\n\t\t\t\t\tlet b = o - offset; //Offset stored in blocs are from the begining of the file, so need to remove the sheet offset from it\r\n\t\t\t\t\tlet firstRowOffset = dv.getUint32(b + 4, true); //Offset of the first row from the start of the DBcell\r\n\t\t\t\t\tlet firstCellOffset = (b - firstRowOffset) + 20 + dv.getUint16(b + 8, true); //Offset of the first cell of the first row, from the end of the first row record (whose length is 20 bytes)\r\n\t\t\t\t\tif(i == (n - 1)) {end = l} //For the last bloc, end is set as the end of the sheet\r\n\t\t\t\t\telse {end = this.Blocs[i + 1] - offset} //Otherwise, the start of the next dBCell is used as end point\r\n\t\t\t\t\t//console.log(\"Parsing bloc \" + i, b, firstRowOffset, firstCellOffset, end);\r\n\t\t\t\t\tthis.getRows(ab, dv, sst, firstCellOffset, end);\r\n\t\t\t\t}, self); //Self is used as the this context in the foreach loop\r\n\t\t\t}\r\n\t\t\telse { //In older versions, no dBCell...\r\n\t\t\t\t//console.log(dv.getUint16(self.FirstCellOffset, true));\r\n\t\t\t\tthis.getRows(ab, dv, undefined, self.FirstCellOffset, ab.byteLength);\r\n\t\t\t}\r\n\t\t}\r\n\t\tlet getRows = function(ab, dv, sst, start, end) { //Get the rows available from the start to end bytes of the buffer\r\n\t\t\tself.Cursor = start; //Position the cursor at the first cell location\r\n\t\t\tlet row = [];\r\n\t\t\tlet done = false;\r\n\t\t\twhile(!done && self.Cursor < end) { //Parse all data until the buffer is exhausted\r\n\t\t\t\tlet c = self.cell(ab, dv, sst);\r\n\t\t\t\t//console.log(\"Worker cell\", c);\r\n\t\t\t\tdone = c.Done;\r\n\t\t\t\tif(!done) { //A valid cell data is received\r\n\t\t\t\t\tlet cellRow = c.Row;\r\n\t\t\t\t\twhile(self.RowIndex < cellRow && self.RowIndex < 65536) { //Fill the gaps between rows if any. A second stop condition is added for security (65535 = max number of row possible for XLS files)\r\n\t\t\t\t\t\t//console.log(\"Worker posting\", row, self.Cursor);\r\n\t\t\t\t\t\tpostMessage({Row: row}); //Post the completed row and start a new one\r\n\t\t\t\t\t\trow = [];\r\n\t\t\t\t\t\tself.RowIndex++;\r\n\t\t\t\t\t}\r\n\t\t\t\t\trow[c.Col] = c.Value;\r\n\t\t\t\t\tif(c.More !== undefined) { //Case of multiple records\r\n\t\t\t\t\t\tc.More.forEach(function(v, i) {row[c.Col + i + 1] = v}); //Push all the cell values\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse { //All data collected, submit the completed row\r\n\t\t\t\t\t//console.log(\"Worker posting (done)\", row, self.Cursor);\r\n\t\t\t\t\tpostMessage({Row: row});\r\n\t\t\t\t\tself.RowIndex++;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tlet cell = function(ab, dv, sst) { //Process the cell at the current cursor location\r\n\t\t\tlet cursor = self.Cursor;\r\n\t\t\tlet dataType = dv.getUint16(cursor, true);\r\n\t\t\tlet recLen = dv.getUint16(cursor + 2, true); //Size of the cell record in Bytes, excluding header code and size\r\n\t\t\tlet parsed = { //Data for the parsed cells\r\n\t\t\t\tRow: dv.getUint16(cursor + 4, true),\r\n\t\t\t\tCol: dv.getUint16(cursor + 6, true),\r\n\t\t\t\tValue: undefined,\r\n\t\t\t\tDone: false,\r\n\t\t\t}\r\n\t\t\tswitch(dataType) { //Cell value is evaluated depending on the record type\r\n\t\t\t\tcase 253: //FD00 SharedString\r\n\t\t\t\t\tparsed.Value = sst[dv.getUint32(cursor + 10, true)]; break;\r\n\t\t\t\tcase 515: //0302 Number, as a 64bit IEEE floating-point \r\n\t\t\t\t\tparsed.Value = dv.getFloat64(cursor + 10, true); break;\r\n\t\t\t\tcase 126: case 638: //7E00 RK or 7E02 RK\r\n\t\t\t\t\tparsed.Value = self.parseRK(cursor + 10, dv); break;\r\n\t\t\t\tcase 189: //BD00 MulRK, multiple RK numbers to read\r\n\t\t\t\t\tparsed.Value = self.parseRK(cursor + 10, dv); //First value read as the others\r\n\t\t\t\t\tparsed.More = []; //Array to receive additional RK values\r\n\t\t\t\t\tlet start = cursor + 16; //Position of the next RK record\r\n\t\t\t\t\tlet stop = cursor + recLen + 2; //Cursor + 4 + recLen is the full size, but two last bytes are for the index of the last column\r\n\t\t\t\t\twhile(start < stop) { //Accumulate the values until the chain is exhausted\r\n\t\t\t\t\t\tparsed.More.push(self.parseRK(start, dv));\r\n\t\t\t\t\t\tstart += 6;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t//console.log(\"MULRK\", parsed, cursor, recLen, start, stop);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 215: //D700 DBCell, mark the end of the cell data for BIFF5-8 files\r\n\t\t\t\t\tparsed.Done = true; break;\r\n\t\t\t\tcase   6: case 518: case 1030: //0600 Formula or 0602 Formula or 0604 Formula\r\n\t\t\t\t\tlet bytes = [];\r\n\t\t\t\t\tfor(let i=0; i<8; i++) {bytes.push(dv.getUint8(cursor + 10 + i, true))} //Collect bytes for the FormulaValue field\r\n\t\t\t\t\tif(bytes[6] == 255 && bytes[7] == 255) { //fExprO = 0xFFFF, boolean/error/blank/string can be stored\r\n\t\t\t\t\t\tswitch(bytes[0]) {\r\n\t\t\t\t\t\t\tcase 0: //A string is stored in this formula\r\n\t\t\t\t\t\t\t\tlet o = self.parseString(ab, dv, cursor + recLen + 8); //A string record immediately follows the formula record. It starts with the string code (0702) and the record length (total 4 bytes), followed by a string structure\r\n\t\t\t\t\t\t\t\tparsed.Value = o.Str; //The parsed string\r\n\t\t\t\t\t\t\t\tself.Cursor += (o.Offset + 4); //Need to offset by the size of the string record to get to the next cell\r\n\t\t\t\t\t\t\t\tbreak; \r\n\t\t\t\t\t\t\tcase 1: //boolean value => Read bytes[2]\r\n\t\t\t\t\t\t\t\tif(bytes[2] == 0) {parsed.Value = \"FALSE\"}\r\n\t\t\t\t\t\t\t\telse {parsed.Value = \"TRUE\"}\r\n\t\t\t\t\t\t\t\tbreak; \r\n\t\t\t\t\t\t\tcase 2:  //Error value => Read bytes[2]\r\n\t\t\t\t\t\t\t\tswitch(bytes[2]) {\r\n\t\t\t\t\t\t\t\t\tcase 0: parsed.Value = \"#NULL!\"; break;\r\n\t\t\t\t\t\t\t\t\tcase 7: parsed.Value = \"#DIV/0!\"; break;\r\n\t\t\t\t\t\t\t\t\tcase 15: parsed.Value = \"#VALUE!\"; break;\r\n\t\t\t\t\t\t\t\t\tcase 23: parsed.Value = \"#REF!\"; break;\r\n\t\t\t\t\t\t\t\t\tcase 29: parsed.Value = \"#NAME?\"; break;\r\n\t\t\t\t\t\t\t\t\tcase 36: parsed.Value = \"#NUM!\"; break;\r\n\t\t\t\t\t\t\t\t\tcase 42: parsed.Value = \"#N/A\"; break;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\tdefault: break; //Includes case 3, Blank\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {parsed.Value = dv.getFloat64(cursor + 10, true)} //Numerical value\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 516: case 214: //0402 Label, D600 RString (for older versions without sst)\r\n\t\t\t\t\tlet td = new TextDecoder(\"windows-1252\"); //Sorry for other text encoding, it will be for future updates...\r\n\t\t\t\t\tlet view = new Uint8Array(ab, cursor + 12, dv.getUint16(cursor + 10, true));\r\n\t\t\t\t\tparsed.Value = td.decode(view);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 513: break; //0102 Blank cell\r\n\t\t\t\tcase 190: break; //BE00 MulBlank\r\n\t\t\t\tcase 517: break; //0502 BoolErr\r\n\t\t\t\t//break;\r\n\t\t\t\tdefault: //Other values should mark the end of the cell table\r\n\t\t\t\t\tparsed.Done = true; break;\r\n\t\t\t}\r\n\t\t\tself.Cursor += (recLen + 4); //Move the cursor to the next cell\r\n\t\t\treturn parsed;\r\n\t\t}\r\n\t\tlet parseRK = function(cursor, dv) { //Parse and return the value for the RK number\r\n\t\t\tlet temp = dv.getUint8(cursor, true);\r\n\t\t\tlet fX100 = temp & 1; //Bitwise comparison with 1: 00000001, will return 1 if and only if the first bit is 1\r\n\t\t\tlet fInt = temp & 2; //Bitwise comparison with 2: 00000010, will return 2 if and only if the second bit is 1\r\n\t\t\tlet num = undefined;\r\n\t\t\t//console.log(temp, fX100, fInt);\r\n\t\t\tif(fInt == 2) {num = dv.getInt32(cursor, true) >> 2} //The stored number is a signed integer, it should be shifted 2 bits because of the metadata\r\n\t\t\telse { //30 most significant bits of a 64-bit binary floating point number, see iEEE754\r\n\t\t\t\tlet bytes = [temp, dv.getUint8(cursor + 1, true), dv.getUint8(cursor + 2, true), dv.getUint8(cursor + 3, true)]; //4 bytes containing the data; first byte has only 6 bits of data\r\n\t\t\t\tlet sign = 1 - (2 * (bytes[3] >> 7));\r\n\t\t\t\tlet exponent = ((((bytes[3] << 1) & 0xff) << 3) | (bytes[2] >> 4)) - ((1 << 10) - 1); //0xff = 1111 1111\r\n\t\t\t\tlet mantissa = ((bytes[2] & 0x0f) * Math.pow(2, 48)) + (bytes[1] * Math.pow(2, 40)) + ((bytes[0] & 0xfc) * Math.pow(2, 32)); //Other bytes are all null; 0x0f = 0000 1111;  0xfc = 1111 1100\r\n\t\t\t\tif (exponent == 1024) { //Particular cases\r\n\t\t\t\t\tif (mantissa != 0) {return NaN}\r\n\t\t\t\t\telse {return sign * Infinity}\r\n\t\t\t\t}\r\n\t\t\t\tif (exponent == -1023) {num = sign * mantissa * Math.pow(2, -1022 - 52)} // Denormalized\r\n\t\t\t\telse {num = sign * (1 + mantissa * Math.pow(2, -52)) * Math.pow(2, exponent)}\r\n\t\t\t}\r\n\t\t\tif(fX100 == 1) {return num / 100}\r\n\t\t\telse {return num}\r\n\t\t}\r\n\t\tlet code =\"\";\r\n\t\tcode += \"self.cell = \" + cell.toString() + \"; \";\r\n\t\tcode += \"self.parseRK = \" + parseRK.toString() + \"; \";\r\n\t\tcode += \"self.metaSheet = \" + metaSheet.toString() + \"; \";\r\n\t\tcode += \"self.parse = \" + parse.toString() + \"; \";\r\n\t\tcode += \"self.getRows = \" + getRows.toString() + \"; \";\r\n\t\tcode += \"self.parseString = \" + this.parseString.toString().replace(\"parseString\", \"function\") + \"; \";\r\n\t\tcode += \"self.Cursor = 0; \";\r\n\t\tcode += \"self.BIFFversion = \" + parser.BIFFversion + \"; \"; //BIFF Version for the file\r\n\t\tcode += \"onmessage = \" + onMessage.toString() + \";\";\r\n\t\tlet blob = new Blob([code], {type: \"application/javascript\"});\r\n\t\treturn new Worker(URL.createObjectURL(blob));\r\n\t}\r\n\t//Methods\r\n\tfirstParse(I) { //Parse the entire file to get nb of rows and columns available\r\n\t\tthis.TotalCols = 0; //Reset previous data\r\n\t\tthis.TotalRows = 0;\r\n\t\tInputParser_XLS.getMeta(this).then(function() { //Get the metadata\r\n\t\t\tthis.stream(function(row, selected, parser) { //Step function\r\n\t\t\t\tlet l = row.length;\r\n\t\t\t\tif(l > this.TotalCols) {this.TotalCols = l}\r\n\t\t\t\tthis.TotalRows++;\r\n\t\t\t\tif(I && I.Step) {I.Step(row, this.TotalRows, parser)}\r\n\t\t\t}.bind(this), function() { //Completion function\r\n\t\t\t\tthis.FirstParsed = true;\r\n\t\t\t\tthis.parse(I);\r\n\t\t\t}.bind(this), I); //Pass options to the stream to catch errors\r\n\t\t}.bind(this), function(error) { //What to do if the reading fail\r\n\t\t\tthis.Error = true;\r\n\t\t\tthis.ErrorDetails = error;\r\n\t\t\tthis.parse(I); //We call the parse again so that the error message and status are reflected in the preview box and the input table\r\n\t\t\tif(I && I.Error) {I.Error(error)}\r\n\t\t}.bind(this));\r\n\t}\r\n\tstream(f, complete, I) { //Stream the input and send the row to the function provided as argument\r\n\t\tlet w = InputParser_XLS.initWorker(this); //Initialize the webworker\r\n\t\tthis.Worker = w; //Expose the worker so that the parsing can be killed following outside events\r\n\t\tlet o = this.parsingOptions();\r\n\t\tif(I && I.ApplyToHeader) {o.ApplyToHeader = true}\r\n\t\tlet reader = new FileReader();\r\n\t\tlet onError = function(e) { //Error loading the file\r\n\t\t\tthis.Error = true;\r\n\t\t\tthis.ErrorDetails = e;\r\n\t\t\tif(I && I.Error) {I.Error(e)}\r\n\t\t\tthis.parseEnd(w, o, complete);\r\n\t\t}.bind(this);\r\n\t\treader.onerror = function(e) {onError(reader.error)} //Catch errors thrown by the FileReader\r\n\t\treader.onload = function(e) { //After the file is loaded\r\n\t\t\tlet ab = e.target.result; //the arraybuffer\r\n\t\t\tlet sheet = this.Sheets[this.Options.Sheet.getValue()]; //Selected sheet object\r\n\t\t\t//let sheetAB = ab.slice(sheet.Offset, sheet.Offset + sheet.Length); //A slice of the arraybuffer that contains the sheet data\r\n\t\t\tlet sheetAB = InputParser_XLS.buildSheetAB(ab, sheet, this.SectorSize, this.WorkbookOffset, this.WorkbookSector, this.BIFFversion); //A slice of the arraybuffer that contains the sheet data\r\n\t\t\tw.postMessage({Buffer: sheetAB, SharedStrings: this.SharedStrings, WBoffset: this.WorkbookOffset, SheetOffset: sheet.Offset}, [sheetAB]); //Transfer ownership of the arraybuffer to the worker and initiate the parsing\r\n\t\t}.bind(this);\r\n\t\tlet parser = { //A parser object that is used to catch abort events by the user\r\n\t\t\tabort: function() {this.parseEnd(w, o, complete)}.bind(this),\r\n\t\t\tFirstParsed: this.FirstParsed,\r\n\t\t};\r\n\t\tw.onmessage = function(e) { //What to do when the worker sends a row\r\n\t\t\t//console.log(\"Data from worker\", e.data);\r\n\t\t\t//\r\n\t\t\t//setTimeout(w.terminate(), 1000); //FOR TEST\r\n\t\t\t//\r\n\t\t\t\r\n\t\t\tif(e.data.Done) {this.parseEnd(w, o, complete)} //Parsing is done\r\n\t\t\telse { //Parsing is on-going\r\n\t\t\t\tthis.processRow(e.data.Row, parser, f, o); //Process the row and run the function provided by the user, when needed\r\n\t\t\t}\r\n\t\t\t\r\n\t\t}.bind(this);\r\n\t\tw.onmessageerror = function(e) {onError(e.message)} //Catch errors thrown by the worker\r\n\t\tw.onerror = function(e) {onError(e.message)}\r\n\t\treader.readAsArrayBuffer(this.RawData); //Start the file reading process\r\n\t}\r\n\tparseEnd(w, o, complete) { //Completion of the streaming\r\n\t\tw.terminate(); //Kill the worker\r\n\t\tthis.Worker = undefined;\r\n\t\tif(complete) {complete(o.Selected, o)} //Execute the complete function\r\n\t}\r\n\t/*chunk(f, I) { //Chunk a piece of the input and apply the provided function on each chunk\r\n\t\r\n\t}\r\n\tbulk(f) { //Fully Parse the input, in a single block, and execute the function passed as argument after cleaning. Don't do this for big files, use stream() instead \r\n\t\r\n\t}*/\r\n\t\r\n\t/*\r\n\t//LET'S SEE IF ALL THAT MESS IS USEFUL ONE DAY...\r\n\tthis.FAT = Array(dv.getUint32(44, true)); //Array of FAT, will be used to store their sector#\r\n\tthis.FAT = []; //Array of FAT, will be used to store their sector#\r\n\tthis.MiniFAT = Array(dv.getUint32(64, true)); //Array of miniFAT, will be used to store their sector#\r\n\tthis.DIFAT = dv.getUint32(72, true); //Number of DIFAT sectors\r\n\tif(this.MiniFAT.length > 0) {this.MiniFAT[0] = (dv.getUint32(60, true) + 1) * this.SectorSize} //Register 1st miniFAT location\r\n\tlet i = 76; //From this location, gather the FAT sectors\r\n\tlet sector = dv.getInt32(76, true); //We use the signed int to quickly recognize FS (FFFF FFFF; -1) value that mark the end of the track\r\n\twhile(sector != -1 && i < 512) { //Gather the FAT sectors from the header\r\n\t\tthis.FAT.push((sector + 1) * this.SectorSize);\r\n\t\ti += 4;\r\n\t\tsector = dv.getInt32(i, true); //Refresh the sector\r\n\t}\r\n\tif(this.DIFAT > 0) { //If additional DIFAT are required to locate all the FAT, traverse them the same way\r\n\t\tlet max = dv.getUint32(44, true); //The max number of FAT that we expect\r\n\t\tlet n = 109; //The number of FAT already counted from the header\r\n\t\ti = (dv.getUint32(68, true) + 1) * this.SectorSize; //1st DIFAT location, the others just follow\r\n\t\tsector = dv.getInt32(i, true); //Here again, we use the signed integer\r\n\t\twhile(sector != -1 && n < max) { //Gather all the remaining FAT sectors\r\n\t\t\tthis.FAT.push((sector + 1) * this.SectorSize);\r\n\t\t\ti += 4;\r\n\t\t\tn++;\r\n\t\t\tsector = dv.getInt32(i, true); //Here again, we use the signed integer\r\n\t\t}\r\n\t}\r\n\tlet miniFatOffset = dv.getInt32(60, true); //We use the signed version to quickly recognize FEFF FFFF values (EOC)\r\n\tif(miniFatOffset < 0) {this.MiniFat = []} //No miniFat\r\n\telse {this.MiniFat = [dv.getUint32(60, true)]} //Get the offset for the first miniFat location\r\n\t*/\r\n}","//************************************************************************\r\n// INPUTPARSER_XLSX - A parser for xlsx files thatfully supports streaming\r\n//************************************************************************\r\nclass InputParser_XLSX extends InputParser {\r\n\tconstructor(I) {\r\n\t\tsuper(I);\r\n\t\tthis.Type = \"XLSX\";\r\n\t\tthis.Help = \"Parsing of .xlsx Excel files with streaming capabilities\";\r\n\t\tlet target = Form_Import.Anchors.ParserOptions; //Target ID for the options\r\n\t\tthis.Options = Object.assign(this.Options, { //These options require a new parsing to be performed\r\n\t\t\tSheet: LinkCtrl.new(\"Select\", {ID: target, Label: \"Sheet\", Default: 0, List: [], Preserve: true, NewLine: true, Index: 5, Change: function() {\r\n\t\t\t\tif(this.Worker) {this.Worker.terminate()}\r\n\t\t\t\tthis.FirstParsed = false; //Need to reevaluate available rows/cols\r\n\t\t\t\tthis.parse();\r\n\t\t\t}.bind(this), Title: \"The sheet to import\"}),\r\n\t\t});\r\n\t\tthis.Worker = undefined; //WebWorker used to process the file\r\n\t\tthis.ZIP = undefined;\r\n\t\tthis.SharedStrings = undefined;\r\n\t}\r\n\t//Static methods\r\n\tstatic getSheetNames(zip, DOMParser) { //Parse the input to get the number of sheets and their names\r\n\t\treturn new Promise(function(resolve, reject) {\r\n\t\t\tzip.file(\"xl/workbook.xml\").async(\"string\").then(function(str) {\r\n\t\t\t\tlet xml = DOMParser.parseFromString(str, \"application/xml\").getElementsByTagName(\"sheet\");\r\n\t\t\t\tlet l = xml.length;\r\n\t\t\t\tlet sheets = Array(l);\r\n\t\t\t\tfor(let i=0; i<l; i++) {\r\n\t\t\t\t\tlet index = Number(xml[i].attributes.sheetId.value) - 1;\r\n\t\t\t\t\tsheets[index] = xml[i].attributes.name.value;\r\n\t\t\t\t}\r\n\t\t\t\tresolve(sheets);\r\n\t\t\t}, function(e) {reject(e)});\r\n\t\t}.bind(this));\r\n\t}\r\n\tstatic getSharedStrings(zip, DOMParser) { //Parse the input to get the shared strings available for this file\r\n\t\treturn new Promise(function(resolve, reject) {\r\n\t\t\tzip.file(\"xl/sharedStrings.xml\").async(\"string\").then(function(str) {\r\n\t\t\t\tlet xml = DOMParser.parseFromString(str, \"application/xml\").getElementsByTagName(\"t\");\r\n\t\t\t\tlet l = xml.length;\r\n\t\t\t\tlet shared = [];\r\n\t\t\t\tfor(let i=0; i<l; i++) {\r\n\t\t\t\t\tshared.push(xml[i].innerHTML);\r\n\t\t\t\t}\r\n\t\t\t\tresolve(shared);\r\n\t\t\t}, function(e) {reject(e)});\r\n\t\t}.bind(this));\r\n\t}\r\n\tstatic getMeta(inputParser, zip) { //Recover meta data from the file and store them in the object property\r\n\t\tlet parser = new DOMParser();\r\n\t\treturn new Promise(function(resolve, reject) {\r\n\t\t\tlet promises = [this.getSheetNames(zip, parser), this.getSharedStrings(zip, parser)];\r\n\t\t\tPromise.all(promises).then(function(out) {\r\n\t\t\t\tinputParser.Options.Sheet.updateList(out[0]);\r\n\t\t\t\tinputParser.SharedStrings = out[1];\r\n\t\t\t\tresolve();\r\n\t\t\t}, function(e) {reject(e)});\r\n\t\t}.bind(this));\r\n\t}\r\n\tstatic initWorker() {\r\n\t\tlet f = function(e) { //What to do inside the worker when a message is received\r\n\t\t\tlet buffer = e.data.Buffer; //Incoming arraybuffer containing the excel sheet\r\n\t\t\tlet shared = e.data.SharedStrings;\r\n\t\t\tlet alphabet = \"*ABCDEFGHIJKLMNOPQRSTUVWXYZ\"; //Add a first character to shift the index by 1, so that A=1, B=2, C=3...\r\n\t\t\tlet chunkSize = self.MaxChunkSize; //The length of data to process\r\n\t\t\tlet l = buffer.byteLength;\r\n\t\t\twhile(self.Position < l) { //While the buffer has not been fully processed\r\n\t\t\t\tif((self.Position + self.MaxChunkSize) > l) {chunkSize = l - self.Position} //There are less elements to process than the max allowed\r\n\t\t\t\tlet view = new Uint8Array(buffer, self.Position, chunkSize); //Get data from arraybuffer\r\n\t\t\t\tlet data = new TextDecoder(\"utf-8\").decode(view);\r\n\t\t\t\tif(self.LastRow) {data = self.LastRow + data} //Concate the remaining elements from previous chunk to get it full\r\n\t\t\t\tdata.split('<row r=\"').forEach(function(str, i) { //Process all the individual row chunks\r\n\t\t\t\t\tlet rowEnd = str.indexOf(\"</row>\");\r\n\t\t\t\t\tif(rowEnd > -1) { //This means a complete row is present and can be parsed right away without worrying about missing items\r\n\t\t\t\t\t\tlet rowIndex = str.substring(0, str.indexOf('\"')); //Recover the row index, as a string!\r\n\t\t\t\t\t\tlet row = [];\r\n\t\t\t\t\t\tlet ColCount = 0; //How many columns are counted\r\n\t\t\t\t\t\tstr.split('<c r=\"').forEach(function(cell, j) { //Further divide it into individual cells\r\n\t\t\t\t\t\t\tif(j > 0) { //The first piece is the row header, which is not useful here\r\n\t\t\t\t\t\t\t\tlet colName = cell.substring(0, cell.indexOf('\"') - rowIndex.length); //Recover the letters forming the cell name\r\n\t\t\t\t\t\t\t\tlet colIndex = -1; //Start at -1 to retrieve a 0-based index\r\n\t\t\t\t\t\t\t\tcolName.split(\"\").forEach(function(c, k) {colIndex += alphabet.indexOf(c) * Math.pow(26, colName.length - k - 1)}); //Convert colName to colIndex\r\n\t\t\t\t\t\t\t\twhile(ColCount < colIndex) {ColCount++; row.push(\"\")} //Fill gaps with empty values\r\n\t\t\t\t\t\t\t\tlet valStart = cell.indexOf(\"<v>\");\r\n\t\t\t\t\t\t\t\tif(valStart > -1) { //This cell has a value\r\n\t\t\t\t\t\t\t\t\tlet v = cell.substring(valStart + 3, cell.indexOf(\"</v>\")); //The value\r\n\t\t\t\t\t\t\t\t\tlet type = cell.match(/t=\"(.+?)\"/);\r\n\t\t\t\t\t\t\t\t\tif(type !== null) {\r\n\t\t\t\t\t\t\t\t\t\tswitch(type[1]) {\r\n\t\t\t\t\t\t\t\t\t\t\tcase \"b\": //Boolean value\r\n\t\t\t\t\t\t\t\t\t\t\t\tif(v) {row.push(\"TRUE\")}\r\n\t\t\t\t\t\t\t\t\t\t\t\telse {row.push(\"FALSE\")}\r\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\t\t\t\tcase \"s\": //Shared string\r\n\t\t\t\t\t\t\t\t\t\t\t\trow.push(shared[Number(v)]); //Convert the value using the shared dictionary and push it\r\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\t\t\t\tdefault: //This includes string and error values from formula\r\n\t\t\t\t\t\t\t\t\t\t\t\trow.push(v); //Push the value\r\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\telse {row.push(Number(v))} //Other cases should fall to the number type\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\telse {row.push(\"\")} //No value\r\n\t\t\t\t\t\t\t\tColCount++;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t\tpostMessage({Row: row});\r\n\t\t\t\t\t\tlet remaining = str.substring(rowEnd + 6); //What remains after the rowEnd tag?\r\n\t\t\t\t\t\tif(remaining.length == 0) {self.LastRow = undefined} //There is nothing left after the closing row tag, lucky you!\r\n\t\t\t\t\t\telse {self.LastRow = remaining} //Pieces left should be added to the next chunk\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {self.LastRow = str} //This row is not complete so we need to wait for the next chunk\r\n\t\t\t\t});\r\n\t\t\t\tself.Position += self.MaxChunkSize; //Increment position to process the next chunk of data\r\n\t\t\t}\r\n\t\t\tpostMessage({Done: true});\r\n\t\t}\r\n\t\tlet blob = new Blob([\"self.MaxChunkSize = 1024 * 1024; self.LastRow = undefined; self.Position = 0; onmessage = \" + f.toString()], {type: \"application/javascript\"});\r\n\t\treturn new Worker(URL.createObjectURL(blob));\r\n\t}\r\n\t//Methods\r\n\tfirstParse(I) { //Parse the entire file to get nb of rows and columns available\r\n\t\tthis.TotalCols = 0; //Reset previous data\r\n\t\tthis.TotalRows = 0;\r\n\t\tJSZip.loadAsync(this.RawData).then(function(zip) { //Read the archive to get the structure\r\n\t\t\tthis.ZIP = zip;\r\n\t\t\tInputParser_XLSX.getMeta(this, zip).then(function() { //Get the metadata\r\n\t\t\t\tthis.stream(function(row, selected, parser) { //Step function\r\n\t\t\t\t\tlet l = row.length;\r\n\t\t\t\t\tif(l > this.TotalCols) {this.TotalCols = l}\r\n\t\t\t\t\tthis.TotalRows++;\r\n\t\t\t\t\tif(I && I.Step) {I.Step(row, this.TotalRows, parser)}\r\n\t\t\t\t}.bind(this), function() { //Completion function\r\n\t\t\t\t\tthis.FirstParsed = true;\r\n\t\t\t\t\tthis.parse(I);\r\n\t\t\t\t}.bind(this), I);\r\n\t\t\t}.bind(this));\r\n\t\t}.bind(this), function(e) { //What to do on failure of archive reading\r\n\t\t\tthis.Error = true;\r\n\t\t\tthis.ErrorDetails = e;\r\n\t\t\tthis.parse(I); //We call the parse again so that the error message and status are reflected in the preview box and the input table\r\n\t\t\tif(I && I.Error) {I.Error(e)}\r\n\t\t}.bind(this));\r\n\t}\r\n\tstream(f, complete, I) { //Stream the input and send the row to the function provided as argument\r\n\t\tlet w = InputParser_XLSX.initWorker(); //Initialize the webworker\r\n\t\tthis.Worker = w; //Expose the worker so that the parsing can be killed following outside events\r\n\t\tlet sheet = this.ZIP.file(\"xl/worksheets/sheet\" + (this.Options.Sheet.getValue() + 1) + \".xml\");\r\n\t\tlet o = this.parsingOptions();\r\n\t\tlet onError = function(e) { //Error loading the file\r\n\t\t\tthis.Error = true;\r\n\t\t\tthis.ErrorDetails = e;\r\n\t\t\tif(I && I.Error) {I.Error(e)}\r\n\t\t\tthis.parseEnd(w, o, complete);\r\n\t\t}.bind(this);\r\n\t\tsheet.async(\"arraybuffer\").then(function(ab) { //Get the sheet as an arraybuffer and transfer it to the worker\r\n\t\t\tif(I && I.ApplyToHeader) {o.ApplyToHeader = true}\r\n\t\t\tlet parser = { //A parser object that is used to catch abort events by the user\r\n\t\t\t\tabort: function() {\r\n\t\t\t\t\tw.terminate(); //Kill the worker\r\n\t\t\t\t\tthis.Worker = undefined;\r\n\t\t\t\t\tif(complete) {complete(o.Selected, o)} //Execute the complete function\r\n\t\t\t\t}.bind(this),\r\n\t\t\t\tFirstParsed: this.FirstParsed,\r\n\t\t\t};\r\n\t\t\tw.onmessage = function(e) { //What to do when the worker sends a row\r\n\t\t\t\tif(e.data.Done) { //Parsing is done\r\n\t\t\t\t\t/*if(complete) { //Execute the user function on complete\r\n\t\t\t\t\t\tcomplete(o.Selected, o);\r\n\t\t\t\t\t\tw.terminate(); //Close the worker on completion\r\n\t\t\t\t\t\tthis.Worker = undefined; //Release the exposed worker\r\n\t\t\t\t\t}*/\r\n\t\t\t\t\tthis.parseEnd(w, o, complete);\r\n\t\t\t\t}\r\n\t\t\t\telse { //Parsing is on-going\r\n\t\t\t\t\tthis.processRow(e.data.Row, parser, f, o); //Process the row and run the function provided by the user, when needed\r\n\t\t\t\t}\r\n\t\t\t}.bind(this);\r\n\t\t\tw.onmessageerror = function(e) {onError(e.message)} //Catch errors thrown by the worker\r\n\t\t\tw.onerror = function(e) {onError(e.message)}\r\n\t\t\tw.postMessage({Buffer: ab, SharedStrings: this.SharedStrings}, [ab]); //Transfer the ownership of the arraybuffer to the worker\r\n\t\t}.bind(this));\r\n\t}\r\n\tparseEnd(w, o, complete) { //Completion of the streaming\r\n\t\tw.terminate(); //Kill the worker\r\n\t\tthis.Worker = undefined;\r\n\t\tif(complete) {complete(o.Selected, o)} //Execute the complete function\r\n\t}\r\n}","//**************************************************************************************************\r\n// MAPPER_DIRECT object - Function to process a file that contains no mapping for plate or well data\r\n//**************************************************************************************************\r\nclass Mapper_Direct extends Mapper {\r\n\tconstructor(mapping) {\r\n\t\tsuper();\r\n\t\treturn this;\r\n\t}\r\n\t//Methods\r\n\tscan(o, I, output) { //Scan the file and take the element as they come\r\n\t\treturn new Promise(function(resolve) {\r\n\t\t\to.Parser.stream(function(row, selected, parser) { //Stream the input\r\n\t\t\t\tif(I.MinMax) {Mapper.scanMinMax(o, row)} //Log the min/max attributes\r\n\t\t\t\tif(I.Preview) { //Prepare a preview\r\n\t\t\t\t\tMapper.scanPreviewColumns(output, row, (output.Items + 1) + \".\");\r\n\t\t\t\t\tif(output.LimitReached == true && I.Preview.Interrupt) {parser.abort()}\r\n\t\t\t\t}\r\n\t\t\t\toutput.Items++; //Increment the item count\r\n\t\t\t\tif(I.Custom) {I.Custom(undefined, undefined, row, output, parser)} //No well or plate information\r\n\t\t\t}, function(lines) { //Do this when done\r\n\t\t\t\tif(I.Log) {output.PlatesID = undefined} //In this case, the determination of the plate number is not possible\r\n\t\t\t\tresolve(output);\r\n\t\t\t});\r\n\t\t});\r\n\t}\r\n\tfind(o, I) { //Find the data when no mapping is available\r\n\t\tlet plateIndex = Number(I.Plate); //We need to convert the generic plate name in a number\r\n\t\tlet out = I.Default;\r\n\t\tlet start = (plateIndex - 1) * I.Factor;\r\n\t\tlet stop = plateIndex * I.Factor;\r\n\t\tlet index = 0;\r\n\t\tif(I.FindAll) {out = []}\r\n\t\treturn new Promise(function(resolve) {\r\n\t\t\to.Parser.stream(function(row, selected, parser) { //Stream the input\r\n\t\t\t\tif(selected == stop) {parser.abort()} //Outside the plate dimensions\r\n\t\t\t\telse {\r\n\t\t\t\t\tif(selected >= start) { //We are now exploring the definitions for the requested plate\r\n\t\t\t\t\t\tif(I.FindAll) {out.push(row[I.Column])}\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\tif(index == I.RangeIndexBase0) { //The correct element has been found\r\n\t\t\t\t\t\t\t\tout = row[I.Column];\r\n\t\t\t\t\t\t\t\tparser.abort();\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tindex++;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}, function(lines) { //Do this when done\r\n\t\t\t\tout = Mapper.fillMissingElements(out, I, start, index); //Fill missing elements if required\r\n\t\t\t\tresolve(out);\r\n\t\t\t});\r\n\t\t});\r\n\t}\r\n}","//*************************************************************************************************\r\n// MAPPER_PLATE object - Function to process a file that contains a mapping only for the plate data\r\n//*************************************************************************************************\r\nclass Mapper_Plate extends Mapper {\r\n\tconstructor(mapping) {\r\n\t\tsuper();\r\n\t\tthis.PlateCol = mapping[Mapper.plate().Name];\r\n\t\treturn this;\r\n\t}\r\n\t//Methods\r\n\tscan(o, I, output) { //Scan the file by searching plate data and execute the actions required\r\n\t\tlet p = this.PlateCol;\r\n\t\treturn new Promise(function(resolve) {\r\n\t\t\to.Parser.stream(function(row, selected, parser) { //Stream the input\r\n\t\t\t\tif(row[p] !== undefined) { //A valid entry is found\r\n\t\t\t\t\tif(I.Log) { //Log the data\r\n\t\t\t\t\t\tif(output.PlatesID.includes(row[p]) == false) {output.PlatesID.push(row[p])}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif(I.MinMax) {Mapper.scanMinMax(o, row)} //Log the min/max attributes\r\n\t\t\t\t\tif(I.Preview) { //Prepare a preview\r\n\t\t\t\t\t\tMapper.scanPreviewColumns(output, row, row[p] + \".\");\r\n\t\t\t\t\t\tif(output.LimitReached == true && I.Preview.Interrupt) {parser.abort()}\r\n\t\t\t\t\t}\r\n\t\t\t\t\toutput.Items++; //Increment the item count\r\n\t\t\t\t\tif(I.Custom) {I.Custom(undefined, row[p], row, output, parser)} //No well information\r\n\t\t\t\t}\r\n\t\t\t}, function() { //Do this when done\r\n\t\t\t\tresolve(output);\r\n\t\t\t});\r\n\t\t});\r\n\t}\r\n\tfind(o, I) { //Find the data when only plate mapping is available\r\n\t\tlet p = this.PlateCol;\r\n\t\tlet index = 0;\r\n\t\tlet out = I.Default; //Default fallback if the value is not found\r\n\t\tif(I.FindAll) {out = []}\r\n\t\treturn new Promise(function(resolve) { //Return a promise that fulfills with the data needed\r\n\t\t\to.Parser.stream(function(row, selected, parser) { //Do this for each row\r\n\t\t\t\tif(row[p] !== undefined && row[p] == I.Plate) { //Valid entry found for the desired plate, do what is needed\r\n\t\t\t\t\tif(I.FindAll) {\r\n\t\t\t\t\t\tout.push(row[I.Column]);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tif(index == I.RangeIndexBase0) { //This is the correct location\r\n\t\t\t\t\t\t\tout = row[I.Column];\r\n\t\t\t\t\t\t\tparser.abort(); //Stop here since the data has been found\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tindex++;\r\n\t\t\t\t}\r\n\t\t\t}, function() { //Do this when done\r\n\t\t\t\tout = Mapper.fillMissingElements(out, I, 0, index); //Fill missing elements if required\r\n\t\t\t\tresolve(out);\r\n\t\t\t});\r\n\t\t});\r\n\t}\r\n}","//*********************************************************************************************************\r\n// MAPPER_PLATEWELL object - Function to process a file that contains a mappin for both plate and well data\r\n//*********************************************************************************************************\r\nclass Mapper_PlateWell extends Mapper {\r\n\tconstructor(mapping) {\r\n\t\tsuper();\r\n\t\tthis.WellCol = mapping[Mapper.well().Name];\r\n\t\tthis.PlateCol = mapping[Mapper.plate().Name];\r\n\t\treturn this;\r\n\t}\r\n\t//Methods\r\n\tscan(o, I, output) { //Scan the file by searching plate/well data and execute the actions required\r\n\t\tlet plate = Editor.Plate;\r\n\t\tif(plate === undefined) {return Promise.resolve({Error: \"No plate defined, cannot validate the well data now\"})} //Failure \r\n\t\tlet w = this.WellCol;\r\n\t\tlet p = this.PlateCol;\r\n\t\treturn new Promise(function(resolve) {\r\n\t\t\to.Parser.stream(function(row, selected, parser) { //Stream the input\r\n\t\t\t\tlet well = Well.parseIndex(row[w], plate);\r\n\t\t\t\tif(well !== undefined && row[p] !== undefined) { //Valid well found in a valid plate, do what is needed\r\n\t\t\t\t\tif(I.Log) { //Log the data\r\n\t\t\t\t\t\tif(output.PlatesID.includes(row[p]) == false) {output.PlatesID.push(row[p])}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif(I.MinMax) {Mapper.scanMinMax(o, row)} //Log the min/max attributes\r\n\t\t\t\t\tif(I.Preview) { //Prepare a preview\r\n\t\t\t\t\t\tMapper.scanPreviewColumns(output, row, row[p] + \". \" + row[w] + \".\");\r\n\t\t\t\t\t\tif(output.LimitReached == true && I.Preview.Interrupt) {parser.abort()}\r\n\t\t\t\t\t}\r\n\t\t\t\t\toutput.Items++; //Increment the item count\r\n\t\t\t\t\tif(I.Custom) {I.Custom(well, row[p], row, output, parser)}\r\n\t\t\t\t}\r\n\t\t\t}, function() { //Do this when done\r\n\t\t\t\tresolve(output);\r\n\t\t\t});\r\n\t\t});\r\n\t}\r\n\tfind(o, I) { //Find the data when plate and well mapping are available\r\n\t\tlet plate = Editor.Plate;\r\n\t\tif(plate === undefined) {return Promise.resolve(\"\")} //Failure \r\n\t\tlet w = this.WellCol;\r\n\t\tlet p = this.PlateCol;\r\n\t\tlet out = I.Default; //Default fallback if the value is not found\r\n\t\tif(I.FindAll) {out = Array(plate.Rows * plate.Cols).fill(I.Default)}\r\n\t\treturn new Promise(function(resolve) { //Return a promise that fulfills with the data needed\r\n\t\t\to.Parser.stream(function(row, selected, parser) { //Do this for each row\r\n\t\t\t\tlet here = Well.parseIndex(row[w], plate);\r\n\t\t\t\tif(here !== undefined && row[p] !== undefined) { //Valid well found in a valid plate, do what is needed\r\n\t\t\t\t\tif(row[p] == I.Plate) { //This is the right plate\r\n\t\t\t\t\t\tif(I.FindAll) {\r\n\t\t\t\t\t\t\tout[here.Index] = row[I.Column];\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\tif(here.Index == I.Well) { //This is the correct location\r\n\t\t\t\t\t\t\t\tout = row[I.Column];\r\n\t\t\t\t\t\t\t\tparser.abort(); //Stop here since the data has been found\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}, function() { //Do this when done\r\n\t\t\t\tresolve(out);\r\n\t\t\t});\r\n\t\t});\r\n\t}\r\n}","//***********************************************************************************************\r\n// MAPPER_WELL object - Function to process a file that contains a mapping only for the well data\r\n//***********************************************************************************************\r\nclass Mapper_Well extends Mapper {\r\n\tconstructor(mapping) {\r\n\t\tsuper();\r\n\t\tthis.WellCol = mapping[Mapper.well().Name];\r\n\t\treturn this;\r\n\t}\r\n\t//Methods\r\n\tscan(o, I, output) { //Scan the file by searching well data and execute the actions required\r\n\t\tlet plate = Editor.Plate;\r\n\t\tif(plate === undefined) {return Promise.resolve({Error: \"No plate defined, cannot validate the well data now\"})} //Failure \r\n\t\toutput.PlatesID = Array(plate.Rows * plate.Cols).fill(0);\r\n\t\tlet w = this.WellCol;\r\n\t\treturn new Promise(function(resolve) {\r\n\t\t\to.Parser.stream(function(row, selected, parser) { //Stream the input\r\n\t\t\t\tlet well = Well.parseIndex(row[w], plate);\r\n\t\t\t\tif(well !== undefined) { //Valid well found, do what is needed\r\n\t\t\t\t\t//if(I.Log) {output.PlatesID[well.Index]++} //Log the data\r\n\t\t\t\t\toutput.PlatesID[well.Index]++;\r\n\t\t\t\t\tif(I.MinMax) {Mapper.scanMinMax(o, row)} //Log the min/max attributes\r\n\t\t\t\t\tif(I.Preview) { //Prepare a preview\r\n\t\t\t\t\t\tMapper.scanPreviewColumns(output, row, row[w] + \".\");\r\n\t\t\t\t\t\tif(output.LimitReached == true && I.Preview.Interrupt) {parser.abort()}\r\n\t\t\t\t\t}\r\n\t\t\t\t\toutput.Items++; //Increment the item count\r\n\t\t\t\t\tif(I.Custom) {I.Custom(well, output.PlatesID[well.Index], row, output, parser)}\r\n\t\t\t\t}\r\n\t\t\t}, function() { //Do this when done\r\n\t\t\t\tif(I.Log) {\r\n\t\t\t\t\tlet plateNb = 0;\r\n\t\t\t\t\toutput.PlatesID.forEach(function(n) {\r\n\t\t\t\t\t\tif(n > plateNb) {plateNb = n} //Search the max number of plates\r\n\t\t\t\t\t});\r\n\t\t\t\t\tlet array = [];\r\n\t\t\t\t\tfor(let i=0; i<plateNb; i++) {array.push(i+1)} //Build a default array with incrementing numbers\r\n\t\t\t\t\toutput.PlatesID = array;\r\n\t\t\t\t}\r\n\t\t\t\tresolve(output);\r\n\t\t\t});\r\n\t\t});\r\n\t}\r\n\tfind(o, I) { //Find the data when only well mapping is available\r\n\t\tlet plate = Editor.Plate;\r\n\t\tif(plate === undefined) {return Promise.resolve(\"\")} //Failure \r\n\t\tlet w = this.WellCol;\r\n\t\tI.Plate = Number(I.Plate) - 1; //We need to convert the generic plate name in a number. Plate numbering starts at 1\r\n\t\tlet index = 0;\r\n\t\tlet out = I.Default; //Default fallback if the value is not found\r\n\t\tif(I.FindAll) {\r\n\t\t\tout = Array(plate.Rows * plate.Cols).fill(I.Default);\r\n\t\t\tindex = Array(plate.Rows * plate.Cols).fill(0); \r\n\t\t}\r\n\t\treturn new Promise(function(resolve) { //Return a promise that fulfills with the data needed\r\n\t\t\to.Parser.stream(function(row, selected, parser) { //Do this for each row\r\n\t\t\t\tlet here = Well.parseIndex(row[w], plate);\r\n\t\t\t\tif(here !== undefined) { //Valid entry found, do what is needed\r\n\t\t\t\t\tif(I.FindAll) { //Log all the wells\r\n\t\t\t\t\t\tif(index[here.Index] == I.Plate) { //This entry corresponds to the desired plate\r\n\t\t\t\t\t\t\tout[here.Index] = row[I.Column];\r\n\t\t\t\t\t\t} \r\n\t\t\t\t\t\tindex[here.Index]++;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tif(here.Index == I.Well) { //This is the right well\r\n\t\t\t\t\t\t\tif(index == I.Plate) { //This is the right plate\r\n\t\t\t\t\t\t\t\tout = row[I.Column];\r\n\t\t\t\t\t\t\t\tparser.abort();\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\telse {index++}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}, function() { //Do this when done\r\n\t\t\t\tresolve(out);\r\n\t\t\t});\r\n\t\t});\r\n\t}\r\n}"]}